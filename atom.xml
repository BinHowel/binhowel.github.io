<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>双子星Binaryؼ</title>
  
  <subtitle>相逐彼此，却永不能触及</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shuhaohwang.github.io/"/>
  <updated>2019-09-20T07:59:05.526Z</updated>
  <id>https://shuhaohwang.github.io/</id>
  
  <author>
    <name>ShuHaoHwang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++进阶学习总结-(3.3)typename的使用场合及使用范例、函数指针参数化</title>
    <link href="https://shuhaohwang.github.io/2019/09/19/C-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-3-3-typename%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E5%90%88%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%8C%83%E4%BE%8B/"/>
    <id>https://shuhaohwang.github.io/2019/09/19/C-进阶学习总结-3-3-typename的使用场合及使用范例/</id>
    <published>2019-09-19T13:19:55.000Z</published>
    <updated>2019-09-20T07:59:05.526Z</updated>
    
    <content type="html"><![CDATA[<h4 id="typename的使用场合"><a href="#typename的使用场合" class="headerlink" title="typename的使用场合"></a>typename的使用场合</h4><h5 id="在类模板中存在自定义类型时-相关返回值函数必须添加typename"><a href="#在类模板中存在自定义类型时-相关返回值函数必须添加typename" class="headerlink" title="在类模板中存在自定义类型时 相关返回值函数必须添加typename"></a>在类模板中存在自定义类型时 相关返回值函数必须添加typename</h5><ul><li>范例：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">array</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*自定义类型：把模板参数T定义为 自定义类型名Size*/</span></span><br><span class="line">    <span class="keyword">typedef</span> T Size;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Size <span class="title">getsize</span><span class="params">(T i)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*类外定义的时候需要添加   typename 模板类名&lt;&gt;  来指定该模板类中的自定义类型Size*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">array</span>&lt;T&gt;::Size <span class="built_in">array</span>&lt;T&gt;::getsize(T i)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size的值为"</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">    arr.getsize(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果：<img src="/2019/09/19/C-进阶学习总结-3-3-typename的使用场合及使用范例/1.png"></p><h5 id="在类模板中存在内部类的情况"><a href="#在类模板中存在内部类的情况" class="headerlink" title="在类模板中存在内部类的情况"></a>在类模板中存在内部类的情况</h5><ul><li>范例:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lklist</span>&#123;</span></span><br><span class="line">    Node* head;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">      Node* next;</span><br><span class="line">        T data;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">GetNodeID</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> Lklist&lt;T&gt;::Node* Lklist&lt;T&gt;::GetNodeID(<span class="keyword">int</span> i)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"测试函数传参的值为 "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">Lklist&lt;<span class="keyword">int</span>&gt; lk;</span><br><span class="line">lk.GetNodeID(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果：<img src="/2019/09/19/C-进阶学习总结-3-3-typename的使用场合及使用范例/2.png"></p><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul><li>上述两种情况，在类模板外定义函数时，都必须要加typename 目的是通知编译器，该名称是一个类型名称，且为类模板内定义的类型或类。</li><li>上述情况只能用typename不能替换为class</li></ul><p>其余范例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> T::<span class="function">size_type <span class="title">getlength</span><span class="params">(<span class="keyword">const</span> T&amp;c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> c.size();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"HelloShuHao"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span>::size_type size = getlength(str);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"测试值:str的长度为："</span> &lt;&lt; size &lt;&lt; <span class="built_in">endl</span>;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果：<img src="/2019/09/19/C-进阶学习总结-3-3-typename的使用场合及使用范例/3.png"></p><hr><h4 id="函数指针作参数"><a href="#函数指针作参数" class="headerlink" title="函数指针作参数"></a>函数指针作参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*Func)</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i+k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testfunc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k, Func f)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"测试函数指针 两数相加的值为: "</span> &lt;&lt; f(i,k) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    testfunc(<span class="number">10</span>,<span class="number">15</span>,add);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果：<img src="/2019/09/19/C-进阶学习总结-3-3-typename的使用场合及使用范例/4.png"></p><hr><h4 id="typename使用范例"><a href="#typename使用范例" class="headerlink" title="typename使用范例"></a>typename使用范例</h4><h5 id="改造成函数模板"><a href="#改造成函数模板" class="headerlink" title="改造成函数模板"></a>改造成函数模板</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*Func)</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i+k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testfunc</span><span class="params">(T i, T k, F f)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"测试函数指针 两数相加的值为: "</span> &lt;&lt; f(i,k) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//此时F类型识别为函数指针，则使用函数指针类型</span></span><br><span class="line">    testfunc(<span class="number">10</span>,<span class="number">15</span>,add);<span class="comment">//依旧通过编译没有报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="若使用类-可调用对象"><a href="#若使用类-可调用对象" class="headerlink" title="若使用类(可调用对象)"></a>若使用类(可调用对象)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*Func)</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i+k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    TestClass()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"这是TC的构造函数 被调用了"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TestClass(<span class="keyword">const</span> TestClass&amp; t)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"拷贝构造函数 被调用了"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testfunc</span><span class="params">(T i, T k, F f)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"测试函数指针 两数相加的值为: "</span> &lt;&lt; f(i,k) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//此时F类型识别为函数指针，则使用函数指针类型</span></span><br><span class="line">    testfunc(<span class="number">10</span>,<span class="number">15</span>,add);<span class="comment">//依旧通过编译没有报错</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    TestClass tc;<span class="comment">//此时调用构造函数</span></span><br><span class="line">    testfunc(<span class="number">100</span>,<span class="number">150</span>,tc);<span class="comment">//传参是参数临时对象，调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实验结果</strong>：<img src="/2019/09/19/C-进阶学习总结-3-3-typename的使用场合及使用范例/5.png"></p><p><strong>结果分析</strong>：可以发现，当对象被创建时调用了一次构造函数，然后传参入<code>testfunc</code>函数时，调用了一次拷贝构造函数，最后输出值，整个过程，T的类型推断为int整型 然后 F被推断为TestClass类型，然后该类型对象通过重载后的()返回两个整型参数的和值。</p><h5 id="此时也可以通过直接传参消除临时对象"><a href="#此时也可以通过直接传参消除临时对象" class="headerlink" title="此时也可以通过直接传参消除临时对象"></a>此时也可以通过直接传参消除临时对象</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//TestClass tc;</span></span><br><span class="line">    </span><br><span class="line">    testfunc(<span class="number">100</span>,<span class="number">150</span>,TestClass());<span class="comment">//直接使用构造函数，可以消除临时对象的产生</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果：<img src="/2019/09/19/C-进阶学习总结-3-3-typename的使用场合及使用范例/6.png"></p><hr><h4 id="默认模板参数"><a href="#默认模板参数" class="headerlink" title="默认模板参数"></a>默认模板参数</h4><p>总体跟函数默认参数类似，从右到左，存在默认参数不能有断</p><ul><li>范例：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">int</span> a = <span class="number">100</span>&gt;class A&#123;&#125;;<span class="comment">//没有问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="built_in">string</span>,<span class="keyword">int</span> a = <span class="number">100</span>&gt;class B&#123;&#125;;<span class="comment">//没有问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="built_in">string</span>,<span class="keyword">int</span> a&gt;class C&#123;&#125;;<span class="comment">//报错！a没有提供默认参数</span></span><br></pre></td></tr></table></figure><p>—（本文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;typename的使用场合&quot;&gt;&lt;a href=&quot;#typename的使用场合&quot; class=&quot;headerlink&quot; title=&quot;typename的使用场合&quot;&gt;&lt;/a&gt;typename的使用场合&lt;/h4&gt;&lt;h5 id=&quot;在类模板中存在自定义类型时-相关返回值函数
      
    
    </summary>
    
      <category term="代码学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="C++学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/C-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C++" scheme="https://shuhaohwang.github.io/tags/C/"/>
    
      <category term="学习总结" scheme="https://shuhaohwang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="C++学习总结" scheme="https://shuhaohwang.github.io/tags/C-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>C++进阶学习总结-(3.2)类模板</title>
    <link href="https://shuhaohwang.github.io/2019/09/18/C-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-3-2-%E7%B1%BB%E6%A8%A1%E6%9D%BF/"/>
    <id>https://shuhaohwang.github.io/2019/09/18/C-进阶学习总结-3-2-类模板/</id>
    <published>2019-09-18T15:29:16.000Z</published>
    <updated>2019-09-20T07:58:58.939Z</updated>
    
    <content type="html"><![CDATA[<h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><h5 id="模板参数类型"><a href="#模板参数类型" class="headerlink" title="模板参数类型"></a>模板参数类型</h5><p>使类能够根据给定的实际类型，来对类内的一些参数类型进行变化</p><p>编译器不能为类模板推断模板参数类型，所以要使用类模板，必须要在模板名后用<code>&lt;&gt;</code>来提供实际类型</p><ul><li>格式：<ul><li><code>template&lt;typename T&gt;class 类名</code></li><li><code>template&lt;typename T，B&gt;class 类名</code></li><li><code>template&lt;typename T，int a&gt;class 类名</code></li></ul></li><li>注意：<ul><li>类模板成员函数，可以写在类模板定义中。(即：不在类外定义类成员函数）其中这种<strong>成员函数会隐式声明为<code>inline</code>内联函数</strong></li><li>类模板被实例化对象后，类内的对应的实例都会有自己版本的成员函数</li><li>在实例化类模板对象的时候，要在类模板名后加&lt;&gt;并给定实际类型</li><li>定义在类模板之外的成员函数必须以<code>template</code>关键字开头，后面加类模板的参数列表。其次类名后面要添加&lt;&gt;吧模板参数列表里面<strong>的所有模板参数名列出来</strong>(多个参数用 <code>,</code> 隔开)</li></ul></li><li>范例：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">Sqlist</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">  T* data;<span class="comment">//使用模板参数</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*类内定义的函数会隐式声明为inline函数*/</span></span><br><span class="line">    <span class="comment">/*inline*/</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"这是该类的func函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*外部定义，在外部要加&lt;&gt;*/</span></span><br><span class="line">    <span class="function">T <span class="title">func2</span><span class="params">(T a,T b)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*要类模板名要添加模板参数列表*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T Sqlist&lt;T&gt;::func2(T a,T b)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"这是该类的func2函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*在实例化类模板对象时，要用&lt;&gt;来提供实际类型*/</span></span><br><span class="line">    Sqlist&lt;<span class="keyword">int</span>&gt; sq1;</span><br><span class="line">    sq1.func();</span><br><span class="line">    </span><br><span class="line">    Sqlist&lt;<span class="keyword">double</span>&gt; sq2;</span><br><span class="line">    sq2.func2(<span class="number">12.3</span>,<span class="number">14.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果：<img src="/2019/09/18/C-进阶学习总结-3-2-类模板/1.png"></p><hr><h5 id="非模板类型"><a href="#非模板类型" class="headerlink" title="非模板类型"></a>非模板类型</h5><p>在定义模板类的时候模板参数不提供模板参数，而是给定实际参数</p><ul><li><p>格式：</p><ul><li><code>template&lt;int a&gt;class 类名</code></li><li><code>template&lt;typename T，int a&gt;class 类名</code></li></ul></li><li><p>范例：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">int</span> size = <span class="number">10</span>&gt;class Sqlist&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  T data[size];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*要在类模板后的&lt;&gt;把所有的类模板参数列出来，即便存在默认值*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">int</span> size&gt; <span class="keyword">void</span> Sqlist&lt;T,size&gt;::func()&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"这是该类的func函数 其中size: "</span> &lt;&lt; size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*存在默认参数可以不给size的值*/</span></span><br><span class="line">    Sqlist&lt;<span class="keyword">int</span>&gt; sq1;</span><br><span class="line">    sq1.func();</span><br><span class="line">    Sqlist&lt;<span class="keyword">double</span>,<span class="number">100</span>&gt; sq2;</span><br><span class="line">    sq2.func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果：<img src="/2019/09/18/C-进阶学习总结-3-2-类模板/2.png"></p><ul><li><strong>注意：</strong><ul><li>浮点数不能作为非类型模板参数<ul><li><code>template&lt;typename T,double a&gt; class B //报错，double和float都不能做非类型模板参数</code></li></ul></li><li>类类型不能做非类型模板参数<ul><li><code>class A{};template&lt;typename T,A a&gt; class B //报错：类类型不能做非类型模板参数</code></li></ul></li></ul></li></ul><p>—（本文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;类模板&quot;&gt;&lt;a href=&quot;#类模板&quot; class=&quot;headerlink&quot; title=&quot;类模板&quot;&gt;&lt;/a&gt;类模板&lt;/h4&gt;&lt;h5 id=&quot;模板参数类型&quot;&gt;&lt;a href=&quot;#模板参数类型&quot; class=&quot;headerlink&quot; title=&quot;模板参数类型&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="代码学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="C++学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/C-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C++" scheme="https://shuhaohwang.github.io/tags/C/"/>
    
      <category term="学习总结" scheme="https://shuhaohwang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="C++学习总结" scheme="https://shuhaohwang.github.io/tags/C-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>C++进阶学习总结-（3.1）模板、函数模板</title>
    <link href="https://shuhaohwang.github.io/2019/09/17/C-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%883-1%EF%BC%89%E6%A8%A1%E6%9D%BF%E3%80%81%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/"/>
    <id>https://shuhaohwang.github.io/2019/09/17/C-进阶学习总结-（3-1）模板、函数模板/</id>
    <published>2019-09-17T14:54:58.000Z</published>
    <updated>2019-09-20T07:58:30.842Z</updated>
    
    <content type="html"><![CDATA[<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>所谓泛型编程 是独立于任何特定类型类型的方式编写代码。使用泛型编程时，需要<strong>提供具体的程序实例</strong>。</p><p>模板是泛型编程的基础，是一种在创建类或函数时的一种公式，根据给定的类型来决定公式中具体参数的类型值。</p><hr><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><h5 id="函数模板定义与使用"><a href="#函数模板定义与使用" class="headerlink" title="函数模板定义与使用"></a>函数模板定义与使用</h5><p>会更具实际类型来推断模板实际类型的函数，一般情况下会编译器会自动判别。</p><ul><li>格式：<ul><li><code>template&lt;typename T&gt; T 函数名(参数)</code></li><li><code>template&lt;class T&gt; T 函数名(参数)</code></li></ul></li></ul><p>范例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">add</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"12 + 13 = "</span> &lt;&lt; add(<span class="number">12</span>,<span class="number">13</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"5.6 + 12.3 = "</span> &lt;&lt; add(<span class="number">5.6</span>,<span class="number">12.3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果：</p><p>实际上，函数模板会更具你实际给定的对象类型来生成对应的函数。例如：如果你给定T的类型为double，则系统会生成<code>double add(double a,double b)</code>给定整型int则会生成对应的函数<code>int add(int a,int b)</code>。</p><h5 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h5><p>在模板参数列表中没有使用类型参数，而是给定实际的类型的参数</p><ul><li>格式：<code>template&lt;实际类型 T&gt;</code></li></ul><p>范例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*需要在&lt;&gt;给定实际类型才能调用*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> a,<span class="keyword">int</span> b&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*混合型*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">int</span> a,<span class="keyword">int</span> b&gt;</span><br><span class="line"><span class="function">T <span class="title">add2</span><span class="params">(T c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = c;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a + b + (<span class="keyword">int</span>)c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*特殊：不用提供实际类型，由系统自动推断*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> L1,<span class="keyword">unsigned</span> L2&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">charscomp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>(&amp;p1)[L1],<span class="keyword">const</span> <span class="keyword">char</span>(&amp;p2)[L2])</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"12 + 13 = "</span> &lt;&lt; add1&lt;<span class="number">12</span>,<span class="number">13</span>&gt;() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*不需要在&lt;&gt;中给定实际类型*/</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; charscomp(<span class="string">"ShuHao"</span>,<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p>如果要声明函数模板为内联函数，那么inline关键字要在template与函数返回值之间。例如: <code>template&lt;typename T, int a&gt; inline T func(T b){return b+a}</code></p></li><li><p>模板函数一般放在头文件中，再多个CPP文件中include该头文件不会出现函数重定义</p></li></ul><p>—（本文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;模板&quot;&gt;&lt;a href=&quot;#模板&quot; class=&quot;headerlink&quot; title=&quot;模板&quot;&gt;&lt;/a&gt;模板&lt;/h4&gt;&lt;p&gt;所谓泛型编程 是独立于任何特定类型类型的方式编写代码。使用泛型编程时，需要&lt;strong&gt;提供具体的程序实例&lt;/strong&gt;。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="代码学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="C++学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/C-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C++" scheme="https://shuhaohwang.github.io/tags/C/"/>
    
      <category term="学习总结" scheme="https://shuhaohwang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="C++学习总结" scheme="https://shuhaohwang.github.io/tags/C-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>C++进阶学习总结-(2.11)类型转换构造函数、运算符、类成员指针</title>
    <link href="https://shuhaohwang.github.io/2019/09/11/C-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2-11-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E7%B1%BB%E6%88%90%E5%91%98%E6%8C%87%E9%92%88/"/>
    <id>https://shuhaohwang.github.io/2019/09/11/C-进阶学习总结-2-11-类型转换构造函数、运算符、类成员指针/</id>
    <published>2019-09-10T16:39:32.000Z</published>
    <updated>2019-09-20T07:58:52.476Z</updated>
    
    <content type="html"><![CDATA[<h4 id="类型转换构造函数"><a href="#类型转换构造函数" class="headerlink" title="类型转换构造函数"></a>类型转换构造函数</h4><p>实质：把某个类型的变量，通过类的构造函数隐式转换变为该类类型的变量。</p><p>例如：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    A(<span class="keyword">int</span> i):num(i)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    A a = k;<span class="comment">//使整型k转换类型为A</span></span><br><span class="line">    A a2 = <span class="number">120</span>; <span class="comment">//把整型转换成类型A变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h4><p>与类型转换构造函数的作用相反，类型转换构造函数是将某个类型转换成该类类型，而类型转换运算符则把该类类型转换成特点的类型</p><p>定义格式：<code>operator type()</code>||<code>operator type() const</code>(一般会加const后缀，防止值被修改)</p><p>例如：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">    A(<span class="keyword">int</span> i):num(i)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">  <span class="keyword">int</span> k = a + <span class="number">100</span>;<span class="comment">//结果K的值为200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="显示调用类型转换运算符"><a href="#显示调用类型转换运算符" class="headerlink" title="显示调用类型转换运算符"></a>显示调用类型转换运算符</h5><p>即：把类型转换运算符当做该类对象的成员函数进行调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">  <span class="keyword">int</span> k = a.<span class="keyword">operator</span> <span class="keyword">int</span>() + <span class="number">100</span>;<span class="comment">//显示调用类型转换运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="禁止使用隐式调用类型转换运算符"><a href="#禁止使用隐式调用类型转换运算符" class="headerlink" title="禁止使用隐式调用类型转换运算符"></a>禁止使用隐式调用类型转换运算符</h5><p>对类型转换构造函数同时适用：在前面加<code>explicit</code>(禁止编译器为我们做隐式类型转换)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">    A(<span class="keyword">int</span> i):num(i)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">  <span class="keyword">int</span> k = a + <span class="number">100</span>;<span class="comment">//报错，</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2019/09/11/C-进阶学习总结-2-11-类型转换构造函数、运算符、类成员指针/1.png"><hr><h4 id="类成员指针"><a href="#类成员指针" class="headerlink" title="类成员指针"></a>类成员指针</h4><h5 id="类成员函数指针"><a href="#类成员函数指针" class="headerlink" title="类成员函数指针"></a>类成员函数指针</h5><ul><li>定义：指向类成员函数的指针</li><li><p>格式：</p><ul><li>声明普通成员函数指针：<code>类名：：*函数指针变量名</code></li><li>获取类成员函数地址：<code>&amp;类名：：成员函数名</code></li><li>使用函数指针格式：<code>(类对象名.*函数指针变量名)(参数)</code>（若为对象指针则使用<code>-&gt;</code>指向运算符调用）</li></ul></li></ul><h6 id="普通成员函数"><a href="#普通成员函数" class="headerlink" title="普通成员函数"></a>普通成员函数</h6><p><strong>注意点</strong>：成员函数属于类，只要类存在这函数地址就存在(有无对象被创建没关系)、<strong>若要使用成员函数指针需要绑定到一个类对象上去</strong></p><ul><li>范例：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Afunc</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"这是类A中的普通成员函数Afunc，参数I："</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*声明函数指针*/</span></span><br><span class="line">    <span class="keyword">void</span>(A::*Func)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="comment">/*给函数指针赋予类成员函数地址值*/</span></span><br><span class="line">    Func = &amp;A::Afunc;</span><br><span class="line">    </span><br><span class="line">    A a;</span><br><span class="line">    A* a2;</span><br><span class="line">    (a.*Func)(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//(a2-&gt;*Func)(200);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果：<img src="/2019/09/11/C-进阶学习总结-2-11-类型转换构造函数、运算符、类成员指针/2.png"></p><h6 id="虚成员函数"><a href="#虚成员函数" class="headerlink" title="虚成员函数"></a>虚成员函数</h6><ul><li>范例：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Afunc</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"这是类A中的普通成员函数Afunc，参数I："</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virtualFunc</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"这是类A中的虚成员函数virtualFunc，参数I："</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*声明函数指针*/</span></span><br><span class="line">    <span class="keyword">void</span>(A::*virtualFunc)(<span class="keyword">int</span>) = &amp;A::virtualFunc;</span><br><span class="line">    A a;</span><br><span class="line">    (a.*Func)(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  实验结果：<img src="/2019/09/11/C-进阶学习总结-2-11-类型转换构造函数、运算符、类成员指针/3.png"></p><h6 id="静态类成员函数"><a href="#静态类成员函数" class="headerlink" title="静态类成员函数"></a>静态类成员函数</h6><ul><li>格式：<ul><li>声明普通成员函数指针：<code>*函数指针名</code>   (eg: <code>void(*staticFunc)(int)</code>)</li><li>获取地址：<code>&amp;类名：：成员函数名</code></li><li>使用：直接 <code>函数指针名(参数)</code></li></ul></li></ul><hr><h5 id="类成员变量"><a href="#类成员变量" class="headerlink" title="类成员变量"></a>类成员变量</h5><p>格式：</p><ul><li>定义指针: <code>类型 类名：：*指针名</code></li><li>获取地址: <code>&amp;类名：：成员变量名</code></li></ul><p><strong>注意：</strong>此时获取的地址<u>不是该成员变量在内存中的地址</u>，而是对于类来说的偏移量</p><h6 id="普通成员变量"><a href="#普通成员变量" class="headerlink" title="普通成员变量"></a>普通成员变量</h6><p>范例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> num1;</span><br><span class="line">    <span class="keyword">int</span> num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> B::*P_num = &amp;B::num1;</span><br><span class="line">    </span><br><span class="line">    B b;</span><br><span class="line">    b.*P_num = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"此时类B中的成员变量num1的值为 "</span> &lt;&lt; b.num1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果：<img src="/2019/09/11/C-进阶学习总结-2-11-类型转换构造函数、运算符、类成员指针/4.png"></p><h6 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h6><p>范例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> num1;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num2;<span class="comment">//此时只是声明了一个静态变量。要在类外定义</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> B::num2 = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* static_P_num = &amp;B::num2;</span><br><span class="line">    </span><br><span class="line">    B b;</span><br><span class="line">    *static_P_num = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"此时类B中的静态成员变量num2的值为 "</span> &lt;&lt; b.num2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果：<img src="/2019/09/11/C-进阶学习总结-2-11-类型转换构造函数、运算符、类成员指针/5.png"></p><p>—（本文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;类型转换构造函数&quot;&gt;&lt;a href=&quot;#类型转换构造函数&quot; class=&quot;headerlink&quot; title=&quot;类型转换构造函数&quot;&gt;&lt;/a&gt;类型转换构造函数&lt;/h4&gt;&lt;p&gt;实质：把某个类型的变量，通过类的构造函数隐式转换变为该类类型的变量。&lt;/p&gt;
&lt;p&gt;例如：&lt;
      
    
    </summary>
    
      <category term="代码学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="C++学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/C-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C++" scheme="https://shuhaohwang.github.io/tags/C/"/>
    
      <category term="学习总结" scheme="https://shuhaohwang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="C++学习总结" scheme="https://shuhaohwang.github.io/tags/C-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>C++进阶学习总结-（2.10）构造函数继承、多继承、虚继承</title>
    <link href="https://shuhaohwang.github.io/2019/09/06/C-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-10%EF%BC%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E7%BB%A7%E6%89%BF/"/>
    <id>https://shuhaohwang.github.io/2019/09/06/C-进阶学习总结-（2-10）构造函数继承、多继承、虚继承/</id>
    <published>2019-09-05T16:21:49.000Z</published>
    <updated>2019-09-20T07:58:23.463Z</updated>
    
    <content type="html"><![CDATA[<h4 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h4><p>C++在继承的时候子类在构造的时候是会调用父类的构造函数的，但实际上，父类的默认构造函数、拷贝构造、移动构造函数是不会继承给子类的，子类只会继承父类由程序员自己定义的构造函数。</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> f_num;</span><br><span class="line">    </span><br><span class="line">    Father(<span class="keyword">int</span> i):f_num(i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"父类的构造函数被调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~Father()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"父类的析构函数被调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span>:</span><span class="keyword">public</span> Father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> c1_num;</span><br><span class="line">Child1(<span class="keyword">int</span> i):c1_num(i),Father(i)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"子类1的构造函数被调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Child1()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"子类1的析构函数被调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Child1 <span class="title">c</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实验结果：<img src="/2019/09/06/C-进阶学习总结-（2-10）构造函数继承、多继承、虚继承/1.png"></li></ul></li></ul><p>当父类中含有多个参数的构造函数时，子类也会继承与其，但是在子类的默认构造函数中不会调用父类的这些构造函数，而是会调用无参的父类的构造函数或者带有默认参数的构造函数。</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> f_num;</span><br><span class="line">  <span class="keyword">int</span> f_num2;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Father(<span class="keyword">int</span> i,<span class="keyword">int</span> k):f_num(i),f_num2(k)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"父类的构造函数被调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    Father(<span class="keyword">int</span> i = <span class="number">100</span>):f_num(i),f_num2(i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"父类的构造函数被调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~Father()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"父类的析构函数被调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span>:</span><span class="keyword">public</span> Father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> c1_num;</span><br><span class="line"></span><br><span class="line">Child1(<span class="keyword">int</span> i):c1_num(i)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"子类1的构造函数被调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Child1()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"子类1的析构函数被调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Child1 <span class="title">c</span><span class="params">(<span class="number">9</span>)</span></span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"父类的f_num： "</span>&lt;&lt;c.f_num &lt;&lt; <span class="string">"父类的f_num2："</span> &lt;&lt; c.f_num2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实验结果：<img src="/2019/09/06/C-进阶学习总结-（2-10）构造函数继承、多继承、虚继承/2.png"></li><li>结果分析：可以发现子类调用了父类的<code>Child1(int i = 100):c1_num(i),Father(i)</code></li></ul></li></ul><p>那如果要在子类对象再创建时调用父类的其他构造函数该怎么办呢？除了在子类的构造函数里调用的方法外还可以使用<strong>using</strong>关键字实现</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span>:</span><span class="keyword">public</span> Father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> c1_num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Father::Father;<span class="comment">//使用using关键字</span></span><br><span class="line"></span><br><span class="line">Child1(<span class="keyword">int</span> i):c1_num(i)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"子类1的构造函数被调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Child1()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"子类1的析构函数被调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Child1 <span class="title">c</span><span class="params">(<span class="number">9</span>,<span class="number">2</span>)</span></span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"父类的f_num： "</span>&lt;&lt;c.f_num &lt;&lt; <span class="string">"父类的f_num2："</span> &lt;&lt; c.f_num2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实验结果：<img src="/2019/09/06/C-进阶学习总结-（2-10）构造函数继承、多继承、虚继承/3.png"></li><li>结果分析：使用<code>using Father::Father;</code>发现子类在没有创建2个参数的构造函数也可以用两个参数进行调用构造函数，原因是使用<code>using Father::Father;</code>后编译器会在子类创建隐藏的含有两个参数的构造函数，用来调用父类的其他构造函数。</li></ul></li></ul><h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p>C++中，如果父类含有多个构造函数，多数下会全部继承，但有以下例外：</p><ul><li>子类中的构造函数与父类的构造函数有相同的参数列表，则子类会覆盖父类的构造函数，导致无法继承父类的构造函数</li><li>默认构造函数，移动、拷贝构造函数不会被继承。</li></ul><hr><h4 id="多重继承与虚继承"><a href="#多重继承与虚继承" class="headerlink" title="多重继承与虚继承"></a>多重继承与虚继承</h4><h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p>C++允许多继承，一个子类在多继承时，会存在两个或以上个父类，也意味着，该子类会继承多个父类的成员变量、成员函数。</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">    A(<span class="keyword">int</span> i):a(i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了A的构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~A()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    </span><br><span class="line">    B(<span class="keyword">int</span> i):b(i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了B的构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~B()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*C同时继承A和B*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> B,<span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> c</span><br><span class="line">    C(<span class="keyword">int</span> i):c(i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了C的构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~C()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">c</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实验结果：<img src="/2019/09/06/C-进阶学习总结-（2-10）构造函数继承、多继承、虚继承/4.png"></li><li>结果分析：结果发现，在创建C类对象时，调用了A和B的构造函数。</li></ul></li></ul><p>上述的多继承父类构造函数调用顺序是根据子类的继承(派生列表)顺序来决定的，例如上面是先继承B在继承A，则先调用B的构造函数再调用A的构造函数。如果先继承A再继承B则：<img src="/2019/09/06/C-进阶学习总结-（2-10）构造函数继承、多继承、虚继承/5.png"></p><h5 id="多重继承引发的问题"><a href="#多重继承引发的问题" class="headerlink" title="多重继承引发的问题"></a>多重继承引发的问题</h5><h6 id="多继承引发的父类创建累赘多余对象问题"><a href="#多继承引发的父类创建累赘多余对象问题" class="headerlink" title="多继承引发的父类创建累赘多余对象问题"></a>多继承引发的父类创建累赘多余对象问题</h6><p>当一个子类继承两个类的时候，恰好被继承的两个类又继承于同一个父类，那么该子类在创建对象的时候就会调用两次该父类的构造函数，这样的操作难免会造成程序效率低下的情况</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">father</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span></span><br><span class="line">    <span class="keyword">int</span> father_num;</span><br><span class="line">    father()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了father类的构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> :</span><span class="keyword">public</span> father&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a1;</span><br><span class="line">    </span><br><span class="line">    A1(<span class="keyword">int</span> i):a1(i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了A1的构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~A1()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span>:</span><span class="keyword">public</span> father&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a2;</span><br><span class="line">    </span><br><span class="line">    A2(<span class="keyword">int</span> i):a2(i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了A2的构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~A2()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*C同时继承A1和A2*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A2,<span class="keyword">public</span> A1&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    C(<span class="keyword">int</span> i):c(i),A1(i),A2(i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了C的构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~C()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">c</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实验结果：<img src="/2019/09/06/C-进阶学习总结-（2-10）构造函数继承、多继承、虚继承/6.png"></li><li>结果分析：可以发现，在创建类C对象的时候，调用了两次father类的构造函数，也就意味着本来编译器创建了多余的无意义的父类对象，要解决它则可以使用虚继承。</li></ul></li></ul><h6 id="多继承引发的二义性问题"><a href="#多继承引发的二义性问题" class="headerlink" title="多继承引发的二义性问题"></a>多继承引发的二义性问题</h6><ul><li><p><strong>产生二义性</strong>：不明确使用的变量或者函数属于哪一个类（例如上方代码中创建好的c进行调用father类中的father_num变量）</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">c</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c.father_num &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//报错，调用变量不明确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><img src="/2019/09/06/C-进阶学习总结-（2-10）构造函数继承、多继承、虚继承/7.png"></li><li><p><u><strong>解决方案</strong></u>：使用作用域运算符（例如：<code>cout &lt;&lt; c.A2::father_num &lt;&lt; endl;</code>）</p></li></ul></li></ul><hr><h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><p>为了解决上诉父类创建多余对象可以使用虚继承进行继承，这样该父类就会成为虚基类。</p><ul><li>虚基类(virtual base class)：无论这个类在继承体现中出现多少次，派生类中，都只包含唯一一个共享的虚基类的子内容</li></ul><p>例如：</p><ul><li><p>代码：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用虚继承*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> father&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a1;</span><br><span class="line">    </span><br><span class="line">    A1(<span class="keyword">int</span> i):a1(i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了A1的构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~A1()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用虚继承*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> father&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a2;</span><br><span class="line">    </span><br><span class="line">    A2(<span class="keyword">int</span> i):a2(i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了A2的构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~A2()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*C同时继承A1和A2*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A2,<span class="keyword">public</span> A1&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    C(<span class="keyword">int</span> i):c(i),A1(i),A2(i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了C的构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~C()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">c</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c.father_num &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//没有报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实验结果：<img src="/2019/09/06/C-进阶学习总结-（2-10）构造函数继承、多继承、虚继承/8.png"></p></li><li><p>结果分析：发现此时进行创建类C的对象的时候，father类的构造函数只被调用了一次，且能消除一部分调用父类的变量或者函数时的二义性。</p></li></ul></li></ul><h5 id="需要注意！！："><a href="#需要注意！！：" class="headerlink" title="需要注意！！："></a>需要注意！！：</h5><p>此时的继承调用构造函数顺序也会发生改变，这里会先构造出虚继承的父类，然后再按照派生列表进行调用其他函数的构造函数。</p><ul><li><p>例如：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*C同时继承A1和A2、B*/</span></span><br><span class="line"><span class="comment">/*其中A1,A2虚继承了虚基类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> B,<span class="keyword">public</span> A2,<span class="keyword">public</span> A1&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    C(<span class="keyword">int</span> i):c(i),A1(i),A2(i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了C的构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~C()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="function">C <span class="title">c</span><span class="params">(<span class="number">1</span>)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实验结果：<img src="/2019/09/06/C-进阶学习总结-（2-10）构造函数继承、多继承、虚继承/9.png"></p></li><li><p>结果分析：依旧先调用father的构造函数，而不会根据派生列表顺序先进行调用类B的构造函数。</p></li></ul></li></ul><p>—（本文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;构造函数继承&quot;&gt;&lt;a href=&quot;#构造函数继承&quot; class=&quot;headerlink&quot; title=&quot;构造函数继承&quot;&gt;&lt;/a&gt;构造函数继承&lt;/h4&gt;&lt;p&gt;C++在继承的时候子类在构造的时候是会调用父类的构造函数的，但实际上，父类的默认构造函数、拷贝构造、移动构造
      
    
    </summary>
    
      <category term="代码学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="C++学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/C-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C++" scheme="https://shuhaohwang.github.io/tags/C/"/>
    
      <category term="学习总结" scheme="https://shuhaohwang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="C++学习总结" scheme="https://shuhaohwang.github.io/tags/C-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>C++进阶学习总结-（2.9）移动构造函数、移动运算符</title>
    <link href="https://shuhaohwang.github.io/2019/09/02/C-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-9%EF%BC%89%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E7%A7%BB%E5%8A%A8%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://shuhaohwang.github.io/2019/09/02/C-进阶学习总结-（2-9）移动构造函数、移动运算符/</id>
    <published>2019-09-01T23:00:24.000Z</published>
    <updated>2019-09-20T07:58:16.319Z</updated>
    
    <content type="html"><![CDATA[<h4 id="移动对象与移动构造函数"><a href="#移动对象与移动构造函数" class="headerlink" title="移动对象与移动构造函数"></a>移动对象与移动构造函数</h4><ul><li><strong>移动对象</strong>：移动对象与拷贝对象不同的是，移动对象更像把所有权进行转交，例如要把对象B赋值给A，通常上会进行<u>拷贝操作，即进行：创建B对象(开辟新内存空间)，把A的内容逐一拷贝进B，再把对象A进行释放，这一系列的操作会产生临时的对象</u>。在总体上来说进行了创建和拷贝这两步操作会使程序运行效率大大折扣，但<u>移动对象就不同了，它进行的是转交内存的操作</u>，即直接把A对象的相关数据内存地址直接转交给对象B从而跳过了创建对象和拷贝对象的两个操作。</li></ul><h5 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h5><p>C++11新出的移动构造函数对于拷贝构造函数来说，就是专门进行移动对象而设计的。</p><ul><li><p>示例：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> ID;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    student(<span class="keyword">int</span> i,<span class="built_in">string</span> n):ID(i),name(n)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了Student类的构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*拷贝构造函数*/</span></span><br><span class="line">    student(<span class="keyword">const</span> student&amp; temp):ID(temp.ID),name(temp.name)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*拷贝赋值运算符*/</span></span><br><span class="line">    student&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> student&amp; temp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(&amp;temp == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        </span><br><span class="line">        ID = temp.ID;</span><br><span class="line">        name = temp.name;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"使用了拷贝赋值运算符"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> student <span class="title">getStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        student a;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    student person = getStudent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实验结果<img src="/2019/09/02/C-进阶学习总结-（2-9）移动构造函数、移动运算符/1.png"></p></li></ul></li><li><p><strong>结果分析</strong>：从运行结果来看。这个<code>getStudent()</code> 函数在进行的时候，在里面首先创建了对象<code>&#39;a&#39;</code>进而调用了构造函数，然后在<code>return a</code>这步中生成了临时对象a，把函数原有的对象a拷贝给了临时对象a，并把临时对象返回出去(因为函数体内的对象a生命期只在函数体内，所以在返回时会创建临时对象a进行返回)。</p></li></ul><h6 id="移动构造函数的使用"><a href="#移动构造函数的使用" class="headerlink" title="移动构造函数的使用"></a>移动构造函数的使用</h6><p>从结果来看：这里是进行了拷贝操作，难免会出现对象创建、拷贝等影响效率的操作，但对于<strong>这里临时对象a再使用后便可不再重复利用</strong>的对象使用移动对象进行操作时比进行拷贝操作时的程序效率更高，因为进行移动操作对象就不必再创建新的对象，使用额外的内存空间去保存一次性使用的对象了。</p><ul><li><p>代码：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*移动构造函数*/</span></span><br><span class="line">student (student&amp;&amp; temp) <span class="keyword">noexcept</span> :ID(temp.ID),name(temp.name)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了移动构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实验结果：<img src="/2019/09/02/C-进阶学习总结-（2-9）移动构造函数、移动运算符/2.png"></p></li></ul></li><li><p><strong>结果分析</strong>：可以发现此时的临时对象则调用了移动构造函数来进行返回。</p><ul><li><strong>noexcept</strong>：通知编译器这里不会产生异常，<u>任何移动对象有关的函数无论是声明还是定义都得加</u><code>noexcept</code></li></ul></li></ul><h6 id="提要："><a href="#提要：" class="headerlink" title="提要："></a>提要：</h6><p>在<code>getStudent()</code>函数中是产生了临时对象才会调用拷贝构造函数，如果消除此处的临时对象则不会调用拷贝构造函数</p><img src="/2019/09/02/C-进阶学习总结-（2-9）移动构造函数、移动运算符/3.png"><hr><h4 id="移动赋值运算符"><a href="#移动赋值运算符" class="headerlink" title="移动赋值运算符"></a>移动赋值运算符</h4><p>相比拷贝赋值运算符，移动赋值运算符是专门对赋值是移动对象使用的</p><ul><li><p>代码：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*移动赋值运算符*/</span></span><br><span class="line"> student&amp; <span class="keyword">operator</span>= (student&amp;&amp; temp)<span class="keyword">noexcept</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (&amp;temp == <span class="keyword">this</span>)</span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> ID = temp.ID;</span><br><span class="line"> name = temp.name;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"使用了移动赋值运算符"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>但在实际运用中，系统会默认使用拷贝赋值运算符进行拷贝赋值操作。</p><img src="/2019/09/02/C-进阶学习总结-（2-9）移动构造函数、移动运算符/4.png"><p>只有在特点情况下才会优先使用移动赋值运算符，在上面的<code>getStudent()</code>函数中，只有产生了临时对象才会调用移动构造函数，而没有产生临时对象则不会调用，说明移动对象与临时变量有充分的联系，即：对右值的变量会使用移动构造函数。</p><h6 id="移动赋值运算符使用条件"><a href="#移动赋值运算符使用条件" class="headerlink" title="移动赋值运算符使用条件"></a>移动赋值运算符使用条件</h6><ul><li>在进行移动赋值的时候要确保原有的对象<strong>处于一种即便销毁也不再使用</strong>的情况下，则可以使用移动对象操作。(通俗点讲就是：要进行移动操作，原来的对象不能再使用)。</li><li>原对象为临时变量。即：原对象为右值时。(<code>std::move()</code>函数就派上用场了)</li></ul><img src="/2019/09/02/C-进阶学习总结-（2-9）移动构造函数、移动运算符/5.png"><hr><h4 id="移动对象时要注意的点"><a href="#移动对象时要注意的点" class="headerlink" title="移动对象时要注意的点"></a>移动对象时要注意的点</h4><h5 id="当类中包含指针的时"><a href="#当类中包含指针的时" class="headerlink" title="当类中包含指针的时"></a>当类中包含指针的时</h5><ul><li><p>当类中包含指针成员的时候，在进行移动操作的时候要把原有的对象里的指针置零。</p></li><li><p>移动时要确保该指针断绝原对象的关系，以免在原对象释放的时候对该指针也进行释放，对移动后对象产生不可预料的危险</p></li><li>在进行移动赋值的时候，<strong>要先把自己对象中的指针先释放掉，再进行赋值</strong>，并把原对象的指针要置零。</li></ul><p><strong>实例：</strong></p><ul><li><p>代码：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span> num1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> i = <span class="number">0</span>):num1(i)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    A* temp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B():temp(<span class="keyword">new</span> A())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了类B的构造函数 "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    B(<span class="keyword">const</span> B&amp; t):temp(t.temp)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了类B的拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*拷贝赋值运算符*/</span></span><br><span class="line">    B&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> B&amp; t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;t)<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"使用了类B的拷贝赋值运算符"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        temp = t.temp;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*移动构造函数*/</span></span><br><span class="line">    B(B&amp;&amp; t)<span class="keyword">noexcept</span>:temp(t.temp)&#123;</span><br><span class="line">        t.temp = <span class="literal">nullptr</span>;<span class="comment">//要把原来的指针进行置零</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了类B的移动构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    B&amp; <span class="keyword">operator</span>=(B&amp;&amp; t)<span class="keyword">noexcept</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">delete</span> temp;<span class="comment">//移动赋值时先要释放自己原有的内存地址</span></span><br><span class="line">        temp = t.temp;</span><br><span class="line">        t.temp = <span class="literal">nullptr</span>;<span class="comment">//赋值后要把原对象的指针置零，防止在原对象释放时，该指针跟着释放</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"使用了类B的移动赋值运算符"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>—（本文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;移动对象与移动构造函数&quot;&gt;&lt;a href=&quot;#移动对象与移动构造函数&quot; class=&quot;headerlink&quot; title=&quot;移动对象与移动构造函数&quot;&gt;&lt;/a&gt;移动对象与移动构造函数&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;移动对象&lt;/strong&gt;：移动对象与拷
      
    
    </summary>
    
      <category term="代码学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="C++学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/C-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C++" scheme="https://shuhaohwang.github.io/tags/C/"/>
    
      <category term="学习总结" scheme="https://shuhaohwang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="C++学习总结" scheme="https://shuhaohwang.github.io/tags/C-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计（二）</title>
    <link href="https://shuhaohwang.github.io/2019/08/29/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://shuhaohwang.github.io/2019/08/29/概率论与数理统计（二）/</id>
    <published>2019-08-29T15:09:59.000Z</published>
    <updated>2019-08-29T15:33:01.175Z</updated>
    
    <content type="html"><![CDATA[<h4 id="条件概率与乘法公式"><a href="#条件概率与乘法公式" class="headerlink" title="条件概率与乘法公式"></a>条件概率与乘法公式</h4><ul><li><p>条件概率：</p><ul><li>P(B|A) = P(AB) / P(A)</li><li>P(A|B) = P(AB) / P(B)</li></ul></li><li><p>乘法公式</p><ul><li>P(AB) = P(A) - P(B|A) = P(B) - P(A|B)</li></ul></li></ul><hr><h4 id="全概率公式与贝叶斯公式"><a href="#全概率公式与贝叶斯公式" class="headerlink" title="全概率公式与贝叶斯公式"></a>全概率公式与贝叶斯公式</h4><ul><li><p>全概率公式：</p><ul><li><script type="math/tex; mode=display">P(A) = \sum_{i=1}^nP(B_i)P(A|B_i)</script></li><li><p>P(A) 要发生的事件的概率</p></li><li><p>P(B<sub>i</sub>)为A发生的前提事件的概率</p></li><li><p>P(A|B<sub>i</sub>)为B<sub>i</sub>事件已经发生后的前提下，A事件发生的概率</p></li></ul></li><li><p>贝叶斯公式：（逆概率公式）</p><ul><li><script type="math/tex; mode=display">P(B_i|A) = \frac {P(B_i)P(A|B_i)}{P(A)}</script></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;条件概率与乘法公式&quot;&gt;&lt;a href=&quot;#条件概率与乘法公式&quot; class=&quot;headerlink&quot; title=&quot;条件概率与乘法公式&quot;&gt;&lt;/a&gt;条件概率与乘法公式&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;条件概率：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;P(B|A) = P(AB)
      
    
    </summary>
    
    
      <category term="学习总结" scheme="https://shuhaohwang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="其他" scheme="https://shuhaohwang.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计（一）</title>
    <link href="https://shuhaohwang.github.io/2019/08/28/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://shuhaohwang.github.io/2019/08/28/概率论与数理统计（一）/</id>
    <published>2019-08-28T14:43:55.000Z</published>
    <updated>2019-08-28T15:39:12.051Z</updated>
    
    <content type="html"><![CDATA[<h4 id="事件运算及概率"><a href="#事件运算及概率" class="headerlink" title="事件运算及概率"></a>事件运算及概率</h4><ul><li>事件运算<ul><li>包含事件<ul><li>A</li></ul></li><li>并事件<ul><li>A∪B = A+B</li></ul></li><li>差事件<ul><li>A - B  = AC<sub>B</sub> = A - AB</li></ul></li><li>交事件<ul><li>A∩B = AB</li></ul></li><li>互斥事件<ul><li>AB = ∅</li></ul></li><li>对立事件<ul><li>A∪C<sub>A</sub> = S; AC<sub>A</sub>  = ∅</li></ul></li><li>独立事件<ul><li><code>P(AB) = P(A)P(B)</code></li></ul></li></ul></li><li>其他：<ul><li><strong>A、B独立：</strong><ul><li>A、C<sub>B</sub>     C<sub>A</sub>、B    C<sub>A</sub>、C<sub>B</sub>互相独立</li></ul></li><li><strong>A、B、C独立：</strong><ul><li>A、B、C两两相互独立(充分不必要)</li><li><code>P(ABC) = P(A)P(B)P(C)</code></li></ul></li></ul></li></ul><hr><h4 id="公式："><a href="#公式：" class="headerlink" title="公式："></a>公式：</h4><ul><li><p>德摩根率：</p><ul><li><script type="math/tex; mode=display">C_{A∪B} = C_A · C_B</script></li><li><script type="math/tex; mode=display">C_{A∪B} = C_A∪C_B</script></li></ul></li></ul><ul><li><p>加法公式</p><ul><li><script type="math/tex; mode=display">P(A∪B) = P(A) + P(B) - P(AB）</script></li><li><script type="math/tex; mode=display">P(A∪B∪C) = P(A) + P(B) + P(C) - P(AB) - P(AC) - P(BC) + P(ABC)</script></li></ul></li></ul><ul><li><p>减法公式</p><ul><li><script type="math/tex; mode=display">P(A-B) = P(AC_B) = P(A) - P(AB)</script></li></ul></li><li><p>对立事件</p><ul><li><script type="math/tex; mode=display">P(C_A) = 1 - P(A)</script></li></ul></li><li><p>独立事件</p><ul><li><script type="math/tex; mode=display">P(AB) = P(A)·P(B)</script></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;事件运算及概率&quot;&gt;&lt;a href=&quot;#事件运算及概率&quot; class=&quot;headerlink&quot; title=&quot;事件运算及概率&quot;&gt;&lt;/a&gt;事件运算及概率&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;事件运算&lt;ul&gt;
&lt;li&gt;包含事件&lt;ul&gt;
&lt;li&gt;A&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="学习总结" scheme="https://shuhaohwang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="其他" scheme="https://shuhaohwang.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习总结-（6.7）深度优先搜索(邻接矩阵)</title>
    <link href="https://shuhaohwang.github.io/2019/08/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%886-7%EF%BC%89%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5/"/>
    <id>https://shuhaohwang.github.io/2019/08/21/数据结构学习总结-（6-7）深度优先搜索-邻接矩阵/</id>
    <published>2019-08-21T13:26:44.000Z</published>
    <updated>2019-08-22T07:42:47.118Z</updated>
    
    <content type="html"><![CDATA[<h4 id="邻接矩阵的DFS-深度优先搜索-代码实现及思路"><a href="#邻接矩阵的DFS-深度优先搜索-代码实现及思路" class="headerlink" title="邻接矩阵的DFS(深度优先搜索)代码实现及思路"></a>邻接矩阵的DFS(深度优先搜索)代码实现及思路</h4><ol><li><strong>实现邻接矩阵DFS算法的前提</strong></li></ol><ul><li><p>思路：要实现邻接矩阵的DFS算法，首先就要在邻接矩阵的结构中设置一个标记数组，用来对应顶点数组在遍历过程中的访问情况，即已经访问过的顶点将被标记已被访问，没有访问的将被标记未访问。</p></li><li><p>代码1：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MGraph</span>&#123;</span></span><br><span class="line"> ....</span><br><span class="line">     </span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;Mark;<span class="comment">//标记数组</span></span><br><span class="line">     </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建标记数组*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_mark</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//避免重复创建+验证</span></span><br><span class="line">    <span class="keyword">if</span>(Mark.size() != Vertex.size())<span class="keyword">return</span>;<span class="comment">//Vertex是顶点数组</span></span><br><span class="line">    </span><br><span class="line">    Mark.resize(Vertex.size(),<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol><li><strong>遍历实现DFS</strong></li></ol><ul><li><p>思路：根据标识数组来确定是否要访问，函数参数可以更加顶点数组来指定结点开始，并可以通过函数指针作为参数之一多样化的去遍历图</p></li><li><p>代码：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> ID,<span class="keyword">void</span>(*visit)(<span class="keyword">const</span> VT&amp; vertex))</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ID &lt; <span class="number">0</span> || ID &gt; Mark.size())<span class="keyword">return</span>;</span><br><span class="line">    Mark[ID] = <span class="literal">true</span>;</span><br><span class="line">    vistit(Vertex[ID]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; Vertex.size(); k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Edges[ID][k] != definfo)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!Mark[k])</span><br><span class="line">                DFS(k,visit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>代码解析</strong></p><img src="/2019/08/21/数据结构学习总结-（6-7）深度优先搜索-邻接矩阵/1.png"><div class="table-container"><table><thead><tr><th style="text-align:center">Mark/Vertex</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">false</td></tr></tbody></table></div><ul><li>邻接矩阵</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table></div><ul><li>第一步<code>DFS(unsigned int ID,void(*visit)(const VT&amp; vertex))</code><ul><li>Mark[0] = true；</li><li>输出了A</li><li>Edge[0] [0]不输出，输出B,C,D</li></ul></li></ul><hr><ol><li>堆栈实现</li></ol><ul><li><p>思路：通过堆栈来模拟递归实现</p></li><li><p>代码：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> ID,<span class="keyword">void</span>(*visit)(<span class="keyword">const</span> VT&amp; vertex))</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ID &lt; <span class="number">0</span> || ID &gt; Vertex.size())<span class="keyword">return</span>;</span><br><span class="line">    create_mark();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Vertex.size(); i++)&#123;</span><br><span class="line">        DFS_(i,visit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> ID,<span class="keyword">void</span>(*visit)(<span class="keyword">const</span> VT&amp; vertex))</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ID &lt; <span class="number">0</span> || ID &gt; Vertex.size())<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.push(ID);</span><br><span class="line">    Mark[ID] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">        <span class="keyword">auto</span> v = s.top();s.pop();</span><br><span class="line">        visit(Vertex[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; Vertex.size(); w++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Edge[ID][w] != definfo)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!Mark[w])&#123;</span><br><span class="line">                s.push(w);</span><br><span class="line">                Mark[w] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>—（本文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;邻接矩阵的DFS-深度优先搜索-代码实现及思路&quot;&gt;&lt;a href=&quot;#邻接矩阵的DFS-深度优先搜索-代码实现及思路&quot; class=&quot;headerlink&quot; title=&quot;邻接矩阵的DFS(深度优先搜索)代码实现及思路&quot;&gt;&lt;/a&gt;邻接矩阵的DFS(深度优先搜索)代
      
    
    </summary>
    
      <category term="代码学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据结构学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习总结" scheme="https://shuhaohwang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="数据结构" scheme="https://shuhaohwang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构-学习总结" scheme="https://shuhaohwang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习总结-（6.6）图的遍历</title>
    <link href="https://shuhaohwang.github.io/2019/08/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%886-6%EF%BC%89%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>https://shuhaohwang.github.io/2019/08/20/数据结构学习总结-（6-6）图的遍历/</id>
    <published>2019-08-20T03:53:51.000Z</published>
    <updated>2019-08-22T07:47:14.507Z</updated>
    
    <content type="html"><![CDATA[<h4 id="图的遍历（图的遍历是图的基本运算）"><a href="#图的遍历（图的遍历是图的基本运算）" class="headerlink" title="图的遍历（图的遍历是图的基本运算）"></a>图的遍历（图的遍历是图的基本运算）</h4><ul><li>定义：从已给的连通图中的某一个顶点出发，沿着一些边去访问遍历图中所有的顶点，且使每个顶点仅被访问一次</li><li>实质：找每个顶点的邻接点的过程</li></ul><hr><h4 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h4><ul><li>深度优先搜索(DFS)<ul><li>类似树的先序遍历</li></ul></li><li>广度优先搜索(BFS)<ul><li>类似树的层次遍历</li></ul></li></ul><p>—（本文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;图的遍历（图的遍历是图的基本运算）&quot;&gt;&lt;a href=&quot;#图的遍历（图的遍历是图的基本运算）&quot; class=&quot;headerlink&quot; title=&quot;图的遍历（图的遍历是图的基本运算）&quot;&gt;&lt;/a&gt;图的遍历（图的遍历是图的基本运算）&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;定义：从
      
    
    </summary>
    
      <category term="代码学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据结构学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习总结" scheme="https://shuhaohwang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="数据结构" scheme="https://shuhaohwang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构-学习总结" scheme="https://shuhaohwang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习总结-（6.5）图的实现-邻接表</title>
    <link href="https://shuhaohwang.github.io/2019/08/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%886-5%EF%BC%89%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0-%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
    <id>https://shuhaohwang.github.io/2019/08/18/数据结构学习总结-（6-5）图的实现-邻接表/</id>
    <published>2019-08-17T16:31:21.000Z</published>
    <updated>2019-08-19T13:02:41.535Z</updated>
    
    <content type="html"><![CDATA[<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>邻接表是一种顺序分配和链式分配相结合的存储结构，其顶点集由顺序表进行存储，其边则用邻接顶点来表示，而邻接点则用链式结构在顺序结构中的每一个顶点来承载，通俗点讲，就是把一堆链表用顺序表进行存储的结构。</p><img src="/2019/08/18/数据结构学习总结-（6-5）图的实现-邻接表/1.png"><hr><h5 id="邻接表的实现及思路"><a href="#邻接表的实现及思路" class="headerlink" title="邻接表的实现及思路"></a>邻接表的实现及思路</h5><p><strong>邻接表的结构</strong></p><ul><li><p>思路：邻接表结构是由一个顶点结点数组，和各个邻接点组成的，其中顶点数组中含有顶点数据和指向邻接点的链域，而邻接点由邻接点域(对应顶点数组的顶点下标)和顶点所连接的其他顶点的邻接点地址。所以实现邻接表结构，首先就要有顶点数组和邻接点结构。</p></li><li><p>代码：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VT,<span class="keyword">typename</span> Einfo&gt;<span class="class"><span class="keyword">class</span> <span class="title">AGraph</span>&#123;</span></span><br><span class="line">    <span class="comment">/*邻接点结构*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge_Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> ID;<span class="comment">//对应顶点数组下标</span></span><br><span class="line">        Einfo info;<span class="comment">//保存权重</span></span><br><span class="line">        Edge_Node* next;<span class="comment">//指向下一个邻接点的指针</span></span><br><span class="line">        </span><br><span class="line">        Edge_Node(<span class="keyword">unsigned</span> <span class="keyword">int</span> id,Einfo info):ID(id),info(info),next(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*顶点数组元素结构*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">VerTex_Node</span>&#123;</span></span><br><span class="line">       VT v_data;<span class="comment">//顶点数据</span></span><br><span class="line">       Edge_Node* Edge;</span><br><span class="line">       </span><br><span class="line">       VerTex_Node(VT v):v_data(v),Edge(<span class="literal">nullptr</span>); </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;VerTex_Node&gt;Vertexs;<span class="comment">//顶点数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> Num_Edge;</span><br><span class="line">    <span class="keyword">bool</span> undirected;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    AGraph(<span class="keyword">bool</span> undirected = <span class="literal">true</span>):undirected(undirected),Num_Edge(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>添加顶点</strong></p><ul><li><p>思路：直接进行把顶点加入顶点数组即可</p></li><li><p>代码：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add_VerTex</span><span class="params">(VT t)</span></span>&#123;</span><br><span class="line">    Vertexs.push_back(<span class="keyword">new</span> VerTex_Node(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>填加边</strong></p><p>思路：这里要注意的时，邻接表中的邻接点是以链表结合数组进行实现的，所以在添加边的时候，要对边结点的链域进行处理，这里可以采用链表中的前插法，邻接点一个个插入顶点数组的链域之间。</p><ul><li><p>代码：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Add_Edges</span><span class="params">(<span class="keyword">int</span> id1,<span class="keyword">int</span> id2,Einfo info)</span></span>&#123;</span><br><span class="line">    Edge_Node* p = <span class="keyword">new</span> Edge_Node(id2,info);</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    p-&gt;next = Vertexs[id1].Edge;</span><br><span class="line">    Vertexs[id1].Edge = p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(undirected)&#123;</span><br><span class="line">    Edge_Node* p = <span class="keyword">new</span> Edge_Node(id1,info);</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    p-&gt;next = Vertexs[id2].Edge;</span><br><span class="line">    Vertexs[id2].Edge = p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>修改边的权值</strong></p><ul><li><p>思路：这个操作的思路比较明确，更加要修改的边，通过循环遍历该起始点的顶点数组中的链域结构即可。</p></li><li><p>代码：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_Edge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> id1,<span class="keyword">const</span> <span class="keyword">int</span> id2,<span class="keyword">const</span> Einfo&amp; info)</span></span>&#123;</span><br><span class="line">    Edge_Node* p = Vertexs[id1].Edge;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ID == id2)</span><br><span class="line">            p-&gt;info = info;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(undirected)&#123;</span><br><span class="line">    Edge_Node* p = Vertexs[id2].Edge;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ID == id1)</span><br><span class="line">            p-&gt;info = info;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h4 id="具体代码实现："><a href="#具体代码实现：" class="headerlink" title="具体代码实现："></a>具体代码实现：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VT, <span class="keyword">typename</span> Einfo&gt;<span class="class"><span class="keyword">class</span> <span class="title">AGraph</span> &#123;</span></span><br><span class="line"><span class="comment">/*邻接表结构-边结点*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge_Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ID;<span class="comment">//对应顶点集的下标</span></span><br><span class="line"></span><br><span class="line">Einfo info;<span class="comment">//权重</span></span><br><span class="line">Edge_Node* next;</span><br><span class="line">Edge_Node(<span class="keyword">unsigned</span> <span class="keyword">int</span> id, Einfo info) :ID(id), info(info), next(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*顶点结点结构*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex_Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">VT v_data;</span><br><span class="line">Edge_Node* Edge = <span class="literal">nullptr</span>;</span><br><span class="line">Vertex_Node(VT v) :v_data(v) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Vertex_Node&gt; VerTexs;<span class="comment">//顶点集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Num_Edge;<span class="comment">//边数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> undirected;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">AGraph(<span class="keyword">bool</span> undirected = <span class="literal">true</span>) :undirected(undirected), Num_Edge(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">VT <span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123;</span><br><span class="line"><span class="keyword">return</span> VerTexs[i].v_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add_VerTex</span><span class="params">(VT t)</span> </span>&#123;</span><br><span class="line">VerTexs.push_back(Vertex_Node(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Add_Edges</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> id1, <span class="keyword">unsigned</span> <span class="keyword">int</span> id2, Einfo info)</span> </span>&#123;</span><br><span class="line">Edge_Node* p = <span class="keyword">new</span> Edge_Node(id2, info);</span><br><span class="line"><span class="keyword">if</span> (!p)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*前插*/</span></span><br><span class="line">p-&gt;next = VerTexs[id1].Edge;</span><br><span class="line">VerTexs[id1].Edge = p;</span><br><span class="line">Num_Edge++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (undirected) &#123;</span><br><span class="line">Edge_Node* p = <span class="keyword">new</span> Edge_Node(id1, info);</span><br><span class="line"><span class="keyword">if</span> (!p)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">p-&gt;next = VerTexs[id2].Edge;</span><br><span class="line">VerTexs[id2].Edge = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_Edge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> id1, <span class="keyword">const</span> <span class="keyword">int</span> id2, <span class="keyword">const</span> Einfo&amp; info)</span> </span>&#123;</span><br><span class="line">Edge_Node* p = VerTexs[id1].Edge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;ID == id2)</span><br><span class="line">p-&gt;info = info;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (undirected) &#123;</span><br><span class="line">Edge_Node* p = VerTexs[id2].Edge;</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;ID == id1)</span><br><span class="line">p-&gt;info = info;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_Agraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : VerTexs) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e.v_data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">Edge_Node* p = e.Edge;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p-&gt;ID &lt;&lt; <span class="string">","</span> &lt;&lt; p-&gt;info &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"顶点："</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : VerTexs) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i.v_data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"邻接表:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Print_Agraph();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_n_vertex</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> VerTexs.size(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_n_edges</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Num_Edge; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">AGraph&lt;<span class="keyword">char</span>, <span class="keyword">double</span>&gt; G(<span class="literal">false</span>);</span><br><span class="line">G.Add_VerTex(<span class="string">'A'</span>);</span><br><span class="line">G.Add_VerTex(<span class="string">'B'</span>);</span><br><span class="line">G.Add_VerTex(<span class="string">'C'</span>);</span><br><span class="line">G.Add_VerTex(<span class="string">'D'</span>);</span><br><span class="line"></span><br><span class="line">G.Add_Edges(<span class="number">0</span>, <span class="number">1</span>, <span class="number">12.3</span>);</span><br><span class="line">G.Add_Edges(<span class="number">0</span>, <span class="number">3</span>, <span class="number">9.5</span>);</span><br><span class="line">G.Add_Edges(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3.1</span>);</span><br><span class="line">G.Add_Edges(<span class="number">1</span>, <span class="number">2</span>, <span class="number">13</span>);</span><br><span class="line">G.Add_Edges(<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">G.print();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"顶点数量为: "</span> &lt;&lt; G.Get_n_vertex() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"边的数量为: "</span> &lt;&lt; G.Get_n_edges() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实验结果：<img src="/2019/08/18/数据结构学习总结-（6-5）图的实现-邻接表/2.png"></li></ul><p>—（本文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;邻接表&quot;&gt;&lt;a href=&quot;#邻接表&quot; class=&quot;headerlink&quot; title=&quot;邻接表&quot;&gt;&lt;/a&gt;邻接表&lt;/h4&gt;&lt;p&gt;邻接表是一种顺序分配和链式分配相结合的存储结构，其顶点集由顺序表进行存储，其边则用邻接顶点来表示，而邻接点则用链式结构在顺序结构中的
      
    
    </summary>
    
      <category term="代码学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据结构学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习总结" scheme="https://shuhaohwang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="数据结构" scheme="https://shuhaohwang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构-学习总结" scheme="https://shuhaohwang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>C++进阶学习总结-(2.8)临时对象处理和程序优化探讨</title>
    <link href="https://shuhaohwang.github.io/2019/08/17/C-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2-8-%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86%E5%92%8C%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E6%8E%A2%E8%AE%A8/"/>
    <id>https://shuhaohwang.github.io/2019/08/17/C-进阶学习总结-2-8-临时对象处理和程序优化探讨/</id>
    <published>2019-08-17T13:00:49.000Z</published>
    <updated>2019-09-20T07:58:46.073Z</updated>
    
    <content type="html"><![CDATA[<h4 id="临时对象探讨"><a href="#临时对象探讨" class="headerlink" title="临时对象探讨"></a>临时对象探讨</h4><p>临时对象的产生在很多情况下都会出现，有临时对象的产生，说明就多调用一次构造函数，多调用一次析构函数，在程序内部消耗资源是比较大的，为对程序进行性能提升优化，首先就是要解决临时对象的问题。</p><h5 id="产生临时对象的情况及解决办法："><a href="#产生临时对象的情况及解决办法：" class="headerlink" title="产生临时对象的情况及解决办法："></a>产生临时对象的情况及解决办法：</h5><h5 id="情况1："><a href="#情况1：" class="headerlink" title="情况1："></a>情况1：</h5><p>当对象被当做参数传入函数的时候</p><ul><li><p><strong>具体代码</strong>：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> num1;</span><br><span class="line">    <span class="keyword">int</span> num2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    A(<span class="keyword">int</span> i = <span class="number">0</span>,<span class="keyword">int</span> j = <span class="number">0</span>):num1(i),num2(j)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了类A的构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"num1= "</span> &lt;&lt; num1 &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">             &lt;&lt; <span class="string">"num2= "</span> &lt;&lt; num2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*类A的拷贝构造函数*/</span></span><br><span class="line">    A(<span class="keyword">const</span> A&amp; A)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了类A的拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    num1 = A.num1;</span><br><span class="line">        num2 = A.num2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~A()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了类A的析构函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*相加函数，但这是以对象为参数的类函数*/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(A t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        temp = t.num1 + t.num2;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实验结果</strong>：<img src="/2019/08/17/C-进阶学习总结-2-8-临时对象处理和程序优化探讨/1.png"></p></li><li><p><strong>结果分析</strong>：</p><ul><li><p>根据实验打印情况，发现了A首先调用了构造函数，然后又调用了A的拷贝构造函数。可以发现这里出现了拷贝操作，也就意味着有临时对象的产生，并进行了对象拷贝。原因就出在<code>int add(A t)</code>函数上。<u>先更加拷贝构造函数构造一个临时对象，再进行拷贝操作，并把这个临时对象进行析构。</u></p></li><li><p>因为在<code>int add(A t)</code>中，对象以参数的形式传入函数中，所以先对<code>t</code>这个临时对象先进行拷贝操作，也就是<code>t = a</code>(a为传入的对象),其次再进行相加操作并返回和。</p></li><li><p>如果对add函数进行修改</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(A t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        temp = t.num1 + t.num2;</span><br><span class="line">    t.num1 = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.add();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.num1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><img src="/2019/08/17/C-进阶学习总结-2-8-临时对象处理和程序优化探讨/2.png"></li></ul></li><li><p>也可以发现，在add函数中的修改，是没有影响外界的，即函数中的对象<code>t</code>是一个临时对象。</p></li></ul></li><li><p><strong>解决方案：</strong></p><ul><li><p>在add函数中的<u>使用引用</u>进行传参</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(A&amp;t)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">        temp = t.num1 + t.num2;</span><br><span class="line">    t.num1 = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">return</span> temp; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.add();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.num1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实验结果：<img src="/2019/08/17/C-进阶学习总结-2-8-临时对象处理和程序优化探讨/3.png" title="发现没有调用拷贝构造函数，即没有临时对象产生了"></p></li></ul></li></ul></li></ul><hr><h6 id="情况2："><a href="#情况2：" class="headerlink" title="情况2："></a>情况2：</h6><p>隐式类型转换调用构造函数的时候，会产生临时对象</p><ul><li><p><strong>具体代码：</strong></p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> num1;</span><br><span class="line">    <span class="keyword">int</span> num2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    A(<span class="keyword">int</span> i = <span class="number">0</span>,<span class="keyword">int</span> j = <span class="number">0</span>):num1(i),num2(j)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了类A的构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"num1= "</span> &lt;&lt; num1 &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">             &lt;&lt; <span class="string">"num2= "</span> &lt;&lt; num2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*类A的拷贝构造函数*/</span></span><br><span class="line">    A(<span class="keyword">const</span> A&amp; A)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了类A的拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    num1 = A.num1;</span><br><span class="line">        num2 = A.num2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~A()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了类A的析构函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实验结果</strong>：<img src="/2019/08/17/C-进阶学习总结-2-8-临时对象处理和程序优化探讨/4.png"></p></li><li><p><strong>结果分析：</strong></p><ul><li><p>可以发现，系统先调用普通构造函数生成了对象a，在进行 <code>a = 100</code>操作的时候，会再次调用一次构造函数，实质上，这里是先把100先隐式转换成类A的临时对象，在把这个对象赋值给原来的对象a，最后销毁这个临时对象。(注意！：这里是赋值给原来的a对象，而不是进行拷贝操作)</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*如果使用拷贝赋值运算符*/</span></span><br><span class="line">A&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> A&amp;t)&#123;</span><br><span class="line">    num1 = t.num1;</span><br><span class="line">    num2 = t.num2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"使用了拷贝赋值运算符"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><img src="/2019/08/17/C-进阶学习总结-2-8-临时对象处理和程序优化探讨/5.png"></li></ul></li><li><p><strong>解决方案：</strong></p><ul><li><p>让对象定义和初始化同句进行</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><img src="/2019/08/17/C-进阶学习总结-2-8-临时对象处理和程序优化探讨/6.png"></li></ul></li></ul></li></ul><hr><h6 id="情况3："><a href="#情况3：" class="headerlink" title="情况3："></a>情况3：</h6><p>当函数返回值为对象时</p><ul><li><p><strong>具体代码：</strong></p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">add2</span><span class="params">(A&amp; t)</span> </span>&#123;</span><br><span class="line">A a;</span><br><span class="line">a.num1 = t.num1 + t.num2;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">add2(a);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><strong>实验结果</strong>：<img src="/2019/08/17/C-进阶学习总结-2-8-临时对象处理和程序优化探讨/7.png"></p></li><li><p><strong>结果分析：</strong>从图中可以发现，在执行返回值为对象的函数的时候，会调用一次拷贝构造函数，说明这里发生了拷贝，其中第一个构造函数的函数体外的对象的，第二个构造函数是函数体内的临时对象，除此之外还调用了一次拷贝构造函数，说明这里生成了临时对象，并把临时对象返回出去，（其中三个析构函数分别是临时对象的析构，函数体内对象的析构，函数体外对象的析构）</p></li><li><p>如果函数体外没有函数返回值的接收值，那么该返回值产生的临时对象会在函数体结束的时候立即被析构</p><ul><li><img src="/2019/08/17/C-进阶学习总结-2-8-临时对象处理和程序优化探讨/8.png"></li></ul></li><li><p>如果有接收对象，那么会在程序结束时进行析构</p><ul><li><img src="/2019/08/17/C-进阶学习总结-2-8-临时对象处理和程序优化探讨/9.png"></li></ul></li><li><p><strong>解决方案：</strong></p><ul><li><p>对存在返回值为对象的函数进行优化</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*优化前*/</span></span><br><span class="line"><span class="function">A <span class="title">add2</span><span class="params">(A&amp; t)</span> </span>&#123;</span><br><span class="line">A a;</span><br><span class="line">a.num1 = t.num1 + t.num2;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*优化后*/</span></span><br><span class="line"><span class="function">A <span class="title">add2</span><span class="params">(A&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> A(t.num1+t.num2 , <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><img src="/2019/08/17/C-进阶学习总结-2-8-临时对象处理和程序优化探讨/10.png"></li><li><p>结果会只调用两次构造函数，不会调用拷贝构造函数</p></li></ul></li></ul><hr><h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num1;</span><br><span class="line">    <span class="keyword">int</span> num2;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> num1 = <span class="number">0</span>,<span class="keyword">int</span> num2 = <span class="number">0</span>):num1(num1),num2(num2)&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*传参用引用，避免产生临时对象(情况1)*/</span></span><br><span class="line">A <span class="keyword">operator</span>+(A&amp; t1,A&amp; t2)&#123;</span><br><span class="line">    <span class="comment">/*返回值为对象时，可以直接在返回值里调用其构造函数进行优化(情况3)*/</span></span><br><span class="line">    <span class="keyword">return</span> A(t1.num1 + t2.num1 , t1.num2 + t2.num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">100</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">200</span>,<span class="number">200</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*直接在定义时初始化，防止临时对象产生，提高效率(情况2)*/</span></span><br><span class="line">    A a3 = a1 + a2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>—（本文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;临时对象探讨&quot;&gt;&lt;a href=&quot;#临时对象探讨&quot; class=&quot;headerlink&quot; title=&quot;临时对象探讨&quot;&gt;&lt;/a&gt;临时对象探讨&lt;/h4&gt;&lt;p&gt;临时对象的产生在很多情况下都会出现，有临时对象的产生，说明就多调用一次构造函数，多调用一次析构函数，在程序内
      
    
    </summary>
    
      <category term="代码学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="C++学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/C-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C++" scheme="https://shuhaohwang.github.io/tags/C/"/>
    
      <category term="学习总结" scheme="https://shuhaohwang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="C++学习总结" scheme="https://shuhaohwang.github.io/tags/C-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="性能优化" scheme="https://shuhaohwang.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习总结-（6.4）图的实现-邻接矩阵</title>
    <link href="https://shuhaohwang.github.io/2019/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%886-4%EF%BC%89%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5/"/>
    <id>https://shuhaohwang.github.io/2019/08/16/数据结构学习总结-（6-4）图的实现-邻接矩阵/</id>
    <published>2019-08-16T03:57:14.000Z</published>
    <updated>2019-08-16T12:29:48.730Z</updated>
    
    <content type="html"><![CDATA[<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>用一个二维数组存放顶点间关系（边或弧）的数据，这个二维数组称为邻接矩阵。邻接矩阵又分为有向图邻接矩阵和无向图邻接矩阵。<br><img src="/2019/08/16/数据结构学习总结-（6-4）图的实现-邻接矩阵/1.png"><br>该存储结构，是借助线性代数的邻接矩阵来表示图的结构。</p><hr><h4 id="具体实现和思路"><a href="#具体实现和思路" class="headerlink" title="具体实现和思路"></a>具体实现和思路</h4><ul><li><p><strong>邻接矩阵实现：</strong></p><ul><li><p>思路：邻接矩阵的实现是要借助二维数组来实现，在C++中可以使用vector来代替二维数组，从而实现矩阵。</p></li><li><p>代码：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VT,<span class="keyword">typename</span> Einfo&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MGraph</span>&#123;</span></span><br><span class="line"><span class="built_in">vector</span>&lt;VT&gt;VerTex;<span class="comment">//顶点集</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Einfo&gt;&gt;Edge<span class="comment">//邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> undirected;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">MGraph(<span class="keyword">bool</span> undirected = <span class="literal">true</span>):undirecter(undirected)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>添加顶点/获得顶点总数：</strong></p><ul><li><p>思路：跟边集构建一样，使用vector进行存储顶点数据</p></li><li><p>代码：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add_VerTex</span><span class="params">(VT vertex)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    VerTex.push_back(vertex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_n_Vertex</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> VerTex.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>构建邻边矩阵：</strong></p><ul><li><p>思路：因为邻边矩阵是一个NXN的方形矩阵(N为顶点数量)，所以在构建邻边矩阵的时候，要先根据顶点总数来创建代表邻边矩阵的二维数组。</p></li><li><p>代码：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create_MGraph</span><span class="params">(Einfo&amp; definfo = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*用来防止多次创建邻接矩阵*/</span></span><br><span class="line">    <span class="keyword">if</span>(VerTex.size() != Edge.size())&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> N_Vertex = Get_n_Vertex();</span><br><span class="line">        Edge.resize(N_Vertex,<span class="built_in">vector</span>&lt;Einfo&gt;(N_Vertex,definfo));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>添加边</strong></p><ul><li><p>思路：因为邻接矩阵是一个二维数组，所以添加边的时候直接把顶点下标当做邻接矩阵的坐标位置进行编写即可。</p></li><li><p>代码：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add_Edge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">int</span> j, <span class="keyword">const</span> Einfo&amp;info = <span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*要先创建邻接矩阵才能实现添加边操作*/</span></span><br><span class="line">    <span class="keyword">if</span>(VerTex.size() != Edge.size())</span><br><span class="line">      Create_MGraph();</span><br><span class="line">    </span><br><span class="line">    Edge[i][j] = info;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(undirected)&#123;</span><br><span class="line">        Edge[j][i] = info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><hr><h4 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h4><img src="/2019/08/16/数据结构学习总结-（6-4）图的实现-邻接矩阵/2.png"><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VT, <span class="keyword">typename</span> Einfo&gt;<span class="class"><span class="keyword">class</span> <span class="title">MGraph</span> &#123;</span></span><br><span class="line"><span class="built_in">vector</span>&lt;VT&gt;Vertex;<span class="comment">//顶点集</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Einfo&gt;&gt;Edges; <span class="comment">//邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Num_Edge;<span class="comment">//边数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> undirected;<span class="comment">//标记是否为无向图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*构造函数*/</span></span><br><span class="line">MGraph(<span class="keyword">bool</span> undirected = <span class="literal">true</span>):undirected(undirected),Num_Edge(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获得顶点总数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_n_vertex</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Vertex.size(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_n_edges</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Num_Edge; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_Mgraph</span><span class="params">(<span class="keyword">const</span> Einfo&amp; definfo = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Edges.size() != Vertex.size()) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n_vertex = Get_n_vertex();</span><br><span class="line"></span><br><span class="line">Edges.resize(n_vertex, <span class="built_in">vector</span>&lt;Einfo&gt;(n_vertex, definfo));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add_VerTex</span><span class="params">(VT vertex)</span> </span>&#123; Vertex.push_back(vertex); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add_Edges</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, Einfo info)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Edges.size() != Vertex.size())</span><br><span class="line">create_Mgraph();</span><br><span class="line"></span><br><span class="line">Edges[i][j] = info;</span><br><span class="line">Num_Edge++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (undirected) &#123;</span><br><span class="line">Edges[j][i] = info;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_Mgraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : Edges) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; w : e) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; w &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"顶点："</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : Vertex) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"邻接矩阵:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Print_Mgraph();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MGraph&lt;<span class="keyword">char</span>, <span class="keyword">double</span>&gt; G(<span class="literal">false</span>);</span><br><span class="line">G.Add_VerTex(<span class="string">'A'</span>);</span><br><span class="line">G.Add_VerTex(<span class="string">'B'</span>);</span><br><span class="line">G.Add_VerTex(<span class="string">'C'</span>);</span><br><span class="line">G.Add_VerTex(<span class="string">'D'</span>);</span><br><span class="line"></span><br><span class="line">G.Add_Edges(<span class="number">0</span>, <span class="number">1</span>, <span class="number">12.3</span>);</span><br><span class="line">G.Add_Edges(<span class="number">0</span>, <span class="number">3</span>, <span class="number">9.5</span>);</span><br><span class="line">G.Add_Edges(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3.1</span>);</span><br><span class="line">G.Add_Edges(<span class="number">1</span>, <span class="number">2</span>, <span class="number">13</span>);</span><br><span class="line">G.Add_Edges(<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">G.print();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"顶点数量为: "</span> &lt;&lt; G.Get_n_vertex() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"边的数量为: "</span> &lt;&lt; G.Get_n_edges() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实验结果：<img src="/2019/08/16/数据结构学习总结-（6-4）图的实现-邻接矩阵/1.png"></p></li></ul><p>—（本文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;邻接矩阵&quot;&gt;&lt;a href=&quot;#邻接矩阵&quot; class=&quot;headerlink&quot; title=&quot;邻接矩阵&quot;&gt;&lt;/a&gt;邻接矩阵&lt;/h4&gt;&lt;p&gt;用一个二维数组存放顶点间关系（边或弧）的数据，这个二维数组称为邻接矩阵。邻接矩阵又分为有向图邻接矩阵和无向图邻接矩阵。&lt;br
      
    
    </summary>
    
      <category term="代码学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据结构学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习总结" scheme="https://shuhaohwang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="数据结构" scheme="https://shuhaohwang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构-学习总结" scheme="https://shuhaohwang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习总结-（6.3）图的实现边表</title>
    <link href="https://shuhaohwang.github.io/2019/08/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%886-3%EF%BC%89%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BE%B9%E8%A1%A8/"/>
    <id>https://shuhaohwang.github.io/2019/08/15/数据结构学习总结-（6-3）图的实现边表/</id>
    <published>2019-08-15T13:26:14.000Z</published>
    <updated>2019-08-15T15:38:47.519Z</updated>
    
    <content type="html"><![CDATA[<h4 id="边表"><a href="#边表" class="headerlink" title="边表"></a>边表</h4><ul><li>边表是把图的顶点，和边分别用顺序表进行存储的结构</li><li>这种存储结构是最简单、最容易实现的图存储结构</li><li>缺点：如果边的数目过大，会使效率降低</li></ul><hr><h4 id="代码实现及思路"><a href="#代码实现及思路" class="headerlink" title="代码实现及思路"></a>代码实现及思路</h4><ul><li><p>边表结构</p><ul><li><p>思路：因为边表是通过两个顺序表分别存储顶点集和边集的存储结构，所以在实现时可以通过创建顶点集和边集的结构，其中边集要有两个顶点在顶点集中的下标数值，和该边对应的权值。其中顺序表可以通过C++内置的vector结构实现。</p></li><li><p>代码实现：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VT,<span class="keyword">typename</span> Einfo&gt; <span class="class"><span class="keyword">class</span> <span class="title">ElistGraph</span>&#123;</span></span><br><span class="line">    <span class="comment">/*实现边集结构*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">        <span class="comment">/*边两头的顶点在顶点集的下标*/</span></span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        Einfo info;<span class="comment">//用来存储权的数据</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*边集构造函数*/</span></span><br><span class="line">        Edge(<span class="keyword">int</span> i,<span class="keyword">int</span> j,Einfo info):x(i),y(j),info(info)&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;VT&gt;VerTex;<span class="comment">//顶点集</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt;Edges;<span class="comment">//边集</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> undirected;<span class="comment">//用来标记是否为无向图</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*边表构造函数(默认为无向表)*/</span></span><br><span class="line">     ElistGraph(<span class="keyword">bool</span> undirected = <span class="literal">true</span>):undirected(undirecter)&#123;&#125;; </span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>添加顶点</p><ul><li><p>思路：直接通过对vector结构进行操作添加即可</p></li><li><p>代码实现：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_VerTex</span><span class="params">(VT vertex)</span></span>&#123;VerTex.push_back(vertex);&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>添加边</p><ul><li><p>思路：跟添加顶点操作一致</p></li><li><p>代码实现：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_Edge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> j, <span class="keyword">const</span> Einfo&amp; info)</span></span>&#123;Edges.push_back(Edge(i,j,info));&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><hr><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><img src="/2019/08/15/数据结构学习总结-（6-3）图的实现边表/1.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* VT 顶点数据</span></span><br><span class="line"><span class="comment">* Einfo 边数据类型(权)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VT,<span class="keyword">typename</span> Einfo&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElistGraph</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">Einfo info;</span><br><span class="line">Edge(<span class="keyword">int</span> i, <span class="keyword">int</span> j, Einfo inf) :x(i), y(j), info(inf) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;VT&gt; VerTex;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; Edges;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> undirected;<span class="comment">//判断是否为无向图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*默认为有向图*/</span></span><br><span class="line">ElistGraph(<span class="keyword">bool</span> undirected = <span class="literal">true</span>):undirected(undirected)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*添加顶点*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add_VerTex</span><span class="params">(VT vertex)</span> </span>&#123; VerTex.push_back(vertex); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*添加边*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add_Edges</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> j, <span class="keyword">const</span> Einfo&amp; info)</span> </span>&#123; Edges.push_back(Edge(i, j ,info)); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*重载运算符*/</span></span><br><span class="line"></span><br><span class="line">VT <span class="keyword">operator</span>[](<span class="keyword">int</span> i)&#123;<span class="keyword">return</span> VerTex[i];&#125;</span><br><span class="line">VT&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> VerTex[i]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获得顶点数量*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_n_VT</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> VerTex.size(); &#125;</span><br><span class="line"><span class="comment">/*获得边的数量*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_n_e</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> Edges.size(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*打印信息*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"顶点："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : VerTex) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"边："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : Edges) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e.x &lt;&lt; <span class="string">" "</span> &lt;&lt; e.y &lt;&lt; <span class="string">" "</span> &lt;&lt; e.info &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ElistGraph&lt;<span class="keyword">char</span>, <span class="keyword">double</span>&gt; G(<span class="literal">false</span>);</span><br><span class="line">G.Add_VerTex(<span class="string">'A'</span>);</span><br><span class="line">G.Add_VerTex(<span class="string">'B'</span>);</span><br><span class="line">G.Add_VerTex(<span class="string">'C'</span>);</span><br><span class="line">G.Add_VerTex(<span class="string">'D'</span>);</span><br><span class="line"></span><br><span class="line">G.Add_Edges(<span class="number">0</span>, <span class="number">1</span>, <span class="number">12.3</span>);</span><br><span class="line">G.Add_Edges(<span class="number">0</span>, <span class="number">3</span>, <span class="number">9.5</span>);</span><br><span class="line">G.Add_Edges(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3.1</span>);</span><br><span class="line">G.Add_Edges(<span class="number">1</span>, <span class="number">2</span>, <span class="number">13</span>);</span><br><span class="line">G.Add_Edges(<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">G.print();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"顶点数量为: "</span> &lt;&lt; G.get_n_VT() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"边的数量为: "</span> &lt;&lt; G.get_n_e() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>实验结果：<img src="/2019/08/15/数据结构学习总结-（6-3）图的实现边表/2.png"></p><p>—（本文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;边表&quot;&gt;&lt;a href=&quot;#边表&quot; class=&quot;headerlink&quot; title=&quot;边表&quot;&gt;&lt;/a&gt;边表&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;边表是把图的顶点，和边分别用顺序表进行存储的结构&lt;/li&gt;
&lt;li&gt;这种存储结构是最简单、最容易实现的图存储结构&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="代码学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据结构学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习总结" scheme="https://shuhaohwang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="数据结构" scheme="https://shuhaohwang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构-学习总结" scheme="https://shuhaohwang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习总结-（6.2）图的抽象数据类型</title>
    <link href="https://shuhaohwang.github.io/2019/08/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%886-2%EF%BC%89%E5%9B%BE%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://shuhaohwang.github.io/2019/08/15/数据结构学习总结-（6-2）图的抽象数据类型/</id>
    <published>2019-08-15T13:05:08.000Z</published>
    <updated>2019-08-15T13:25:09.553Z</updated>
    
    <content type="html"><![CDATA[<h4 id="图的抽象数据类型"><a href="#图的抽象数据类型" class="headerlink" title="图的抽象数据类型"></a>图的抽象数据类型</h4><ul><li>ADT Graph</li><li>Data     V是具有相同特性的数据元素的集合名称为顶点集</li><li>Relation<ul><li>R = {VR}</li><li>VR = {<v,w>|V,W∈V且P(V,W) <v,w>表示从V，W的弧，P(v,w)定义了弧的<v,w>的意义}</v,w></v,w></v,w></li></ul></li><li>Operation<ul><li>createGraph(&amp;G,V,VR)<ul><li>初始条件：V是图的顶点集，VR是图中边/弧的集合</li><li>操作结果：按V和VR的定义构造图G</li></ul></li><li>DFSTraverse(G)<ul><li>初始条件：图G存在</li><li>操作结果：对图进行<strong>深度优先遍历</strong>，在遍历过程中对每个顶点访问一次</li></ul></li><li>BFSTraverse(G)<ul><li>初始条件：图G存在</li><li>操作结果：对图进行<strong>广度优先遍历</strong>，在遍历过程中对每个顶点访问一次</li></ul></li></ul></li></ul><hr><h4 id="图的数据存储结构"><a href="#图的数据存储结构" class="headerlink" title="图的数据存储结构"></a>图的数据存储结构</h4><ul><li>边表</li><li>数组表示法(邻接矩阵)</li><li>邻接表</li><li>十字链表(有向图)</li><li>多重邻接表(无向图)</li></ul><p>— (本文完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;图的抽象数据类型&quot;&gt;&lt;a href=&quot;#图的抽象数据类型&quot; class=&quot;headerlink&quot; title=&quot;图的抽象数据类型&quot;&gt;&lt;/a&gt;图的抽象数据类型&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;ADT Graph&lt;/li&gt;
&lt;li&gt;Data     V是具有相同特性的数据元
      
    
    </summary>
    
      <category term="代码学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据结构学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习总结" scheme="https://shuhaohwang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="数据结构" scheme="https://shuhaohwang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构-学习总结" scheme="https://shuhaohwang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>C++进阶学习总结-（2.7）左值和右值、左右值引用、std::move()函数</title>
    <link href="https://shuhaohwang.github.io/2019/08/15/C-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-7%EF%BC%89%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E3%80%81%E5%B7%A6%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81std-move-%E5%87%BD%E6%95%B0/"/>
    <id>https://shuhaohwang.github.io/2019/08/15/C-进阶学习总结-（2-7）左值和右值、左右值引用、std-move-函数/</id>
    <published>2019-08-14T18:10:46.000Z</published>
    <updated>2019-09-20T07:58:07.959Z</updated>
    
    <content type="html"><![CDATA[<h4 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h4><ul><li>左值：可以在等号左边的值，通常叫左值<ul><li>特点：拥有地址，可以被修改和赋值</li></ul></li><li>右值：不能在等号左边的值，通常为右值<ul><li>特点：临时数据，没有地址，不能够修改和赋值</li></ul></li></ul><p>通俗点讲：左值就是地址值，而右值则是一个单纯的数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">b = <span class="number">1</span>;<span class="comment">//此时b是一个地址值，是一个左值，也就是此时这个b代表内存地址，而1只是单纯的数据，为右值</span></span><br><span class="line">a = b;<span class="comment">//此时的a是一个左值，而此时的b计算机认为它是一个数据，而不是b这个变量的地址值，故此时b为右值</span></span><br></pre></td></tr></table></figure><hr><h4 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h4><ul><li><p>左值引用：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">a_t</span> = a; </span><br><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">a_t</span> = <span class="number">1</span>;<span class="comment">//报错：左值引用不能绑定给右值</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>右值引用：</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>；</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; <span class="keyword">a_t</span> = <span class="number">1</span><span class="comment">//右值引用可以绑定给右值</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>实质上：右值引用又是一个左值 </p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; <span class="keyword">b_t</span> = b;<span class="comment">//允许</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h5 id="前置运算符和后置运算符"><a href="#前置运算符和后置运算符" class="headerlink" title="前置运算符和后置运算符"></a>前置运算符和后置运算符</h5><ul><li>前置运算符(++i)是左值表达式<ul><li>++i 实质上，<strong>先直接</strong>给变量 i+1，然后返回 i 本身。</li><li><code>(++i) = 100;</code>//允许，因为++i 是左值表达式，结果 i 的值为100</li><li>—i 同理</li></ul></li><li>后置运算符(i++)是右值表达式<ul><li>i++ 实质上，先把 i 赋值给一个临时变量 t ，然后再让i + 1，<strong>最后返回临时变量 t</strong></li><li><code>(i++) = 100</code>//报错</li><li>i— 同理</li></ul></li></ul><hr><h4 id="右值引用的作用"><a href="#右值引用的作用" class="headerlink" title="右值引用的作用"></a>右值引用的作用</h4><p>假设，有两个变量a和b，其中a要拷贝给b，那么正常情况下，b也要先创建内存空间，然后再把a的内容赋值给b。但在C++11后新引入了 &amp;&amp; 运算符，即：右值引用，在实现上述赋值操作时，由于b没有创建空间，而a却有自己的内存空间，那么可以用右值引用直接获得a空间的地址和数据，直接给b，而不是要b再创建空间去接收a的内容。</p><ul><li>提高程序运行效率，把拷贝对象变成移动对象来提高程序运行效率</li></ul><hr><h4 id="std-move函数"><a href="#std-move函数" class="headerlink" title="std::move函数"></a>std::move函数</h4><ul><li><p>作用：把左值引用强转成右值，使右值引用可以绑定左值</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; r_a = <span class="built_in">std</span>::move(a);</span><br></pre></td></tr></table></figure></li></ul></li><li><img src="/2019/08/15/C-进阶学习总结-（2-7）左值和右值、左右值引用、std-move-函数/1.png"></li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = <span class="string">"ShuHao"</span>;</span><br><span class="line"><span class="built_in">string</span> str2 = <span class="built_in">std</span>::move(str1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"str1的值为: "</span>&lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str2的值为: "</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>实验结果：<img src="/2019/08/15/C-进阶学习总结-（2-7）左值和右值、左右值引用、std-move-函数/2.png"></p><p>可以发现，str1经过move的处理变成了空字符串，其实在实质上，是因为string这个类中通过赋值运算符调用了，移动拷贝函数，即：str2先创建了自己的内存空间，然后把str1的内容先给str2，再把str1，的内容清空。</p><img src="/2019/08/15/C-进阶学习总结-（2-7）左值和右值、左右值引用、std-move-函数/3.png"><img src="/2019/08/15/C-进阶学习总结-（2-7）左值和右值、左右值引用、std-move-函数/4.png"><p>从两个的图可以发现，str1和srt2的内存地址是不同的，说明执行这个赋值过程中，str2是开辟了新的内存空间，在进行拷贝。</p><p>但如果使用右值引用：<img src="/2019/08/15/C-进阶学习总结-（2-7）左值和右值、左右值引用、std-move-函数/5.png"></p><img src="/2019/08/15/C-进阶学习总结-（2-7）左值和右值、左右值引用、std-move-函数/6.png"><img src="/2019/08/15/C-进阶学习总结-（2-7）左值和右值、左右值引用、std-move-函数/7.png"><p>可以发现：str1和str2是同一块内存地址，说明str2在执行赋值的时候没有创建新的空间，而是直接引用str1原有的空间，从而免除了str2创建新空间的步骤，提高了程序运行效率</p><p>—（本文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;左值和右值&quot;&gt;&lt;a href=&quot;#左值和右值&quot; class=&quot;headerlink&quot; title=&quot;左值和右值&quot;&gt;&lt;/a&gt;左值和右值&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;左值：可以在等号左边的值，通常叫左值&lt;ul&gt;
&lt;li&gt;特点：拥有地址，可以被修改和赋值&lt;/li&gt;
&lt;/u
      
    
    </summary>
    
      <category term="代码学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="C++学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/C-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C++" scheme="https://shuhaohwang.github.io/tags/C/"/>
    
      <category term="学习总结" scheme="https://shuhaohwang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="C++学习总结" scheme="https://shuhaohwang.github.io/tags/C-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习总结-（6-1）图的定义及概念</title>
    <link href="https://shuhaohwang.github.io/2019/08/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%886-1%EF%BC%89%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%A6%82%E5%BF%B5/"/>
    <id>https://shuhaohwang.github.io/2019/08/15/数据结构学习总结-（6-1）图的定义及概念/</id>
    <published>2019-08-14T16:44:55.000Z</published>
    <updated>2019-08-14T18:07:05.380Z</updated>
    
    <content type="html"><![CDATA[<h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><ul><li>定义：图G(graph)是一些点和线的集合<ul><li><img src="/2019/08/15/数据结构学习总结-（6-1）图的定义及概念/1.png"></li><li>图中的点叫作<strong>顶点</strong>(VerTex)</li><li>两个顶点的连线叫作<strong>边</strong>(Edges)</li><li>Graph = (V,E)<ul><li>V：顶点(数据元素)的<strong>有穷非空</strong>集合</li><li>E：边的有穷集合</li></ul></li></ul></li></ul><hr><h4 id="图的分类"><a href="#图的分类" class="headerlink" title="图的分类"></a>图的分类</h4><ul><li><p>无向图</p><ul><li><img src="/2019/08/15/数据结构学习总结-（6-1）图的定义及概念/2.png"></li><li>每一条边都是没有方向的</li><li>顶点集合{A,B,C,D}</li><li>边集合{(A,B),(A,D),(C,D),(C,B),(A,C)}</li></ul></li><li><p>有向图</p><ul><li><img src="/2019/08/15/数据结构学习总结-（6-1）图的定义及概念/3.png" title="其中B为弧头(Head),D为弧尾(Tail)"></li><li>每一条边有方向的，也称弧(arc)</li><li>顶点集合{A,B,C,D}</li><li>边集合{(B,A),(A,D),(B,C),(C,A)}</li></ul></li><li>完全图<ul><li><img src="/2019/08/15/数据结构学习总结-（6-1）图的定义及概念/4.png"></li><li>任意两个顶点都有一条边相连的图叫作<strong>完全图</strong></li><li>无向完全图：如果有<strong>N个结点</strong>那么它有<strong>N(N-1)/2条边</strong></li><li>有向完全图：如果有<strong>N个结点</strong>那么它有<strong>N(N-1)条边</strong></li></ul></li><li>网<ul><li><img src="/2019/08/15/数据结构学习总结-（6-1）图的定义及概念/5.png"></li><li>网是边或弧<strong>带权</strong>的图</li><li>无向网</li><li>有向网</li></ul></li></ul><hr><h5 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h5><img src="/2019/08/15/数据结构学习总结-（6-1）图的定义及概念/6.png" title="1和2是3的子图"><ul><li>1和2是3的子图</li></ul><hr><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><img src="/2019/08/15/数据结构学习总结-（6-1）图的定义及概念/2.png"><ol><li>如果边(V,U)∈E，则称顶点V和U互为邻接点(Adjacent)<ul><li>例：A/B、B/C、C/D…互为邻接点</li></ul></li><li>边(V,U)依附于(incident)顶点V和U(或边与顶点相关联)<ul><li>例：边(A,B)依附于顶点A、B上</li></ul></li><li>顶点V的度(Degree)是和V相关联的边的数量，记为TD(V)，对于有向图：有出度和入度<ul><li>例：A的度为3、D的度为2</li><li><strong>握手定理</strong>：边数(E) = 各顶点度数和/2</li></ul></li></ol><h5 id="相关术语解释"><a href="#相关术语解释" class="headerlink" title="相关术语解释"></a>相关术语解释</h5><ul><li><p>路径</p><ul><li>若从一个顶点V<sub>i</sub>出发，沿一些边经过一些顶点，再到达顶点V<sub>k</sub>,则称沿途的经过顶点的序列为从V<sub>i</sub>到V<sub>k</sub>的路径</li></ul></li><li><p>路径的长度</p><ul><li>路径上的边或弧的数目</li></ul></li><li>回路(环)<ul><li>起点与终点相同的路径</li></ul></li><li>简单路径<ul><li><strong>没有重复</strong>顶点的路径，即不含回路</li></ul></li><li>简单回路<ul><li>除起点和终点相同外，<strong>没有</strong>其余<strong>重复</strong>顶点的路径</li></ul></li></ul><hr><h5 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h5><ul><li>在<strong>无向图</strong>G中，如果从顶点V到顶点V`<strong>有路径</strong>，则称V和V’是连通的</li><li>如果对于图中的任意两个顶点V<sub>i</sub>和V<sub>k</sub><strong>都是连通</strong>的，则称G是<strong>连通图</strong></li><li>是否连通是对无向图来说的</li></ul><h5 id="强连通图"><a href="#强连通图" class="headerlink" title="强连通图"></a>强连通图</h5><ul><li>在<strong>有向图</strong>G中，从顶点u到顶点v有路径，且从顶点v到顶点u也有路径，则称u和v是强连通的</li><li>如果有向图的任意两个顶点u和v都是强连通，则称G是<strong>强连通图</strong></li><li>是否强连通是对于有向图来说的</li></ul><p>—（本文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;图&quot;&gt;&lt;a href=&quot;#图&quot; class=&quot;headerlink&quot; title=&quot;图&quot;&gt;&lt;/a&gt;图&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;定义：图G(graph)是一些点和线的集合&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;/2019/08/15/数据结构学习总结-（6-1）图的
      
    
    </summary>
    
      <category term="代码学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据结构学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习总结" scheme="https://shuhaohwang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="数据结构" scheme="https://shuhaohwang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构-学习总结" scheme="https://shuhaohwang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习总结-（5.14.1）哈夫曼编码表的代码实现</title>
    <link href="https://shuhaohwang.github.io/2019/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-14-1%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E8%A1%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>https://shuhaohwang.github.io/2019/08/11/数据结构学习总结-（5-14-1）哈夫曼编码表的代码实现/</id>
    <published>2019-08-11T14:39:41.000Z</published>
    <updated>2019-08-11T16:38:48.698Z</updated>
    
    <content type="html"><![CDATA[<h4 id="哈夫曼编码表"><a href="#哈夫曼编码表" class="headerlink" title="哈夫曼编码表"></a>哈夫曼编码表</h4><ol><li>根据构建的哈夫曼树，左分支标记为0有分支标记为1</li><li>通过二维数组保存编码表</li></ol><hr><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> code[<span class="number">256</span>][<span class="number">128</span>] <span class="comment">//存储哈夫曼编码表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Codeing</span><span class="params">(haffmanNode* node,<span class="keyword">char</span>* temparray,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*处理空结点的情况+递归出口*/</span></span><br><span class="line">    <span class="keyword">if</span>(!node)<span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*当到达叶结点的时候*/</span></span><br><span class="line">    <span class="keyword">if</span>(!node-&gt;R_Node || !node-&gt;L_Node)&#123;</span><br><span class="line">        temparray[index] = <span class="string">'\0'</span>;</span><br><span class="line">        </span><br><span class="line">        strcpy_s(code[node-&gt;data<span class="number">-0</span>],<span class="number">128</span>,temparray);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*递归获取编码表*/</span></span><br><span class="line">    temparray[index] = <span class="string">'0'</span>;</span><br><span class="line">    Codeing(node-&gt;L_Node,temparray,index++);</span><br><span class="line">    temparray[index] = <span class="string">'1'</span>;</span><br><span class="line">    Codeing(node-&gt;R_Node,temparray,index++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="技术小结："><a href="#技术小结：" class="headerlink" title="技术小结："></a>技术小结：</h5><ul><li>temparray数组用来临时存储字符对应的哈夫曼编码，存储格式为字符串</li><li>这里采用二维数组来存储哈夫曼编码表，第一维下标为字符对于的ASCII码，所储存的为对应的编码</li><li>当到达叶结点的时候，在该位置下标的temparry设置为结束符，意味着一个字符串(字符编码)的存储完毕</li></ul><hr><h4 id="编码过程解析"><a href="#编码过程解析" class="headerlink" title="编码过程解析"></a>编码过程解析</h4><img src="/2019/08/11/数据结构学习总结-（5-14-1）哈夫曼编码表的代码实现/1.png"><ul><li>第一步：<code>Codeing(haffmanNode* node,char* temparray,int index)</code><ul><li>根据哈夫曼树构建完毕的node数组</li><li>定义<code>char* temparray[128]；</code>index = 0；</li><li>parent4 拥有左右孩子且不空、temparray[0]  = 0</li></ul></li><li>第二步: <code>Codeing(node(parent4)-&gt;L_Node,temparray,index++);</code><ul><li>index = 1</li><li>B无左右孩子执行<code>if(!node-&gt;R_Node || !node-&gt;L_Node)</code>，temparry[1] = ‘\0’</li><li>code[66(B)] = “0”</li><li>return结束此处递归</li></ul></li><li>第三步： <code>Codeing(node(parent4)-&gt;R_Node,temparray,index++);</code><ul><li>index = 1、temparray[0] = 1</li><li>parent3 拥有左右孩子且不空执行左递归、temparry[1] = 0</li></ul></li><li>第四步：<code>Codeing(node(parent3)-&gt;L_Node,temparray,index++);</code><ul><li>index = 2 </li><li>D结点没有左右孩子执行<code>if(!node-&gt;R_Node || !node-&gt;L_Node)</code>、temparray[2] = ‘\0’</li><li>code[68(D)] = “10”</li><li>return结束此处递归</li></ul></li><li>第五步：<code>Codeing(node(parent3)-&gt;R_Node,temparray,index++)；</code><ul><li>temparry[1] = 1,index = 2</li><li>parent2拥有左右孩子且不空指向左递归、temparry[2] = 0</li></ul></li><li>第六步：<code>Codeing(node(parent2)-&gt;L_Node,temparray,index++)；</code><ul><li>index = 3</li><li>parent1拥有左右孩子且不空指向左递归、temparry[3] = 0</li></ul></li><li>第七步：<code>Codeing(node(parent1)-&gt;L_Node,temparray,index++)；</code><ul><li>index = 4</li><li>C结点没有左右孩子执行<code>if(!node-&gt;R_Node || !node-&gt;L_Node)</code>、temparray[4] = ‘\0’</li><li>code[67(C)] = “1100”</li><li>return结束此处递归</li></ul></li><li>第八步：<code>Codeing(node(parent1)-&gt;R_Node,temparray,index++)；</code><ul><li>temparry[3] = 1，index = 4</li><li>E结点没有左右孩子执行<code>if(!node-&gt;R_Node || !node-&gt;L_Node)</code>、temparray[4] = ‘\0’</li><li>code[69(E)] = “1101”</li><li>return结束此处递归</li></ul></li><li>第九步：<code>Codeing(node(parent2)-&gt;R_Node,temparray,index++)；</code><ul><li>temparry[2] = 1、index = 3</li><li>A结点没有左右孩子执行<code>if(!node-&gt;R_Node || !node-&gt;L_Node)</code>、temparray[3] = ‘\0’</li><li>code[65(A)] = “111”</li></ul></li></ul><hr><ul><li><img src="/2019/08/11/数据结构学习总结-（5-14-1）哈夫曼编码表的代码实现/2.png"></li><li>| code[下标] | 储存元素（编码） |<br>| :————: | :———————: |<br>|  65（A）   |       111        |<br>|  66（B）   |        0         |<br>|  67（C）   |       1100       |<br>|  68（D）   |        10        |<br>|  69（E）   |       1101       |</li></ul><h5 id="解析过程错误小结："><a href="#解析过程错误小结：" class="headerlink" title="解析过程错误小结："></a>解析过程错误小结：</h5><ul><li>函数递归时传参是形参，即index在递归时自加了。结束该分支后返回上一个函数时index值还是递归自加前的值</li></ul><p>—（本文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;哈夫曼编码表&quot;&gt;&lt;a href=&quot;#哈夫曼编码表&quot; class=&quot;headerlink&quot; title=&quot;哈夫曼编码表&quot;&gt;&lt;/a&gt;哈夫曼编码表&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;根据构建的哈夫曼树，左分支标记为0有分支标记为1&lt;/li&gt;
&lt;li&gt;通过二维数组保存编码表&lt;/l
      
    
    </summary>
    
      <category term="代码学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据结构学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习总结" scheme="https://shuhaohwang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="数据结构" scheme="https://shuhaohwang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构-学习总结" scheme="https://shuhaohwang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习总结-（5.14）哈夫曼树的构建代码实现</title>
    <link href="https://shuhaohwang.github.io/2019/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-14%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>https://shuhaohwang.github.io/2019/08/11/数据结构学习总结-（5-14）哈夫曼树的构建代码实现/</id>
    <published>2019-08-10T17:16:45.000Z</published>
    <updated>2019-08-11T14:37:32.852Z</updated>
    
    <content type="html"><![CDATA[<h4 id="哈夫曼树的构建"><a href="#哈夫曼树的构建" class="headerlink" title="哈夫曼树的构建"></a>哈夫曼树的构建</h4><h5 id="哈夫曼树的构建步骤"><a href="#哈夫曼树的构建步骤" class="headerlink" title="哈夫曼树的构建步骤"></a>哈夫曼树的构建步骤</h5><ol><li>根据权重进行从小到大排列</li><li>取最小的两个构成一个子树,并使两个的权值相加用来代替这两个结点</li><li>根据这个新的权重再进行排列</li><li>重复1.2.3步</li></ol><hr><h5 id="代码实现-顺序结构储存"><a href="#代码实现-顺序结构储存" class="headerlink" title="代码实现(顺序结构储存)"></a>代码实现(顺序结构储存)</h5><ul><li><p>结点的构建</p><ul><li><p>根据哈夫曼树的构建，结点首先要包含权值、左右子树指针，其次要包含数据</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">haffmanNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> weigth;<span class="comment">//权值</span></span><br><span class="line">    <span class="keyword">char</span> data;<span class="comment">//数据</span></span><br><span class="line">    </span><br><span class="line">    haffmanNode* L_Node;<span class="comment">//左孩子</span></span><br><span class="line">    haffmanNode* R_Node;<span class="comment">//右孩子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*顺序结构存储二叉树*/</span></span><br><span class="line"></span><br><span class="line">haffmanNode node[<span class="number">256</span>]；</span><br><span class="line"></span><br><span class="line">haffmanNode allL_Node[<span class="number">128</span>];</span><br><span class="line">haffmanNode allR_Node[<span class="number">128</span>];</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>根据权值进行排序(冒泡排序)</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortHaffmanNode</span><span class="params">(haffmanNode* nodes,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    haffmanNode temp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; length - <span class="number">1</span> - i; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodes[k].weight &lt; nodes[k+<span class="number">1</span>].weight)&#123;</span><br><span class="line">                temp = nodes[k];</span><br><span class="line">                nodes[k] = nodes[k+<span class="number">1</span>];</span><br><span class="line">                nodes[k+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>哈夫曼树的构建</p><ul><li><p>对结点先进行排序取最小的构成一颗树</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateHaffmanTree</span><span class="params">(haffmanNode* nodes, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length &lt;= <span class="number">1</span>)<span class="keyword">return</span>;<span class="comment">//递归出口</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*根据权值进行排序*/</span></span><br><span class="line">    sortHaffmanNode(nodes,length);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*用来压缩成哈夫曼编码用*/</span></span><br><span class="line">    allL_Node[length] = nodes[length<span class="number">-1</span>];<span class="comment">//保存左结点</span></span><br><span class="line">    allR_Node[length] = nodes[length<span class="number">-2</span>];<span class="comment">//保存右结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*取最小权重的两个结点重新组成树*/</span></span><br><span class="line">    haffmanNode parent;</span><br><span class="line">    parent.weight = allL_Node[length].weight + allR_Node[length].weight;</span><br><span class="line">    </span><br><span class="line">    parent.L_Node = &amp;allL_Node[length];</span><br><span class="line">    parent.R_Node = &amp;allR_Node[length];</span><br><span class="line">    </span><br><span class="line">    nodes[length - <span class="number">2</span>] = parent;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归直至哈夫曼树创建完成</span></span><br><span class="line">    CreateHaffmanTree(nodes,length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="哈夫曼树构建解析"><a href="#哈夫曼树构建解析" class="headerlink" title="哈夫曼树构建解析"></a>哈夫曼树构建解析</h4><p>例图：<img src="/2019/08/11/数据结构学习总结-（5-14）哈夫曼树的构建代码实现/1.png"></p><ul><li><p>第一步：<code>void CreateHaffmanTree(haffNode* node, int length)</code></p><ul><li><p>node数组内容{A(12),B(26),C(5),D(18),E(4)}，length = 5；</p></li><li><p>排序后 node{B,D,A,C,E},取最小结点C、E组成树</p></li><li><p><code>allL_Node[5] = C、allR_Node[5] = E</code></p></li><li><p>parent1：weight = (4 + 5)9、L_Node = C、R_Node = E</p></li><li><p>node 数组内容变更为{B(26),D(18),A(12),parent1(9)}</p></li></ul></li><li><p>第二步：<code>CreateHaffmanTree(node, length - 1(4))</code></p><ul><li>node 数组内容{B(26),D(18),A(12),parent1(9)}，length = 4</li><li>排序后 node{B,D,A,parent1},取最小结点A、parent1组成树</li><li><code>allL_Node[4] = parent1、allR_Node[4] = A</code></li><li>parent2：weight = (9+12)21、L_Node = parent1、R_Node = A\</li><li>node 数组内容变更为{B(26),D(18),parent2(21)}</li></ul></li><li><p>第三步：<code>CreateHaffmanTree(node, length - 1(3))</code></p><ul><li>node 数组内容{B(26),D(18),parent2(21)}、length = 3</li><li>排序后 node{B,parent2,D},取最小结点parent2、D组成树</li><li><code>allL_Node[3] = D、allR_Node[3] = parent2</code></li><li>parent3：weight = (18+21)39、L_Node = D、R_Node = parent2</li><li>node 数组内容变更为{B(26),parent3(39)}</li></ul></li><li><p>第四步：<code>CreateHaffmanTree(node, length - 1(2))</code></p><ul><li>node 数组内容{B(26),parent3(39)}、length = 2</li><li>排序后 node{parent3,B},取最小结点parent3、B组成树</li><li><code>allL_Node[2] = B、allR_Node[2] = parent3</code></li><li>parent4：weight = (26+39)65、L_Node = B、R_Node = parent3</li><li>node 数组内容变更为{parent4(65)}</li></ul></li><li><p>第五步：<code>CreateHaffmanTree(node, length - 1(1))</code></p><ul><li>length = 1 符合<code>if(length &lt;= 1)return;</code>结束递归，哈夫曼树创建完毕</li></ul></li></ul><hr><img src="/2019/08/11/数据结构学习总结-（5-14）哈夫曼树的构建代码实现/2.png"><div class="table-container"><table><thead><tr><th style="text-align:center">allL_Node</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th></tr></thead><tbody><tr><td style="text-align:center">\</td><td style="text-align:center">NULL</td><td style="text-align:center">B</td><td style="text-align:center">D</td><td style="text-align:center">parent1</td><td style="text-align:center">C</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">allR_Node</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th></tr></thead><tbody><tr><td style="text-align:center">\</td><td style="text-align:center">NULL</td><td style="text-align:center">parent3</td><td style="text-align:center">parent2</td><td style="text-align:center">A</td><td style="text-align:center">E</td></tr></tbody></table></div><p>—（本文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;哈夫曼树的构建&quot;&gt;&lt;a href=&quot;#哈夫曼树的构建&quot; class=&quot;headerlink&quot; title=&quot;哈夫曼树的构建&quot;&gt;&lt;/a&gt;哈夫曼树的构建&lt;/h4&gt;&lt;h5 id=&quot;哈夫曼树的构建步骤&quot;&gt;&lt;a href=&quot;#哈夫曼树的构建步骤&quot; class=&quot;header
      
    
    </summary>
    
      <category term="代码学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据结构学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习总结" scheme="https://shuhaohwang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="数据结构" scheme="https://shuhaohwang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构-学习总结" scheme="https://shuhaohwang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习总结-（5.13）哈夫曼编码</title>
    <link href="https://shuhaohwang.github.io/2019/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-13%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    <id>https://shuhaohwang.github.io/2019/08/10/数据结构学习总结-（5-13）哈夫曼编码/</id>
    <published>2019-08-09T16:46:14.000Z</published>
    <updated>2019-08-09T17:49:51.117Z</updated>
    
    <content type="html"><![CDATA[<h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><h5 id="哈夫曼编码是什么？"><a href="#哈夫曼编码是什么？" class="headerlink" title="哈夫曼编码是什么？"></a>哈夫曼编码是什么？</h5><p>哈夫曼编码是用来压缩数据的一种手段，在网络上信息的传输都是通过二进制来进行输送的（0和1），在进行数据输送的时候，首先就要将即将输送的数据进行转码，使其变为二进制再进行传输。例如：</p><ul><li><p>要传输<code>‘ABCADBBAED’</code>这段数据。且你知道一个二进制转换编码表：</p><ul><li>| 字符 | 编码 |<br>| :—: | :—: |<br>|  A   | 000  |<br>|  B   | 100  |<br>|  C   | 110  |<br>|  D   | 111  |<br>|  E   | 101  |</li></ul></li><li><p>则这段字符串会先转换成二进制码：<code>000100110000111100100000101111</code></p></li><li><p>上面的二进制转换表编码是以3位进行编码的，而用哈夫曼编码进行编译转换，则会让这段字符串传输的时候能够更为简短。</p></li></ul><h5 id="哈夫曼编码的使用"><a href="#哈夫曼编码的使用" class="headerlink" title="哈夫曼编码的使用"></a>哈夫曼编码的使用</h5><p>哈夫曼编码是通过哈夫曼树进行转换出来的，例如在上面的字符串：<code>‘ABCADBBAED’</code>是出现在一个文章里面的，这个文章里面含有：</p><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">出现次数</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">26</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">18</td></tr><tr><td style="text-align:center">E</td><td style="text-align:center">4</td></tr></tbody></table></div><p>根据上表进行转换为哈夫曼树</p><img src="/2019/08/10/数据结构学习总结-（5-13）哈夫曼编码/1.png"><p>通过对哈夫曼树处理，往左走为0往右走为1，通过记录会形成一个新的转换表</p><img src="/2019/08/10/数据结构学习总结-（5-13）哈夫曼编码/2.png"><ul><li>| 字符 | 编码 |<br>| :—: | :—: |<br>|  A   | 111  |<br>|  B   |  0   |<br>|  C   | 1100 |<br>|  D   |  10  |<br>|  E   | 1101 |</li></ul><p>根据表中的内容把要输送的字符串<code>‘ABCADBBAED’</code>进行转换成二进制<code>111011001111000111110110</code></p><p>对比一开始用3个编码进行转换的字符串编码会发现，哈夫曼编码进行转换处理的二进制码数为24个，比前面的少了6个，可以发现运用哈夫曼编码可以使传输的二进制码被压缩成更简单二进制码。</p><hr><h5 id="哈夫曼编码的好处"><a href="#哈夫曼编码的好处" class="headerlink" title="哈夫曼编码的好处"></a>哈夫曼编码的好处</h5><ul><li><strong>使转换的二进制码更简洁</strong><ul><li>哈夫曼编码是通过检测传输的字符串中字符的出现频率进行生成对应的编码表。采用的是前缀编码。</li></ul></li><li><strong>因为采用的前缀的编码，进行译码的时候减少出错</strong></li><li>….</li></ul><hr><h4 id="译码"><a href="#译码" class="headerlink" title="译码"></a>译码</h4><p>进行译码的过程很简单，通过一开始构建的哈夫曼树，进行译码。</p><ul><li><p>例如：<code>111011001111000111110110</code></p><ul><li><img src="/2019/08/10/数据结构学习总结-（5-13）哈夫曼编码/2.png"></li></ul></li><li><p>译码过程：<strong>从根开始</strong>遇到0就走左，遇到1就走右，当到达叶结点的时候，翻译出该字符，然后<strong>重新返回根结点重新识别</strong></p></li><li><p>译码结果：ABCADBBAED</p></li></ul><hr><h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><ul><li>从上面的译码过程可以看出，对哈夫曼编码编码后的二进制码进行译码的时候只需根据编码对哈夫曼树进行遍历即可。</li></ul><p>—（本文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;哈夫曼编码&quot;&gt;&lt;a href=&quot;#哈夫曼编码&quot; class=&quot;headerlink&quot; title=&quot;哈夫曼编码&quot;&gt;&lt;/a&gt;哈夫曼编码&lt;/h4&gt;&lt;h5 id=&quot;哈夫曼编码是什么？&quot;&gt;&lt;a href=&quot;#哈夫曼编码是什么？&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="代码学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据结构学习" scheme="https://shuhaohwang.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习总结" scheme="https://shuhaohwang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="数据结构" scheme="https://shuhaohwang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构-学习总结" scheme="https://shuhaohwang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
