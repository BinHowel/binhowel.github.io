<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.15）二叉查找树的插入与删除（附加）]]></title>
    <url>%2F2019%2F10%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-15%EF%BC%89%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%EF%BC%88%E9%99%84%E5%8A%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[二叉查找树的插入操作递归实现 思路： 整体还是围绕二叉查找树的性质进行定位要插入的位置，当移动到空位置时则会返回一个插入值构建的新结点供其父结点相接，因为使用递归如果要插入的位置为两个结点之间，则会先把后一个结点的左右孩子先接入这个新的结点后再把这个新结点接入其前面的结点 12345678910BiNode* InsertBST(BiNode root,T e)&#123; if(!root)return new BiNode(e); if(e &lt; root-&gt;data) root-&gt;L_Node = InsertBST(root-&gt;L_Node,e); else if(e &gt; root-&gt;data) root-&gt;R_Node = InsertBST(root-&gt;R_Node,e); return root;&#125; 循环迭代实现 思路：通过循环进行遍历，来寻找插入的位置。若插入的结点在二叉树中已经存在则之间返回nullptr终止插入操作，否则进行把新的结点进行插入二叉树中 123456789101112131415161718192021BiNode* InsertBST(BiNode root,T e)&#123; BiNode* p = root; BiNode* parent = nullptr; while(p &amp;&amp; p-&gt;data!= e)&#123; parent = p; if(e &lt; p-&gt;data) p = p-&gt;L_Node; else p = p-&gt;R_Node; &#125; if(p)return nullptr; if(!parent)return new BiNode(e); else if(e &lt; parent-&gt;data)&#123; parent-&gt;L_Node = new BiNode(e); return parent-&gt;L_Node; &#125;else&#123; parent-&gt;R_Node = new BiNode(e); return parent-&gt;R_Node; &#125;&#125; 二叉查找树的删除操作 思路：二叉查找树的删除 当找到要删的结点后通常有5种情况， 第一种情况：该结点为叶子结点，那么直接删除即可， 第二种情况：该结点只存右子树，那么直接删除该结点后，要让其前一个结点重新连接到这个被删除结点的右子树。 第三种情况：只存在左子树，处理方法同第二种情况。 第四种情况：左右子树都不存在，此时要寻找待删除结点的右子树最左端的结点(该结点比待删除结点大且最接近)，替换掉待删除结点的数据，然后重新在待删除结点的右结点调用删除操作，把最左端的结点删除即可。 第五种情况：没有找到待删除结点，直接返回空 123456789101112131415161718192021222324252627282930313233343536BiNode* deleteBST(BiNode root , T e)&#123; if(!root) return nullptr; if(root-&gt;data &gt; e) deleteBST(root-&gt;L_Node,e); else if(root-&gt;data &lt; e) deleteBST(root-&gt;R_Node,e); else&#123; //若为叶子结点，直接删除该结点 if(!root-&gt;L_Node &amp;&amp; !root-&gt;R_Node)&#123; delete (root); return nullptr; &#125;else if(!root-&gt;R_Node)&#123; BiNode* ret = root-&gt;L_Node; delete(root); return ret; &#125; else if (!root-&gt;L_Node) &#123; BiNode* ret = root-&gt;R_Node; delete(root); return ret; &#125; else&#123; //若所删除的结点存在左右孩子,则选取其右子树中最小的进行替换该节点，然后往右子树递归上诉操作 BiNode* temp = root-&gt;R_Node; while(temp-&gt;L_Node)&#123; temp = temp-&gt;L_Node; &#125; root-&gt;data = temp-&gt;data; root-&gt;R_Node = deleteBST(root-&gt;R_Node , temp-&gt;data); &#125; &#125; return root; &#125; 代码解析： 有如下二叉树查找树，假设此时要删除 89号的结点 第一步：找到该结点发现该结点存在左右子树，接下来寻找该节点右子树下最左端的结点进行替换。 第二步：替换后，原来89号结点的右子树重复上诉操作被替换的结点111 总体实验结果123456789101112131415161718192021222324252627int main(void) &#123; BiNode&lt;int&gt;* b1 = new BiNode&lt;int&gt;(56); b1-&gt;L_Node = new BiNode&lt;int&gt;(34); b1-&gt;R_Node = new BiNode&lt;int&gt;(89); BiNode&lt;int&gt;* b2 = b1-&gt;L_Node; b2-&gt;R_Node = new BiNode&lt;int&gt;(55); b2-&gt;L_Node = new BiNode&lt;int&gt;(12); b2 = b1-&gt;R_Node; b2-&gt;R_Node = new BiNode&lt;int&gt;(100); b1-&gt;Fot(b1); cout&lt;&lt; "插入了40" &lt;&lt; endl; b1-&gt;Fot(b1-&gt;InsertBST(b1, 40)); cout &lt;&lt; endl; b1-&gt;Fot(b1); cout &lt;&lt; endl &lt;&lt; "删除56" &lt;&lt; endl; b1-&gt;deleteBST(b1, 56); b1-&gt;Fot(b1); cout &lt;&lt;endl&lt;&lt; "删除100"&lt;&lt;endl; b1-&gt;deleteBST(b1, 100); b1-&gt;Fot(b1);&#125; 实验结果：]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（7.1）查找]]></title>
    <url>%2F2019%2F10%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%887-1%EF%BC%89%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[查找的概念在数据集合中寻找满足某种条件的数据元素，也就是根据给定的某个值，在查找表中确定一个关键字等于给定值的记录或数据元素。 关键字 数据元素中某个数据项或单独关键字 关键字可以相同，即不一定唯一标识这个元素 平均查找长度查找就是不断将数据元素的关键字与待查找关键字进行比较，查找算法在查找成功时平均比较的次数称作平均查找长度 查找的类型 线性查找表 ·数据集合是一个线性表(数组或链表) 二叉查找树 数据集合是一个二叉树 哈希(散列)表 根据哈希函数(关键字映射到存储地址)存储和查找。类似根据下标到地址 线性查找主要用于线性的数据结构中进行查找 实现思路讲线性表中的每个元素和关键字进行比较，直到找到满足条件(eg:相等)的元素，则查找成功，给出该对象在表中的位置。 若没有找到关键字相等的元素则查找失败。 直接线性查找 实现思路：通过遍历每一个元素进行匹配要查找的元素，如果找到则返回其下标，未找到则返回 -1 12345678910111213141516171819202122232425template&lt;typename T,typename TKey,typename TFunc&gt;int SqSearch(const vector&lt;T&gt;&amp; array,TKey key,TFunc Func)&#123; for(int i = 0; i &lt; array.size(); i++) if(Func(TKey key,array[i]))return i; return -1; &#125;/*用模板函数使查找条件自由变换*/template&lt;typename TKey,typename T&gt;bool IsEqual(TKey key,T Num)&#123; return key == Num;&#125;int main(void)&#123; vector&lt;int&gt; arr&#123;12,34,678,90,56,89,100,55&#125;; cout &lt;&lt; "数字2的位置为 " &lt;&lt; SqSearch(arr, 2, IsEqual&lt;int, int&gt;) &lt;&lt; endl; cout &lt;&lt; "数字56的位置为 " &lt;&lt; SqSearch(arr, 56, IsEqual&lt;int, int&gt;) &lt;&lt; endl;&#125;/*结果输出：数字2的位置为 -1数字56的位置为 4*/ 二分查找(折半查找)注意!!!：此查找算法要在数组已排好序（从小到大）的情况下才适应 思路：首先待查找值的数组已经是从小到大排序完毕。存在一个mid变量下标，一开始便定位在该数组的中间元素，然后通过要查找的值与该中值比较，如果比中间值大，那么则只需在中值后的元素进行查找，小了则反之。重复多次直到中值与该待查找的值相等了就查找成功，否则失败 123456789101112131415161718192021222324252627282930313233template&lt;typename T,typename TKey,typename TFunc&gt;int BinarySearch(const vector&lt;T&gt; array,TKey Key,TFunc Func)&#123; int min = 0; int max = array.size() - 1; while(min &lt;= max)&#123; auto mid = (max+min)/2; auto ret = Func(Key,array[mid]); if(ret == 0)return mid; else if(ret &lt; 0)&#123; max = mid - 1; &#125;else&#123; mid = mid + 1; &#125; &#125; return - 1;&#125;template&lt;typename T,typename TKey&gt;int IsEqual(TKey key,T Num)&#123; return key - Num;&#125;int main(void)&#123; vector&lt;int&gt; arr&#123;12,34,55,56,89,90,100,678&#125;; cout &lt;&lt; "数字2的位置为 " &lt;&lt; BinarySearch(arr, 2, IsEqual&lt;int, int&gt;) &lt;&lt; endl; cout &lt;&lt; "数字56的位置为 " &lt;&lt; BinarySearch(arr, 56, IsEqual&lt;int, int&gt;) &lt;&lt;endl;&#125;/*输出结果：数字2的位置为 -1数字56的位置为 3*/ 二叉查找树什么是二叉查找树？ 一棵空树，或者是具有下列性质的二叉树 （1）若左子树不空，则左子树上所有节点的值均小于它的[节点的值； （2）若右子树不空，则右子树上所有节点的值均大于它的根节点的值； （3）左、右子树也分别为二叉排序树； （4）没有键值相等的节点。 递归查找算法 思路：类似二叉树的先序遍历，通过对根结点的data进行比较 因为查找二叉树的左子树是一定小于其结点的，右子树则一定大于结点。所以可以通过比较结点的data值。来进行递归操作，如果待查找值比结点的数值大那么往右子树找，同理：小了就往左子树找 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253template&lt;typename T&gt;struct BiNode&#123; T data; BiNode* R_Node = nullptr; BiNode* L_Node = nullptr; BiNode(T num)&#123; data = num; &#125; BiNode* BiSearchTree(BiNode* tree,T Key)&#123; if(!tree)return nullptr; if(tree-&gt;data == Key)return tree; if(tree-&gt;data &gt; Key)&#123; return BiSearchTree(tree-&gt;L_Node,Key); &#125;else&#123; return BiSearchTree(tree-&gt;R_Node,Key); &#125; &#125;&#125;;int main(void)&#123; BiNode&lt;int&gt; b1(56); BiNode&lt;int&gt; b2(55); BiNode&lt;int&gt; b3(34); BiNode&lt;int&gt; b4(12); BiNode&lt;int&gt; b5(89); BiNode&lt;int&gt; b6(100); b1.L_Node = &amp;b2; b1.R_Node = &amp;b5; b2.R_Node = &amp;b3; b2.L_Node = &amp;b4; b5.R_Node = &amp;b6; cout &lt;&lt; endl; if (b1.BiSearchTree(&amp;b1, 1))cout &lt;&lt; "找到了" &lt;&lt; endl; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125; if (b1.BiSearchTree(&amp;b1, 89))cout &lt;&lt; "找到了" &lt;&lt; endl; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125;&#125;/*输出结果：没有找到找到了*/ 使用循环迭代来实现查找二叉树的查找 思路：总体思路也是跟递归差不多，运用二叉查找树的特性，循环中如果结点不为空并且结点的data值与要查找的值不相等意味着还没有查找到值则继续对结点的data值进行比较，如果大了就移动到该结点的右子树继续查找，同理，小了就向左边移动继续查找，循环上诉操作。当循环结束后便根据最终指针移动后得到的结点情况来判断是否查找成功，如果为空那么就没有找到，反之则查找成功 12345678910111213141516171819202122232425262728293031323334353637383940414243444546BiNode* BiSearchTree2(BiNode* tree,T Key)&#123; BiNode* temp = tree; while(temp &amp;&amp; temp-&gt;data != key) if(Key &gt; temp-&gt;data) temp = temp-&gt;R_Node; else temp = temp-&gt;L_Node; if(!temp)return nullptr; return temp;&#125;int main(void)&#123; BiNode&lt;int&gt; b1(56); BiNode&lt;int&gt; b2(55); BiNode&lt;int&gt; b3(34); BiNode&lt;int&gt; b4(12); BiNode&lt;int&gt; b5(89); BiNode&lt;int&gt; b6(100); b1.L_Node = &amp;b2; b1.R_Node = &amp;b5; b2.R_Node = &amp;b3; b2.L_Node = &amp;b4; b5.R_Node = &amp;b6; cout &lt;&lt; endl; if (b1.BiSearchTree2(&amp;b1, 1))cout &lt;&lt; "找到了" &lt;&lt; endl; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125; if (b1.BiSearchTree2(&amp;b1, 89))cout &lt;&lt; "找到了" &lt;&lt; endl; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125;&#125;/*输出结果：没有找到找到了*/ —（本文未完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-(3.3)typename的使用场合及使用范例、函数指针参数化]]></title>
    <url>%2F2019%2F09%2F19%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-3-3-typename%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E5%90%88%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%8C%83%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[typename的使用场合在类模板中存在自定义类型时 相关返回值函数必须添加typename 范例： 123456789101112131415161718192021template&lt;typename T&gt;class array&#123; public: /*自定义类型：把模板参数T定义为 自定义类型名Size*/ typedef T Size; Size getsize(T i);&#125;/*类外定义的时候需要添加 typename 模板类名&lt;&gt; 来指定该模板类中的自定义类型Size*/template&lt;typename T&gt;typename array&lt;T&gt;::Size array&lt;T&gt;::getsize(T i)&#123; cout &lt;&lt; "size的值为" &lt;&lt; i; return i;&#125;int main()&#123; array&lt;int&gt; arr; arr.getsize(2);&#125; 实验结果： 在类模板中存在内部类的情况 范例: 12345678910111213141516171819202122232425template&lt;typename T&gt;class Lklist&#123; Node* head; class Node&#123; public: Node* next; T data; &#125;; public: Node* GetNodeID(int i);&#125;;template&lt;typename T&gt;typename Lklist&lt;T&gt;::Node* Lklist&lt;T&gt;::GetNodeID(int i)&#123; cout &lt;&lt; "测试函数传参的值为 " &lt;&lt; i &lt;&lt; endl; return NULL;&#125;int main()&#123; Lklist&lt;int&gt; lk; lk.GetNodeID(100);&#125; 实验结果： 总结： 上述两种情况，在类模板外定义函数时，都必须要加typename 目的是通知编译器，该名称是一个类型名称，且为类模板内定义的类型或类。 上述情况只能用typename不能替换为class 其余范例： 123456789101112131415template&lt;typename T&gt;typename T::size_type getlength(const T&amp;c)&#123; if(c.empty()) return 0; return c.size(); &#125;int main()&#123; string str = "HelloShuHao"; string::size_type size = getlength(str); cout &lt;&lt; "测试值:str的长度为：" &lt;&lt; size &lt;&lt; endl;; &#125; 实验结果： 函数指针作参数1234567891011121314typedef int(*Func)(int a,int b);int add(int i, int k)&#123; return i+k;&#125;void testfunc(int i, int k, Func f)&#123; cout &lt;&lt; "测试函数指针 两数相加的值为: " &lt;&lt; f(i,k) &lt;&lt; endl;&#125; int main()&#123; testfunc(10,15,add);&#125; 实验结果： typename使用范例改造成函数模板1234567891011121314151617typedef int(*Func)(int a,int b);int add(int i, int k)&#123; return i+k;&#125;template&lt;typename T,typename F&gt;void testfunc(T i, T k, F f)&#123; cout &lt;&lt; "测试函数指针 两数相加的值为: " &lt;&lt; f(i,k) &lt;&lt; endl;&#125; int main()&#123; //此时F类型识别为函数指针，则使用函数指针类型 testfunc(10,15,add);//依旧通过编译没有报错&#125; 若使用类(可调用对象)123456789101112131415161718192021222324252627282930313233343536373839typedef int(*Func)(int a,int b);int add(int i, int k)&#123; return i+k;&#125;class TestClass&#123; public: TestClass()&#123; cout &lt;&lt; "这是TC的构造函数 被调用了" &lt;&lt; endl; &#125; TestClass(const TestClass&amp; t)&#123; cout &lt;&lt; "拷贝构造函数 被调用了" &lt;&lt; endl; &#125; int operator()(int a,int b)&#123; return a+b; &#125; &#125;;template&lt;typename T,typename F&gt;void testfunc(T i, T k, F f)&#123; cout &lt;&lt; "测试函数指针 两数相加的值为: " &lt;&lt; f(i,k) &lt;&lt; endl;&#125; int main()&#123; //此时F类型识别为函数指针，则使用函数指针类型 testfunc(10,15,add);//依旧通过编译没有报错 cout &lt;&lt; endl; TestClass tc;//此时调用构造函数 testfunc(100,150,tc);//传参是参数临时对象，调用拷贝构造函数&#125; 实验结果： 结果分析：可以发现，当对象被创建时调用了一次构造函数，然后传参入testfunc函数时，调用了一次拷贝构造函数，最后输出值，整个过程，T的类型推断为int整型 然后 F被推断为TestClass类型，然后该类型对象通过重载后的()返回两个整型参数的和值。 此时也可以通过直接传参消除临时对象12345int main()&#123; //TestClass tc; testfunc(100,150,TestClass());//直接使用构造函数，可以消除临时对象的产生&#125; 实验结果： 默认模板参数总体跟函数默认参数类似，从右到左，存在默认参数不能有断 范例： 12345template&lt;typename T,int a = 100&gt;class A&#123;&#125;;//没有问题template&lt;typename T = string,int a = 100&gt;class B&#123;&#125;;//没有问题template&lt;typename T = string,int a&gt;class C&#123;&#125;;//报错！a没有提供默认参数 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-(3.2)类模板]]></title>
    <url>%2F2019%2F09%2F18%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-3-2-%E7%B1%BB%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[类模板模板参数类型使类能够根据给定的实际类型，来对类内的一些参数类型进行变化 编译器不能为类模板推断模板参数类型，所以要使用类模板，必须要在模板名后用&lt;&gt;来提供实际类型 格式： template&lt;typename T&gt;class 类名 template&lt;typename T，B&gt;class 类名 template&lt;typename T，int a&gt;class 类名 注意： 类模板成员函数，可以写在类模板定义中。(即：不在类外定义类成员函数）其中这种成员函数会隐式声明为inline内联函数 类模板被实例化对象后，类内的对应的实例都会有自己版本的成员函数 在实例化类模板对象的时候，要在类模板名后加&lt;&gt;并给定实际类型 定义在类模板之外的成员函数必须以template关键字开头，后面加类模板的参数列表。其次类名后面要添加&lt;&gt;吧模板参数列表里面的所有模板参数名列出来(多个参数用 , 隔开) 范例： 123456789101112131415161718192021222324252627282930template&lt;typename T&gt;class Sqlist&#123; public: T* data;//使用模板参数 /*类内定义的函数会隐式声明为inline函数*/ /*inline*/ void func()&#123; cout &lt;&lt; "这是该类的func函数" &lt;&lt; endl; &#125; /*外部定义，在外部要加&lt;&gt;*/ T func2(T a,T b); &#125;;/*要类模板名要添加模板参数列表*/template&lt;typename T&gt; T Sqlist&lt;T&gt;::func2(T a,T b)&#123; cout &lt;&lt; "这是该类的func2函数" &lt;&lt; endl; return a+b;&#125;int main()&#123; /*在实例化类模板对象时，要用&lt;&gt;来提供实际类型*/ Sqlist&lt;int&gt; sq1; sq1.func(); Sqlist&lt;double&gt; sq2; sq2.func2(12.3,14.2);&#125; 实验结果： 非模板类型在定义模板类的时候模板参数不提供模板参数，而是给定实际参数 格式： template&lt;int a&gt;class 类名 template&lt;typename T，int a&gt;class 类名 范例： 1234567891011121314151617181920template&lt;typename T,int size = 10&gt;class Sqlist&#123; public: T data[size]; void func(); &#125;;/*要在类模板后的&lt;&gt;把所有的类模板参数列出来，即便存在默认值*/template&lt;typename T,int size&gt; void Sqlist&lt;T,size&gt;::func()&#123; cout &lt;&lt; "这是该类的func函数 其中size: " &lt;&lt; size &lt;&lt; endl;&#125;int main()&#123; /*存在默认参数可以不给size的值*/ Sqlist&lt;int&gt; sq1; sq1.func(); Sqlist&lt;double,100&gt; sq2; sq2.func();&#125; 实验结果： 注意： 浮点数不能作为非类型模板参数 template&lt;typename T,double a&gt; class B //报错，double和float都不能做非类型模板参数 类类型不能做非类型模板参数 class A{};template&lt;typename T,A a&gt; class B //报错：类类型不能做非类型模板参数 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（3.1）模板、函数模板]]></title>
    <url>%2F2019%2F09%2F17%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%883-1%EF%BC%89%E6%A8%A1%E6%9D%BF%E3%80%81%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[模板所谓泛型编程 是独立于任何特定类型类型的方式编写代码。使用泛型编程时，需要提供具体的程序实例。 模板是泛型编程的基础，是一种在创建类或函数时的一种公式，根据给定的类型来决定公式中具体参数的类型值。 函数模板函数模板定义与使用会更具实际类型来推断模板实际类型的函数，一般情况下会编译器会自动判别。 格式： template&lt;typename T&gt; T 函数名(参数) template&lt;class T&gt; T 函数名(参数) 范例： 12345678template&lt;typename T&gt; T add(T a,T b)&#123; return a + b;&#125;int main()&#123; cout &lt;&lt; "12 + 13 = " &lt;&lt; add(12,13) &lt;&lt; endl; cout &lt;&lt; "5.6 + 12.3 = " &lt;&lt; add(5.6,12.3) &lt;&lt; endl;&#125; 实验结果： 实际上，函数模板会更具你实际给定的对象类型来生成对应的函数。例如：如果你给定T的类型为double，则系统会生成double add(double a,double b)给定整型int则会生成对应的函数int add(int a,int b)。 非类型模板参数在模板参数列表中没有使用类型参数，而是给定实际的类型的参数 格式：template&lt;实际类型 T&gt; 范例： 1234567891011121314151617181920212223242526/*需要在&lt;&gt;给定实际类型才能调用*/template&lt;int a,int b&gt;int add1()&#123; return a+b;&#125;/*混合型*/template&lt;typename T,int a,int b&gt;T add2(T c)&#123; int temp = c; return a + b + (int)c;&#125;/*特殊：不用提供实际类型，由系统自动推断*/template&lt;unsigned L1,unsigned L2&gt;int charscomp(const char(&amp;p1)[L1],const char(&amp;p2)[L2])&#123; return strcmp(p1,p2);&#125;int main()&#123; cout &lt;&lt; "12 + 13 = " &lt;&lt; add1&lt;12,13&gt;() &lt;&lt; endl; /*不需要在&lt;&gt;中给定实际类型*/ cout &lt;&lt; endl &lt;&lt; charscomp("ShuHao","hello");&#125; 其他 如果要声明函数模板为内联函数，那么inline关键字要在template与函数返回值之间。例如: template&lt;typename T, int a&gt; inline T func(T b){return b+a} 模板函数一般放在头文件中，再多个CPP文件中include该头文件不会出现函数重定义 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-(2.11)类型转换构造函数、运算符、类成员指针]]></title>
    <url>%2F2019%2F09%2F11%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2-11-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E7%B1%BB%E6%88%90%E5%91%98%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[类型转换构造函数实质：把某个类型的变量，通过类的构造函数隐式转换变为该类类型的变量。 例如： 123456789101112class A&#123; int num; A(int i):num(i)&#123;&#125; &#125;int main()&#123; int k = 100; A a = k;//使整型k转换类型为A A a2 = 120; //把整型转换成类型A变量&#125; 类型转换运算符与类型转换构造函数的作用相反，类型转换构造函数是将某个类型转换成该类类型，而类型转换运算符则把该类类型转换成特点的类型 定义格式：operator type()||operator type() const(一般会加const后缀，防止值被修改) 例如： 123456789101112131415class A&#123; public: int num = 100; A(int i):num(i)&#123;&#125; operator int()&#123; return num; &#125; &#125;int main()&#123; A a; int k = a + 100;//结果K的值为200&#125; 显示调用类型转换运算符即：把类型转换运算符当做该类对象的成员函数进行调用 1234int main()&#123; A a; int k = a.operator int() + 100;//显示调用类型转换运算符&#125; 禁止使用隐式调用类型转换运算符对类型转换构造函数同时适用：在前面加explicit(禁止编译器为我们做隐式类型转换) 123456789101112131415class A&#123; public: int num = 100; A(int i):num(i)&#123;&#125; explicit operator int()&#123; return num; &#125; &#125;int main()&#123; A a; int k = a + 100;//报错，&#125; 类成员指针类成员函数指针 定义：指向类成员函数的指针 格式： 声明普通成员函数指针：类名：：*函数指针变量名 获取类成员函数地址：&amp;类名：：成员函数名 使用函数指针格式：(类对象名.*函数指针变量名)(参数)（若为对象指针则使用-&gt;指向运算符调用） 普通成员函数注意点：成员函数属于类，只要类存在这函数地址就存在(有无对象被创建没关系)、若要使用成员函数指针需要绑定到一个类对象上去 范例： 12345678910111213141516class A&#123; public: void Afunc(int i)&#123;cout &lt;&lt; "这是类A中的普通成员函数Afunc，参数I：" &lt;&lt; i &lt;&lt; endl; &#125;&#125;;int main()&#123; /*声明函数指针*/ void(A::*Func)(int); /*给函数指针赋予类成员函数地址值*/ Func = &amp;A::Afunc; A a; A* a2; (a.*Func)(100); //(a2-&gt;*Func)(200);&#125; 实验结果： 虚成员函数 范例： 1234567891011121314class A&#123; public: void Afunc(int i)&#123;cout &lt;&lt; "这是类A中的普通成员函数Afunc，参数I：" &lt;&lt; i &lt;&lt; endl; &#125; virtual void virtualFunc(int i)&#123;cout &lt;&lt; "这是类A中的虚成员函数virtualFunc，参数I：" &lt;&lt; i &lt;&lt; endl; &#125; &#125;;int main()&#123; /*声明函数指针*/ void(A::*virtualFunc)(int) = &amp;A::virtualFunc; A a; (a.*Func)(100);&#125; 实验结果： 静态类成员函数 格式： 声明普通成员函数指针：*函数指针名 (eg: void(*staticFunc)(int)) 获取地址：&amp;类名：：成员函数名 使用：直接 函数指针名(参数) 类成员变量格式： 定义指针: 类型 类名：：*指针名 获取地址: &amp;类名：：成员变量名 注意：此时获取的地址不是该成员变量在内存中的地址，而是对于类来说的偏移量 普通成员变量范例： 12345678910111213141516class B&#123; public: int num1; int num2;&#125;;int main()&#123; int B::*P_num = &amp;B::num1; B b; b.*P_num = 100; cout &lt;&lt; "此时类B中的成员变量num1的值为 " &lt;&lt; b.num1 &lt;&lt; endl; return 0;&#125; 实验结果： 静态成员变量范例： 12345678910111213141516class B&#123; public: int num1; static int num2;//此时只是声明了一个静态变量。要在类外定义&#125;;int B::num2 = 0;int main()&#123; int* static_P_num = &amp;B::num2; B b; *static_P_num = 100; cout &lt;&lt; "此时类B中的静态成员变量num2的值为 " &lt;&lt; b.num2 &lt;&lt; endl; return 0;&#125; 实验结果： —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（2.10）构造函数继承、多继承、虚继承]]></title>
    <url>%2F2019%2F09%2F06%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-10%EF%BC%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[构造函数继承C++在继承的时候子类在构造的时候是会调用父类的构造函数的，但实际上，父类的默认构造函数、拷贝构造、移动构造函数是不会继承给子类的，子类只会继承父类由程序员自己定义的构造函数。 1234567891011121314151617181920212223242526272829class Father&#123; public: int f_num; Father(int i):f_num(i)&#123; cout &lt;&lt; "父类的构造函数被调用" &lt;&lt; endl; &#125; virtual ~Father()&#123; cout &lt;&lt; "父类的析构函数被调用" &lt;&lt; endl; &#125; &#125;;class Child1:public Father&#123; public: int c1_num; Child1(int i):c1_num(i),Father(i)&#123; cout &lt;&lt; "子类1的构造函数被调用" &lt;&lt; endl; &#125; ~Child1()&#123; cout &lt;&lt; "子类1的析构函数被调用" &lt;&lt; endl; &#125; &#125;;int main()&#123; Child1 c(9);&#125; 实验结果： 当父类中含有多个参数的构造函数时，子类也会继承与其，但是在子类的默认构造函数中不会调用父类的这些构造函数，而是会调用无参的父类的构造函数或者带有默认参数的构造函数。 123456789101112131415161718192021222324252627282930313233343536373839class Father&#123; public: int f_num; int f_num2; Father(int i,int k):f_num(i),f_num2(k)&#123; cout &lt;&lt; "父类的构造函数被调用" &lt;&lt; endl; &#125; Father(int i = 100):f_num(i),f_num2(i)&#123; cout &lt;&lt; "父类的构造函数被调用" &lt;&lt; endl; &#125; virtual ~Father()&#123; cout &lt;&lt; "父类的析构函数被调用" &lt;&lt; endl; &#125; &#125;;class Child1:public Father&#123; public: int c1_num; Child1(int i):c1_num(i)&#123; cout &lt;&lt; "子类1的构造函数被调用" &lt;&lt; endl; &#125; ~Child1()&#123; cout &lt;&lt; "子类1的析构函数被调用" &lt;&lt; endl; &#125; &#125;;int main()&#123; Child1 c(9); cout &lt;&lt; "父类的f_num： "&lt;&lt;c.f_num &lt;&lt; "父类的f_num2：" &lt;&lt; c.f_num2 &lt;&lt; endl;&#125; 实验结果： 结果分析：可以发现子类调用了父类的Child1(int i = 100):c1_num(i),Father(i) 那如果要在子类对象再创建时调用父类的其他构造函数该怎么办呢？除了在子类的构造函数里调用的方法外还可以使用using关键字实现 1234567891011121314151617181920212223class Child1:public Father&#123; public: int c1_num; using Father::Father;//使用using关键字 Child1(int i):c1_num(i)&#123; cout &lt;&lt; "子类1的构造函数被调用" &lt;&lt; endl; &#125; ~Child1()&#123; cout &lt;&lt; "子类1的析构函数被调用" &lt;&lt; endl; &#125; &#125;;int main()&#123; Child1 c(9,2); cout &lt;&lt; "父类的f_num： "&lt;&lt;c.f_num &lt;&lt; "父类的f_num2：" &lt;&lt; c.f_num2 &lt;&lt; endl; &#125; 实验结果： 结果分析：使用using Father::Father;发现子类在没有创建2个参数的构造函数也可以用两个参数进行调用构造函数，原因是使用using Father::Father;后编译器会在子类创建隐藏的含有两个参数的构造函数，用来调用父类的其他构造函数。 小结：C++中，如果父类含有多个构造函数，多数下会全部继承，但有以下例外： 子类中的构造函数与父类的构造函数有相同的参数列表，则子类会覆盖父类的构造函数，导致无法继承父类的构造函数 默认构造函数，移动、拷贝构造函数不会被继承。 多重继承与虚继承多重继承C++允许多继承，一个子类在多继承时，会存在两个或以上个父类，也意味着，该子类会继承多个父类的成员变量、成员函数。 123456789101112131415161718192021222324252627282930313233343536373839class A&#123; public: int a; A(int i):a(i)&#123; cout &lt;&lt; "调用了A的构造函数" &lt;&lt; endl; &#125; virtual ~A()&#123; &#125; &#125;;class B&#123; public: int b; B(int i):b(i)&#123; cout &lt;&lt; "调用了B的构造函数" &lt;&lt; endl; &#125; virtual ~B()&#123; &#125; &#125;;/*C同时继承A和B*/class C:public B,public A&#123; public: int c C(int i):c(i)&#123; cout &lt;&lt; "调用了C的构造函数" &lt;&lt; endl; &#125; virtual ~C()&#123; &#125; &#125;;int main()&#123; C c(1);&#125; 实验结果： 结果分析：结果发现，在创建C类对象时，调用了A和B的构造函数。 上述的多继承父类构造函数调用顺序是根据子类的继承(派生列表)顺序来决定的，例如上面是先继承B在继承A，则先调用B的构造函数再调用A的构造函数。如果先继承A再继承B则： 多重继承引发的问题多继承引发的父类创建累赘多余对象问题当一个子类继承两个类的时候，恰好被继承的两个类又继承于同一个父类，那么该子类在创建对象的时候就会调用两次该父类的构造函数，这样的操作难免会造成程序效率低下的情况 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class father&#123; public int father_num; father()&#123; cout &lt;&lt; "调用了father类的构造函数" &lt;&lt; endl; &#125;&#125;class A1 :public father&#123; public: int a1; A1(int i):a1(i)&#123; cout &lt;&lt; "调用了A1的构造函数" &lt;&lt; endl; &#125; virtual ~A1()&#123; &#125; &#125;;class A2:public father&#123; public: int a2; A2(int i):a2(i)&#123; cout &lt;&lt; "调用了A2的构造函数" &lt;&lt; endl; &#125; virtual ~A2()&#123; &#125; &#125;;/*C同时继承A1和A2*/class C:public A2,public A1&#123; public: int c; C(int i):c(i),A1(i),A2(i)&#123; cout &lt;&lt; "调用了C的构造函数" &lt;&lt; endl; &#125; virtual ~C()&#123; &#125; &#125;;int main()&#123; C c(1);&#125; 实验结果： 结果分析：可以发现，在创建类C对象的时候，调用了两次father类的构造函数，也就意味着本来编译器创建了多余的无意义的父类对象，要解决它则可以使用虚继承。 多继承引发的二义性问题 产生二义性：不明确使用的变量或者函数属于哪一个类（例如上方代码中创建好的c进行调用father类中的father_num变量） 1234int main()&#123; C c(1); cout &lt;&lt; c.father_num &lt;&lt; endl;//报错，调用变量不明确&#125; 解决方案：使用作用域运算符（例如：cout &lt;&lt; c.A2::father_num &lt;&lt; endl;） 虚继承为了解决上诉父类创建多余对象可以使用虚继承进行继承，这样该父类就会成为虚基类。 虚基类(virtual base class)：无论这个类在继承体现中出现多少次，派生类中，都只包含唯一一个共享的虚基类的子内容 例如： 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243/*使用虚继承*/class A1 :virtual public father&#123; public: int a1; A1(int i):a1(i)&#123; cout &lt;&lt; "调用了A1的构造函数" &lt;&lt; endl; &#125; virtual ~A1()&#123; &#125; &#125;;/*使用虚继承*/class A2:virtual public father&#123; public: int a2; A2(int i):a2(i)&#123; cout &lt;&lt; "调用了A2的构造函数" &lt;&lt; endl; &#125; virtual ~A2()&#123; &#125; &#125;;/*C同时继承A1和A2*/class C:public A2,public A1&#123; public: int c; C(int i):c(i),A1(i),A2(i)&#123; cout &lt;&lt; "调用了C的构造函数" &lt;&lt; endl; &#125; virtual ~C()&#123; &#125; &#125;;int main()&#123; C c(1); cout &lt;&lt; c.father_num &lt;&lt; endl;//没有报错&#125; 实验结果： 结果分析：发现此时进行创建类C的对象的时候，father类的构造函数只被调用了一次，且能消除一部分调用父类的变量或者函数时的二义性。 需要注意！！：此时的继承调用构造函数顺序也会发生改变，这里会先构造出虚继承的父类，然后再按照派生列表进行调用其他函数的构造函数。 例如： 12345678910111213141516/*C同时继承A1和A2、B*//*其中A1,A2虚继承了虚基类*/class C:public B,public A2,public A1&#123; public: int c; C(int i):c(i),A1(i),A2(i)&#123; cout &lt;&lt; "调用了C的构造函数" &lt;&lt; endl; &#125; virtual ~C()&#123; &#125; &#125;;int main()&#123; C c(1); &#125; 实验结果： 结果分析：依旧先调用father的构造函数，而不会根据派生列表顺序先进行调用类B的构造函数。 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（2.9）移动构造函数、移动运算符]]></title>
    <url>%2F2019%2F09%2F02%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-9%EF%BC%89%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E7%A7%BB%E5%8A%A8%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[移动对象与移动构造函数 移动对象：移动对象与拷贝对象不同的是，移动对象更像把所有权进行转交，例如要把对象B赋值给A，通常上会进行拷贝操作，即进行：创建B对象(开辟新内存空间)，把A的内容逐一拷贝进B，再把对象A进行释放，这一系列的操作会产生临时的对象。在总体上来说进行了创建和拷贝这两步操作会使程序运行效率大大折扣，但移动对象就不同了，它进行的是转交内存的操作，即直接把A对象的相关数据内存地址直接转交给对象B从而跳过了创建对象和拷贝对象的两个操作。 移动构造函数C++11新出的移动构造函数对于拷贝构造函数来说，就是专门进行移动对象而设计的。 示例： 12345678910111213141516171819202122232425262728293031323334353637class student&#123; int ID; string name; public: student(int i,string n):ID(i),name(n)&#123; cout &lt;&lt; "调用了Student类的构造函数" &lt;&lt; endl; &#125; /*拷贝构造函数*/ student(const student&amp; temp):ID(temp.ID),name(temp.name)&#123; cout &lt;&lt; "调用了拷贝构造函数" &lt;&lt; endl; &#125; /*拷贝赋值运算符*/ student&amp; operator= (const student&amp; temp)&#123; if(&amp;temp == this) return *this; ID = temp.ID; name = temp.name; cout &lt;&lt; "使用了拷贝赋值运算符" &lt;&lt; endl; return *this; &#125; &#125;;static student getStudent()&#123; student a; return a;&#125;int main()&#123; student person = getStudent();&#125; 实验结果 结果分析：从运行结果来看。这个getStudent() 函数在进行的时候，在里面首先创建了对象&#39;a&#39;进而调用了构造函数，然后在return a这步中生成了临时对象a，把函数原有的对象a拷贝给了临时对象a，并把临时对象返回出去(因为函数体内的对象a生命期只在函数体内，所以在返回时会创建临时对象a进行返回)。 移动构造函数的使用从结果来看：这里是进行了拷贝操作，难免会出现对象创建、拷贝等影响效率的操作，但对于这里临时对象a再使用后便可不再重复利用的对象使用移动对象进行操作时比进行拷贝操作时的程序效率更高，因为进行移动操作对象就不必再创建新的对象，使用额外的内存空间去保存一次性使用的对象了。 代码： 1234/*移动构造函数*/student (student&amp;&amp; temp) noexcept :ID(temp.ID),name(temp.name)&#123; cout &lt;&lt; "调用了移动构造函数" &lt;&lt; endl;&#125; 实验结果： 结果分析：可以发现此时的临时对象则调用了移动构造函数来进行返回。 noexcept：通知编译器这里不会产生异常，任何移动对象有关的函数无论是声明还是定义都得加noexcept 提要：在getStudent()函数中是产生了临时对象才会调用拷贝构造函数，如果消除此处的临时对象则不会调用拷贝构造函数 移动赋值运算符相比拷贝赋值运算符，移动赋值运算符是专门对赋值是移动对象使用的 代码： 12345678910/*移动赋值运算符*/ student&amp; operator= (student&amp;&amp; temp)noexcept &#123; if (&amp;temp == this) return *this; ID = temp.ID; name = temp.name; cout &lt;&lt; "使用了移动赋值运算符" &lt;&lt; endl; return *this; &#125; 但在实际运用中，系统会默认使用拷贝赋值运算符进行拷贝赋值操作。 只有在特点情况下才会优先使用移动赋值运算符，在上面的getStudent()函数中，只有产生了临时对象才会调用移动构造函数，而没有产生临时对象则不会调用，说明移动对象与临时变量有充分的联系，即：对右值的变量会使用移动构造函数。 移动赋值运算符使用条件 在进行移动赋值的时候要确保原有的对象处于一种即便销毁也不再使用的情况下，则可以使用移动对象操作。(通俗点讲就是：要进行移动操作，原来的对象不能再使用)。 原对象为临时变量。即：原对象为右值时。(std::move()函数就派上用场了) 移动对象时要注意的点当类中包含指针的时 当类中包含指针成员的时候，在进行移动操作的时候要把原有的对象里的指针置零。 移动时要确保该指针断绝原对象的关系，以免在原对象释放的时候对该指针也进行释放，对移动后对象产生不可预料的危险 在进行移动赋值的时候，要先把自己对象中的指针先释放掉，再进行赋值，并把原对象的指针要置零。 实例： 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142class A&#123; int num1;public: A(int i = 0):num1(i)&#123;&#125;&#125;;class B&#123; A* temp;public: B():temp(new A())&#123; cout &lt;&lt; "调用了类B的构造函数 " &lt;&lt; endl; &#125; B(const B&amp; t):temp(t.temp)&#123; cout &lt;&lt; "调用了类B的拷贝构造函数" &lt;&lt; endl; &#125; /*拷贝赋值运算符*/ B&amp; operator=(const B&amp; t)&#123; if(this == &amp;t)return *this; cout &lt;&lt; "使用了类B的拷贝赋值运算符" &lt;&lt; endl; temp = t.temp; return *this; &#125; /*移动构造函数*/ B(B&amp;&amp; t)noexcept:temp(t.temp)&#123; t.temp = nullptr;//要把原来的指针进行置零 cout &lt;&lt; "调用了类B的移动构造函数" &lt;&lt; endl; &#125; B&amp; operator=(B&amp;&amp; t)noexcept&#123; delete temp;//移动赋值时先要释放自己原有的内存地址 temp = t.temp; t.temp = nullptr;//赋值后要把原对象的指针置零，防止在原对象释放时，该指针跟着释放 cout &lt;&lt; "使用了类B的移动赋值运算符" &lt;&lt; endl; &#125; &#125; —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率论与数理统计（二）]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[条件概率与乘法公式 条件概率： P(B|A) = P(AB) / P(A) P(A|B) = P(AB) / P(B) 乘法公式 P(AB) = P(A) - P(B|A) = P(B) - P(A|B) 全概率公式与贝叶斯公式 全概率公式： P(A) = \sum_{i=1}^nP(B_i)P(A|B_i) P(A) 要发生的事件的概率 P(Bi)为A发生的前提事件的概率 P(A|Bi)为Bi事件已经发生后的前提下，A事件发生的概率 贝叶斯公式：（逆概率公式） P(B_i|A) = \frac {P(B_i)P(A|B_i)}{P(A)}]]></content>
      <tags>
        <tag>学习总结</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率论与数理统计（一）]]></title>
    <url>%2F2019%2F08%2F28%2F%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[事件运算及概率 事件运算 包含事件 A 并事件 A∪B = A+B 差事件 A - B = ACB = A - AB 交事件 A∩B = AB 互斥事件 AB = ∅ 对立事件 A∪CA = S; ACA = ∅ 独立事件 P(AB) = P(A)P(B) 其他： A、B独立： A、CB CA、B CA、CB互相独立 A、B、C独立： A、B、C两两相互独立(充分不必要) P(ABC) = P(A)P(B)P(C) 公式： 德摩根率： C_{A∪B} = C_A · C_B C_{A∪B} = C_A∪C_B 加法公式 P(A∪B) = P(A) + P(B) - P(AB） P(A∪B∪C) = P(A) + P(B) + P(C) - P(AB) - P(AC) - P(BC) + P(ABC) 减法公式 P(A-B) = P(AC_B) = P(A) - P(AB) 对立事件 P(C_A) = 1 - P(A) 独立事件 P(AB) = P(A)·P(B)]]></content>
      <tags>
        <tag>学习总结</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（6.7）深度优先搜索(邻接矩阵)]]></title>
    <url>%2F2019%2F08%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%886-7%EF%BC%89%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[邻接矩阵的DFS(深度优先搜索)代码实现及思路 实现邻接矩阵DFS算法的前提 思路：要实现邻接矩阵的DFS算法，首先就要在邻接矩阵的结构中设置一个标记数组，用来对应顶点数组在遍历过程中的访问情况，即已经访问过的顶点将被标记已被访问，没有访问的将被标记未访问。 代码1： 1234567891011121314class MGraph&#123; .... vector&lt;bool&gt;Mark;//标记数组 &#125;;/*创建标记数组*/void create_mark()&#123; //避免重复创建+验证 if(Mark.size() != Vertex.size())return;//Vertex是顶点数组 Mark.resize(Vertex.size(),false);&#125; 遍历实现DFS 思路：根据标识数组来确定是否要访问，函数参数可以更加顶点数组来指定结点开始，并可以通过函数指针作为参数之一多样化的去遍历图 代码： 123456789101112void DFS(unsigned int ID,void(*visit)(const VT&amp; vertex))&#123; if(ID &lt; 0 || ID &gt; Mark.size())return; Mark[ID] = true; vistit(Vertex[ID]); for(int k = 0; k &lt; Vertex.size(); k++)&#123; if(Edges[ID][k] != definfo)&#123; if(!Mark[k]) DFS(k,visit); &#125; &#125;&#125; 代码解析 Mark/Vertex 1 false 2 false 3 false 4 false 邻接矩阵 A B C D A 0 1 1 1 B 1 0 1 0 C 1 1 0 1 D 1 0 1 0 第一步DFS(unsigned int ID,void(*visit)(const VT&amp; vertex)) Mark[0] = true； 输出了A Edge[0] [0]不输出，输出B,C,D 堆栈实现 思路：通过堆栈来模拟递归实现 代码： 12345678910111213141516171819202122232425262728293031void DFS2(unsigned int ID,void(*visit)(const VT&amp; vertex))&#123; if(ID &lt; 0 || ID &gt; Vertex.size())return; create_mark(); for(int i = 0; i &lt; Vertex.size(); i++)&#123; DFS_(i,visit); &#125;&#125;void DFS_(unsigned int ID,void(*visit)(const VT&amp; vertex))&#123; if(ID &lt; 0 || ID &gt; Vertex.size())return; stack&lt;int&gt; s; s.push(ID); Mark[ID] = true; while(!s.empty())&#123; auto v = s.top();s.pop(); visit(Vertex[v]); &#125; for(int w = 0; w &lt; Vertex.size(); w++)&#123; if(Edge[ID][w] != definfo)&#123; if(!Mark[w])&#123; s.push(w); Mark[w] = true; &#125; &#125; &#125; &#125; —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（6.6）图的遍历]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%886-6%EF%BC%89%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[图的遍历（图的遍历是图的基本运算） 定义：从已给的连通图中的某一个顶点出发，沿着一些边去访问遍历图中所有的顶点，且使每个顶点仅被访问一次 实质：找每个顶点的邻接点的过程 遍历算法 深度优先搜索(DFS) 类似树的先序遍历 广度优先搜索(BFS) 类似树的层次遍历 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（6.5）图的实现-邻接表]]></title>
    <url>%2F2019%2F08%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%886-5%EF%BC%89%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0-%E9%82%BB%E6%8E%A5%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[邻接表邻接表是一种顺序分配和链式分配相结合的存储结构，其顶点集由顺序表进行存储，其边则用邻接顶点来表示，而邻接点则用链式结构在顺序结构中的每一个顶点来承载，通俗点讲，就是把一堆链表用顺序表进行存储的结构。 邻接表的实现及思路邻接表的结构 思路：邻接表结构是由一个顶点结点数组，和各个邻接点组成的，其中顶点数组中含有顶点数据和指向邻接点的链域，而邻接点由邻接点域(对应顶点数组的顶点下标)和顶点所连接的其他顶点的邻接点地址。所以实现邻接表结构，首先就要有顶点数组和邻接点结构。 代码： 123456789101112131415161718192021222324252627template&lt;typename VT,typename Einfo&gt;class AGraph&#123; /*邻接点结构*/ struct Edge_Node&#123; unsigned int ID;//对应顶点数组下标 Einfo info;//保存权重 Edge_Node* next;//指向下一个邻接点的指针 Edge_Node(unsigned int id,Einfo info):ID(id),info(info),next(nullptr)&#123;&#125;; &#125;; /*顶点数组元素结构*/ struct VerTex_Node&#123; VT v_data;//顶点数据 Edge_Node* Edge; VerTex_Node(VT v):v_data(v),Edge(nullptr); &#125;; vector&lt;VerTex_Node&gt;Vertexs;//顶点数组 unsigned int Num_Edge; bool undirected; public: AGraph(bool undirected = true):undirected(undirected),Num_Edge(0)&#123;&#125;;&#125;; 添加顶点 思路：直接进行把顶点加入顶点数组即可 代码： 123void Add_VerTex(VT t)&#123; Vertexs.push_back(new VerTex_Node(t));&#125; 填加边 思路：这里要注意的时，邻接表中的邻接点是以链表结合数组进行实现的，所以在添加边的时候，要对边结点的链域进行处理，这里可以采用链表中的前插法，邻接点一个个插入顶点数组的链域之间。 代码： 1234567891011121314151617bool Add_Edges(int id1,int id2,Einfo info)&#123; Edge_Node* p = new Edge_Node(id2,info); if(!p)return false; p-&gt;next = Vertexs[id1].Edge; Vertexs[id1].Edge = p; if(undirected)&#123; Edge_Node* p = new Edge_Node(id1,info); if(!p)return false; p-&gt;next = Vertexs[id2].Edge; Vertexs[id2].Edge = p; &#125; return true;&#125; 修改边的权值 思路：这个操作的思路比较明确，更加要修改的边，通过循环遍历该起始点的顶点数组中的链域结构即可。 代码： 1234567891011121314151617void set_Edge(const int id1,const int id2,const Einfo&amp; info)&#123; Edge_Node* p = Vertexs[id1].Edge; while(p)&#123; if(p-&gt;ID == id2) p-&gt;info = info; p = p-&gt;next; &#125; if(undirected)&#123; Edge_Node* p = Vertexs[id2].Edge; while(p)&#123; if(p-&gt;ID == id1) p-&gt;info = info; p = p-&gt;next; &#125; &#125;&#125; 具体代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;template&lt;typename VT, typename Einfo&gt;class AGraph &#123; /*邻接表结构-边结点*/ struct Edge_Node &#123; unsigned int ID;//对应顶点集的下标 Einfo info;//权重 Edge_Node* next; Edge_Node(unsigned int id, Einfo info) :ID(id), info(info), next(nullptr) &#123;&#125;; &#125;; /*顶点结点结构*/ struct Vertex_Node &#123; VT v_data; Edge_Node* Edge = nullptr; Vertex_Node(VT v) :v_data(v) &#123;&#125;; &#125;; vector&lt;Vertex_Node&gt; VerTexs;//顶点集 unsigned int Num_Edge;//边数 bool undirected;public: AGraph(bool undirected = true) :undirected(undirected), Num_Edge(0) &#123;&#125;; VT operator[](int i) &#123; return VerTexs[i].v_data; &#125; void Add_VerTex(VT t) &#123; VerTexs.push_back(Vertex_Node(t)); &#125; bool Add_Edges(unsigned int id1, unsigned int id2, Einfo info) &#123; Edge_Node* p = new Edge_Node(id2, info); if (!p)return false; /*前插*/ p-&gt;next = VerTexs[id1].Edge; VerTexs[id1].Edge = p; Num_Edge++; if (undirected) &#123; Edge_Node* p = new Edge_Node(id1, info); if (!p)return false; p-&gt;next = VerTexs[id2].Edge; VerTexs[id2].Edge = p; &#125; return true; &#125; void set_Edge(const int id1, const int id2, const Einfo&amp; info) &#123; Edge_Node* p = VerTexs[id1].Edge; while (p) &#123; if (p-&gt;ID == id2) p-&gt;info = info; p = p-&gt;next; &#125; if (undirected) &#123; Edge_Node* p = VerTexs[id2].Edge; while (p) &#123; if (p-&gt;ID == id1) p-&gt;info = info; p = p-&gt;next; &#125; &#125; &#125; void Print_Agraph() &#123; for (auto&amp; e : VerTexs) &#123; cout &lt;&lt; e.v_data &lt;&lt; " "; Edge_Node* p = e.Edge; while (p) &#123; cout &lt;&lt; p-&gt;ID &lt;&lt; "," &lt;&lt; p-&gt;info &lt;&lt; " "; p = p-&gt;next; &#125; cout &lt;&lt; endl; &#125; &#125; void print() &#123; cout &lt;&lt; "顶点："; for (auto&amp; i : VerTexs) &#123; cout &lt;&lt; i.v_data &lt;&lt; " "; &#125; cout &lt;&lt; endl &lt;&lt; "邻接表:" &lt;&lt; endl; Print_Agraph(); &#125; int Get_n_vertex() &#123; return VerTexs.size(); &#125; int Get_n_edges() &#123; return Num_Edge; &#125;&#125;;int main() &#123; AGraph&lt;char, double&gt; G(false); G.Add_VerTex('A'); G.Add_VerTex('B'); G.Add_VerTex('C'); G.Add_VerTex('D'); G.Add_Edges(0, 1, 12.3); G.Add_Edges(0, 3, 9.5); G.Add_Edges(0, 2, 3.1); G.Add_Edges(1, 2, 13); G.Add_Edges(2, 3, 6); G.print(); cout &lt;&lt; "顶点数量为: " &lt;&lt; G.Get_n_vertex() &lt;&lt; endl; cout &lt;&lt; "边的数量为: " &lt;&lt; G.Get_n_edges() &lt;&lt; endl;&#125; 实验结果： —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-(2.8)临时对象处理和程序优化探讨]]></title>
    <url>%2F2019%2F08%2F17%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2-8-%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86%E5%92%8C%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E6%8E%A2%E8%AE%A8%2F</url>
    <content type="text"><![CDATA[临时对象探讨临时对象的产生在很多情况下都会出现，有临时对象的产生，说明就多调用一次构造函数，多调用一次析构函数，在程序内部消耗资源是比较大的，为对程序进行性能提升优化，首先就是要解决临时对象的问题。 产生临时对象的情况及解决办法：情况1：当对象被当做参数传入函数的时候 具体代码： 1234567891011121314151617181920212223242526272829303132333435class A&#123; int num1; int num2;public: A(int i = 0,int j = 0):num1(i),num2(j)&#123; cout &lt;&lt; "调用了类A的构造函数" &lt;&lt; endl; cout &lt;&lt; "num1= " &lt;&lt; num1 &lt;&lt; endl &lt;&lt; "num2= " &lt;&lt; num2 &lt;&lt; endl; &#125; /*类A的拷贝构造函数*/ A(const A&amp; A)&#123; cout &lt;&lt; "调用了类A的拷贝构造函数" &lt;&lt; endl; num1 = A.num1; num2 = A.num2; &#125; virtual ~A()&#123; cout &lt;&lt; "调用了类A的析构函数" &lt;&lt; endl; &#125; /*相加函数，但这是以对象为参数的类函数*/ int add(A t)&#123; int temp; temp = t.num1 + t.num2; return temp; &#125; &#125;;int main()&#123; A a; a.add();&#125; 实验结果： 结果分析： 根据实验打印情况，发现了A首先调用了构造函数，然后又调用了A的拷贝构造函数。可以发现这里出现了拷贝操作，也就意味着有临时对象的产生，并进行了对象拷贝。原因就出在int add(A t)函数上。先更加拷贝构造函数构造一个临时对象，再进行拷贝操作，并把这个临时对象进行析构。 因为在int add(A t)中，对象以参数的形式传入函数中，所以先对t这个临时对象先进行拷贝操作，也就是t = a(a为传入的对象),其次再进行相加操作并返回和。 如果对add函数进行修改 123456789101112int add(A t)&#123; int temp; temp = t.num1 + t.num2; t.num1 = 1000; return temp;&#125;int main()&#123; A a; a.add(); cout &lt;&lt; a.num1 &lt;&lt; endl;&#125; 也可以发现，在add函数中的修改，是没有影响外界的，即函数中的对象t是一个临时对象。 解决方案： 在add函数中的使用引用进行传参 123456789101112int add(A&amp;t)&#123; int temp; temp = t.num1 + t.num2; t.num1 = 1000; return temp; &#125;int main()&#123; A a; a.add(); cout &lt;&lt; a.num1 &lt;&lt; endl;&#125; 实验结果： 情况2：隐式类型转换调用构造函数的时候，会产生临时对象 具体代码： 12345678910111213141516171819202122232425262728class A&#123; int num1; int num2;public: A(int i = 0,int j = 0):num1(i),num2(j)&#123; cout &lt;&lt; "调用了类A的构造函数" &lt;&lt; endl; cout &lt;&lt; "num1= " &lt;&lt; num1 &lt;&lt; endl &lt;&lt; "num2= " &lt;&lt; num2 &lt;&lt; endl; &#125; /*类A的拷贝构造函数*/ A(const A&amp; A)&#123; cout &lt;&lt; "调用了类A的拷贝构造函数" &lt;&lt; endl; num1 = A.num1; num2 = A.num2; &#125; virtual ~A()&#123; cout &lt;&lt; "调用了类A的析构函数" &lt;&lt; endl; &#125; &#125;;int main()&#123; A a; a = 100;&#125; 实验结果： 结果分析： 可以发现，系统先调用普通构造函数生成了对象a，在进行 a = 100操作的时候，会再次调用一次构造函数，实质上，这里是先把100先隐式转换成类A的临时对象，在把这个对象赋值给原来的对象a，最后销毁这个临时对象。(注意！：这里是赋值给原来的a对象，而不是进行拷贝操作) 1234567/*如果使用拷贝赋值运算符*/A&amp; operator= (const A&amp;t)&#123; num1 = t.num1; num2 = t.num2; cout &lt;&lt; "使用了拷贝赋值运算符" &lt;&lt; endl; return *this;&#125; 解决方案： 让对象定义和初始化同句进行 123int main()&#123; A a = 100;&#125; 情况3：当函数返回值为对象时 具体代码： 123456789101112A add2(A&amp; t) &#123; A a; a.num1 = t.num1 + t.num2; return a;&#125;int main() &#123; A a = 100; add2(a); &#125; 实验结果： 结果分析：从图中可以发现，在执行返回值为对象的函数的时候，会调用一次拷贝构造函数，说明这里发生了拷贝，其中第一个构造函数的函数体外的对象的，第二个构造函数是函数体内的临时对象，除此之外还调用了一次拷贝构造函数，说明这里生成了临时对象，并把临时对象返回出去，（其中三个析构函数分别是临时对象的析构，函数体内对象的析构，函数体外对象的析构） 如果函数体外没有函数返回值的接收值，那么该返回值产生的临时对象会在函数体结束的时候立即被析构 如果有接收对象，那么会在程序结束时进行析构 解决方案： 对存在返回值为对象的函数进行优化 1234567891011/*优化前*/A add2(A&amp; t) &#123; A a; a.num1 = t.num1 + t.num2; return a;&#125;/*优化后*/A add2(A&amp; t) &#123; return A(t.num1+t.num2 , 0);&#125; 结果会只调用两次构造函数，不会调用拷贝构造函数 使用实例1234567891011121314151617181920class A&#123; int num1; int num2; public: A(int num1 = 0,int num2 = 0):num1(num1),num2(num2)&#123;&#125;;&#125;/*传参用引用，避免产生临时对象(情况1)*/A operator+(A&amp; t1,A&amp; t2)&#123; /*返回值为对象时，可以直接在返回值里调用其构造函数进行优化(情况3)*/ return A(t1.num1 + t2.num1 , t1.num2 + t2.num2);&#125;int main()&#123; A a1(100,100); A a2(200,200); /*直接在定义时初始化，防止临时对象产生，提高效率(情况2)*/ A a3 = a1 + a2;&#125; —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（6.4）图的实现-邻接矩阵]]></title>
    <url>%2F2019%2F08%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%886-4%EF%BC%89%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[邻接矩阵用一个二维数组存放顶点间关系（边或弧）的数据，这个二维数组称为邻接矩阵。邻接矩阵又分为有向图邻接矩阵和无向图邻接矩阵。该存储结构，是借助线性代数的邻接矩阵来表示图的结构。 具体实现和思路 邻接矩阵实现： 思路：邻接矩阵的实现是要借助二维数组来实现，在C++中可以使用vector来代替二维数组，从而实现矩阵。 代码： 1234567891011template&lt;typename VT,typename Einfo&gt;class MGraph&#123;vector&lt;VT&gt;VerTex;//顶点集vector&lt;vector&lt;Einfo&gt;&gt;Edge//邻接矩阵bool undirected;public:MGraph(bool undirected = true):undirecter(undirected)&#123;&#125;&#125;; 添加顶点/获得顶点总数： 思路：跟边集构建一样，使用vector进行存储顶点数据 代码： 12345678void Add_VerTex(VT vertex)&#123; VerTex.push_back(vertex);&#125;int Get_n_Vertex()&#123; return VerTex.size();&#125; 构建邻边矩阵： 思路：因为邻边矩阵是一个NXN的方形矩阵(N为顶点数量)，所以在构建邻边矩阵的时候，要先根据顶点总数来创建代表邻边矩阵的二维数组。 代码： 1234567void Create_MGraph(Einfo&amp; definfo = 0)&#123; /*用来防止多次创建邻接矩阵*/ if(VerTex.size() != Edge.size())&#123; const int N_Vertex = Get_n_Vertex(); Edge.resize(N_Vertex,vector&lt;Einfo&gt;(N_Vertex,definfo)); &#125;&#125; 添加边 思路：因为邻接矩阵是一个二维数组，所以添加边的时候直接把顶点下标当做邻接矩阵的坐标位置进行编写即可。 代码： 1234567891011void Add_Edge(const int i,const int j, const Einfo&amp;info = 1)&#123; /*要先创建邻接矩阵才能实现添加边操作*/ if(VerTex.size() != Edge.size()) Create_MGraph(); Edge[i][j] = info; if(undirected)&#123; Edge[j][i] = info; &#125;&#125; 具体代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;template&lt;typename VT, typename Einfo&gt;class MGraph &#123; vector&lt;VT&gt;Vertex;//顶点集 vector&lt;vector&lt;Einfo&gt;&gt;Edges; //邻接矩阵 unsigned int Num_Edge;//边数 bool undirected;//标记是否为无向图public: /*构造函数*/ MGraph(bool undirected = true):undirected(undirected),Num_Edge(0)&#123;&#125; /*获得顶点总数*/ int Get_n_vertex() &#123; return Vertex.size(); &#125; int Get_n_edges() &#123; return Num_Edge; &#125; void create_Mgraph(const Einfo&amp; definfo = 0) &#123; if (Edges.size() != Vertex.size()) &#123; const int n_vertex = Get_n_vertex(); Edges.resize(n_vertex, vector&lt;Einfo&gt;(n_vertex, definfo)); &#125; &#125; void Add_VerTex(VT vertex) &#123; Vertex.push_back(vertex); &#125; void Add_Edges(int i, int j, Einfo info) &#123; if (Edges.size() != Vertex.size()) create_Mgraph(); Edges[i][j] = info; Num_Edge++; if (undirected) &#123; Edges[j][i] = info; &#125; &#125; void Print_Mgraph() &#123; for (auto&amp; e : Edges) &#123; for (auto&amp; w : e) &#123; cout &lt;&lt; w &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; &#125; void print() &#123; cout &lt;&lt; "顶点："; for (auto&amp; i : Vertex) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl &lt;&lt; "邻接矩阵:" &lt;&lt; endl; Print_Mgraph(); &#125;&#125;;int main() &#123; MGraph&lt;char, double&gt; G(false); G.Add_VerTex('A'); G.Add_VerTex('B'); G.Add_VerTex('C'); G.Add_VerTex('D'); G.Add_Edges(0, 1, 12.3); G.Add_Edges(0, 3, 9.5); G.Add_Edges(0, 2, 3.1); G.Add_Edges(1, 2, 13); G.Add_Edges(2, 3, 6); G.print(); cout &lt;&lt; "顶点数量为: " &lt;&lt; G.Get_n_vertex() &lt;&lt; endl; cout &lt;&lt; "边的数量为: " &lt;&lt; G.Get_n_edges() &lt;&lt; endl; &#125; 实验结果： —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（6.3）图的实现边表]]></title>
    <url>%2F2019%2F08%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%886-3%EF%BC%89%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BE%B9%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[边表 边表是把图的顶点，和边分别用顺序表进行存储的结构 这种存储结构是最简单、最容易实现的图存储结构 缺点：如果边的数目过大，会使效率降低 代码实现及思路 边表结构 思路：因为边表是通过两个顺序表分别存储顶点集和边集的存储结构，所以在实现时可以通过创建顶点集和边集的结构，其中边集要有两个顶点在顶点集中的下标数值，和该边对应的权值。其中顺序表可以通过C++内置的vector结构实现。 代码实现： 12345678910111213141516171819202122template &lt;typename VT,typename Einfo&gt; class ElistGraph&#123; /*实现边集结构*/ struct Edge&#123; /*边两头的顶点在顶点集的下标*/ int x; int y; Einfo info;//用来存储权的数据 /*边集构造函数*/ Edge(int i,int j,Einfo info):x(i),y(j),info(info)&#123;&#125;; &#125; vector&lt;VT&gt;VerTex;//顶点集 vector&lt;Edge&gt;Edges;//边集 bool undirected;//用来标记是否为无向图 public: /*边表构造函数(默认为无向表)*/ ElistGraph(bool undirected = true):undirected(undirecter)&#123;&#125;; &#125;; 添加顶点 思路：直接通过对vector结构进行操作添加即可 代码实现： 1void add_VerTex(VT vertex)&#123;VerTex.push_back(vertex);&#125; 添加边 思路：跟添加顶点操作一致 代码实现： 1void add_Edge(const int i, const int j, const Einfo&amp; info)&#123;Edges.push_back(Edge(i,j,info));&#125; 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;/** VT 顶点数据* Einfo 边数据类型(权)*/template &lt;typename VT,typename Einfo&gt;class ElistGraph &#123; struct Edge &#123; int x; int y; Einfo info; Edge(int i, int j, Einfo inf) :x(i), y(j), info(inf) &#123;&#125;; &#125;; vector&lt;VT&gt; VerTex; vector&lt;Edge&gt; Edges; bool undirected;//判断是否为无向图public: /*默认为有向图*/ ElistGraph(bool undirected = true):undirected(undirected)&#123;&#125; /*添加顶点*/ void Add_VerTex(VT vertex) &#123; VerTex.push_back(vertex); &#125; /*添加边*/ void Add_Edges(const int i, const int j, const Einfo&amp; info) &#123; Edges.push_back(Edge(i, j ,info)); &#125; /*重载运算符*/ VT operator[](int i)&#123;return VerTex[i];&#125; VT&amp; operator[](int i) &#123; return VerTex[i]; &#125; /*获得顶点数量*/ int get_n_VT() const&#123; return VerTex.size(); &#125; /*获得边的数量*/ int get_n_e() const&#123; return Edges.size(); &#125; /*打印信息*/ void print() &#123; cout &lt;&lt; "顶点：" &lt;&lt; endl; for (auto&amp; x : VerTex) &#123; cout &lt;&lt; x &lt;&lt; " "; &#125; cout &lt;&lt; endl &lt;&lt; "边：" &lt;&lt; endl; for (auto&amp; e : Edges) &#123; cout &lt;&lt; e.x &lt;&lt; " " &lt;&lt; e.y &lt;&lt; " " &lt;&lt; e.info &lt;&lt; endl; &#125; &#125; &#125;;int main() &#123; ElistGraph&lt;char, double&gt; G(false); G.Add_VerTex('A'); G.Add_VerTex('B'); G.Add_VerTex('C'); G.Add_VerTex('D'); G.Add_Edges(0, 1, 12.3); G.Add_Edges(0, 3, 9.5); G.Add_Edges(0, 2, 3.1); G.Add_Edges(1, 2, 13); G.Add_Edges(2, 3, 6); G.print(); cout &lt;&lt; "顶点数量为: " &lt;&lt; G.get_n_VT() &lt;&lt; endl; cout &lt;&lt; "边的数量为: " &lt;&lt; G.get_n_e() &lt;&lt; endl;&#125; ​ 实验结果： —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（6.2）图的抽象数据类型]]></title>
    <url>%2F2019%2F08%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%886-2%EF%BC%89%E5%9B%BE%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[图的抽象数据类型 ADT Graph Data V是具有相同特性的数据元素的集合名称为顶点集 Relation R = {VR} VR = {|V,W∈V且P(V,W) 表示从V，W的弧，P(v,w)定义了弧的的意义} Operation createGraph(&amp;G,V,VR) 初始条件：V是图的顶点集，VR是图中边/弧的集合 操作结果：按V和VR的定义构造图G DFSTraverse(G) 初始条件：图G存在 操作结果：对图进行深度优先遍历，在遍历过程中对每个顶点访问一次 BFSTraverse(G) 初始条件：图G存在 操作结果：对图进行广度优先遍历，在遍历过程中对每个顶点访问一次 图的数据存储结构 边表 数组表示法(邻接矩阵) 邻接表 十字链表(有向图) 多重邻接表(无向图) — (本文完)]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（2.7）左值和右值、左右值引用、std::move()函数]]></title>
    <url>%2F2019%2F08%2F15%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-7%EF%BC%89%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E3%80%81%E5%B7%A6%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81std-move-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[左值和右值 左值：可以在等号左边的值，通常叫左值 特点：拥有地址，可以被修改和赋值 右值：不能在等号左边的值，通常为右值 特点：临时数据，没有地址，不能够修改和赋值 通俗点讲：左值就是地址值，而右值则是一个单纯的数据 12345int a;int b;b = 1;//此时b是一个地址值，是一个左值，也就是此时这个b代表内存地址，而1只是单纯的数据，为右值a = b;//此时的a是一个左值，而此时的b计算机认为它是一个数据，而不是b这个变量的地址值，故此时b为右值 左值引用和右值引用 左值引用： 123int a = 1;int&amp; a_t = a; int&amp; a_t = 1;//报错：左值引用不能绑定给右值 右值引用： 12int a = 1；int&amp;&amp; a_t = 1//右值引用可以绑定给右值 实质上：右值引用又是一个左值 123int a = 1;int&amp; b = a;int&amp;&amp; b_t = b;//允许 前置运算符和后置运算符 前置运算符(++i)是左值表达式 ++i 实质上，先直接给变量 i+1，然后返回 i 本身。 (++i) = 100;//允许，因为++i 是左值表达式，结果 i 的值为100 —i 同理 后置运算符(i++)是右值表达式 i++ 实质上，先把 i 赋值给一个临时变量 t ，然后再让i + 1，最后返回临时变量 t (i++) = 100//报错 i— 同理 右值引用的作用假设，有两个变量a和b，其中a要拷贝给b，那么正常情况下，b也要先创建内存空间，然后再把a的内容赋值给b。但在C++11后新引入了 &amp;&amp; 运算符，即：右值引用，在实现上述赋值操作时，由于b没有创建空间，而a却有自己的内存空间，那么可以用右值引用直接获得a空间的地址和数据，直接给b，而不是要b再创建空间去接收a的内容。 提高程序运行效率，把拷贝对象变成移动对象来提高程序运行效率 std::move函数 作用：把左值引用强转成右值，使右值引用可以绑定左值 12int a = 1;int&amp;&amp; r_a = std::move(a); 示例：1234string str1 = "ShuHao";string str2 = std::move(str1);cout &lt;&lt;"str1的值为: "&lt;&lt; str1 &lt;&lt; endl;cout &lt;&lt; "str2的值为: " &lt;&lt; str2 &lt;&lt; endl; 实验结果： 可以发现，str1经过move的处理变成了空字符串，其实在实质上，是因为string这个类中通过赋值运算符调用了，移动拷贝函数，即：str2先创建了自己的内存空间，然后把str1的内容先给str2，再把str1，的内容清空。 从两个的图可以发现，str1和srt2的内存地址是不同的，说明执行这个赋值过程中，str2是开辟了新的内存空间，在进行拷贝。 但如果使用右值引用： 可以发现：str1和str2是同一块内存地址，说明str2在执行赋值的时候没有创建新的空间，而是直接引用str1原有的空间，从而免除了str2创建新空间的步骤，提高了程序运行效率 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（6-1）图的定义及概念]]></title>
    <url>%2F2019%2F08%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%886-1%EF%BC%89%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[图 定义：图G(graph)是一些点和线的集合 图中的点叫作顶点(VerTex) 两个顶点的连线叫作边(Edges) Graph = (V,E) V：顶点(数据元素)的有穷非空集合 E：边的有穷集合 图的分类 无向图 每一条边都是没有方向的 顶点集合{A,B,C,D} 边集合{(A,B),(A,D),(C,D),(C,B),(A,C)} 有向图 每一条边有方向的，也称弧(arc) 顶点集合{A,B,C,D} 边集合{(B,A),(A,D),(B,C),(C,A)} 完全图 任意两个顶点都有一条边相连的图叫作完全图 无向完全图：如果有N个结点那么它有N(N-1)/2条边 有向完全图：如果有N个结点那么它有N(N-1)条边 网 网是边或弧带权的图 无向网 有向网 子图 1和2是3的子图 其他 如果边(V,U)∈E，则称顶点V和U互为邻接点(Adjacent) 例：A/B、B/C、C/D…互为邻接点 边(V,U)依附于(incident)顶点V和U(或边与顶点相关联) 例：边(A,B)依附于顶点A、B上 顶点V的度(Degree)是和V相关联的边的数量，记为TD(V)，对于有向图：有出度和入度 例：A的度为3、D的度为2 握手定理：边数(E) = 各顶点度数和/2 相关术语解释 路径 若从一个顶点Vi出发，沿一些边经过一些顶点，再到达顶点Vk,则称沿途的经过顶点的序列为从Vi到Vk的路径 路径的长度 路径上的边或弧的数目 回路(环) 起点与终点相同的路径 简单路径 没有重复顶点的路径，即不含回路 简单回路 除起点和终点相同外，没有其余重复顶点的路径 连通图 在无向图G中，如果从顶点V到顶点V`有路径，则称V和V’是连通的 如果对于图中的任意两个顶点Vi和Vk都是连通的，则称G是连通图 是否连通是对无向图来说的 强连通图 在有向图G中，从顶点u到顶点v有路径，且从顶点v到顶点u也有路径，则称u和v是强连通的 如果有向图的任意两个顶点u和v都是强连通，则称G是强连通图 是否强连通是对于有向图来说的 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.14.1）哈夫曼编码表的代码实现]]></title>
    <url>%2F2019%2F08%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-14-1%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E8%A1%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[哈夫曼编码表 根据构建的哈夫曼树，左分支标记为0有分支标记为1 通过二维数组保存编码表 代码实现 1234567891011121314151617181920char code[256][128] //存储哈夫曼编码表void Codeing(haffmanNode* node,char* temparray,int index)&#123; /*处理空结点的情况+递归出口*/ if(!node)return; /*当到达叶结点的时候*/ if(!node-&gt;R_Node || !node-&gt;L_Node)&#123; temparray[index] = '\0'; strcpy_s(code[node-&gt;data-0],128,temparray); return; &#125; /*递归获取编码表*/ temparray[index] = '0'; Codeing(node-&gt;L_Node,temparray,index++); temparray[index] = '1'; Codeing(node-&gt;R_Node,temparray,index++);&#125; 技术小结： temparray数组用来临时存储字符对应的哈夫曼编码，存储格式为字符串 这里采用二维数组来存储哈夫曼编码表，第一维下标为字符对于的ASCII码，所储存的为对应的编码 当到达叶结点的时候，在该位置下标的temparry设置为结束符，意味着一个字符串(字符编码)的存储完毕 编码过程解析 第一步：Codeing(haffmanNode* node,char* temparray,int index) 根据哈夫曼树构建完毕的node数组 定义char* temparray[128]；index = 0； parent4 拥有左右孩子且不空、temparray[0] = 0 第二步: Codeing(node(parent4)-&gt;L_Node,temparray,index++); index = 1 B无左右孩子执行if(!node-&gt;R_Node || !node-&gt;L_Node)，temparry[1] = ‘\0’ code[66(B)] = “0” return结束此处递归 第三步： Codeing(node(parent4)-&gt;R_Node,temparray,index++); index = 1、temparray[0] = 1 parent3 拥有左右孩子且不空执行左递归、temparry[1] = 0 第四步：Codeing(node(parent3)-&gt;L_Node,temparray,index++); index = 2 D结点没有左右孩子执行if(!node-&gt;R_Node || !node-&gt;L_Node)、temparray[2] = ‘\0’ code[68(D)] = “10” return结束此处递归 第五步：Codeing(node(parent3)-&gt;R_Node,temparray,index++)； temparry[1] = 1,index = 2 parent2拥有左右孩子且不空指向左递归、temparry[2] = 0 第六步：Codeing(node(parent2)-&gt;L_Node,temparray,index++)； index = 3 parent1拥有左右孩子且不空指向左递归、temparry[3] = 0 第七步：Codeing(node(parent1)-&gt;L_Node,temparray,index++)； index = 4 C结点没有左右孩子执行if(!node-&gt;R_Node || !node-&gt;L_Node)、temparray[4] = ‘\0’ code[67(C)] = “1100” return结束此处递归 第八步：Codeing(node(parent1)-&gt;R_Node,temparray,index++)； temparry[3] = 1，index = 4 E结点没有左右孩子执行if(!node-&gt;R_Node || !node-&gt;L_Node)、temparray[4] = ‘\0’ code[69(E)] = “1101” return结束此处递归 第九步：Codeing(node(parent2)-&gt;R_Node,temparray,index++)； temparry[2] = 1、index = 3 A结点没有左右孩子执行if(!node-&gt;R_Node || !node-&gt;L_Node)、temparray[3] = ‘\0’ code[65(A)] = “111” | code[下标] | 储存元素（编码） || :————: | :———————: || 65（A） | 111 || 66（B） | 0 || 67（C） | 1100 || 68（D） | 10 || 69（E） | 1101 | 解析过程错误小结： 函数递归时传参是形参，即index在递归时自加了。结束该分支后返回上一个函数时index值还是递归自加前的值 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.14）哈夫曼树的构建代码实现]]></title>
    <url>%2F2019%2F08%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-14%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[哈夫曼树的构建哈夫曼树的构建步骤 根据权重进行从小到大排列 取最小的两个构成一个子树,并使两个的权值相加用来代替这两个结点 根据这个新的权重再进行排列 重复1.2.3步 代码实现(顺序结构储存) 结点的构建 根据哈夫曼树的构建，结点首先要包含权值、左右子树指针，其次要包含数据 1234567891011121314struct haffmanNode&#123; int weigth;//权值 char data;//数据 haffmanNode* L_Node;//左孩子 haffmanNode* R_Node;//右孩子&#125;/*顺序结构存储二叉树*/haffmanNode node[256]；haffmanNode allL_Node[128];haffmanNode allR_Node[128]; 根据权值进行排序(冒泡排序) 12345678910111213void sortHaffmanNode(haffmanNode* nodes,int length)&#123; haffmanNode temp; for(int i = 0; i &lt; length-1; i++)&#123; for(int k = 0; k &lt; length - 1 - i; k++)&#123; if(nodes[k].weight &lt; nodes[k+1].weight)&#123; temp = nodes[k]; nodes[k] = nodes[k+1]; nodes[k+1] = temp; &#125; &#125; &#125;&#125; 哈夫曼树的构建 对结点先进行排序取最小的构成一颗树 12345678910111213141516171819202122void CreateHaffmanTree(haffmanNode* nodes, int length)&#123; if(length &lt;= 1)return;//递归出口 /*根据权值进行排序*/ sortHaffmanNode(nodes,length); /*用来压缩成哈夫曼编码用*/ allL_Node[length] = nodes[length-1];//保存左结点 allR_Node[length] = nodes[length-2];//保存右结点 /*取最小权重的两个结点重新组成树*/ haffmanNode parent; parent.weight = allL_Node[length].weight + allR_Node[length].weight; parent.L_Node = &amp;allL_Node[length]; parent.R_Node = &amp;allR_Node[length]; nodes[length - 2] = parent; //递归直至哈夫曼树创建完成 CreateHaffmanTree(nodes,length - 1);&#125; 哈夫曼树构建解析例图： 第一步：void CreateHaffmanTree(haffNode* node, int length) node数组内容{A(12),B(26),C(5),D(18),E(4)}，length = 5； 排序后 node{B,D,A,C,E},取最小结点C、E组成树 allL_Node[5] = C、allR_Node[5] = E parent1：weight = (4 + 5)9、L_Node = C、R_Node = E node 数组内容变更为{B(26),D(18),A(12),parent1(9)} 第二步：CreateHaffmanTree(node, length - 1(4)) node 数组内容{B(26),D(18),A(12),parent1(9)}，length = 4 排序后 node{B,D,A,parent1},取最小结点A、parent1组成树 allL_Node[4] = parent1、allR_Node[4] = A parent2：weight = (9+12)21、L_Node = parent1、R_Node = A\ node 数组内容变更为{B(26),D(18),parent2(21)} 第三步：CreateHaffmanTree(node, length - 1(3)) node 数组内容{B(26),D(18),parent2(21)}、length = 3 排序后 node{B,parent2,D},取最小结点parent2、D组成树 allL_Node[3] = D、allR_Node[3] = parent2 parent3：weight = (18+21)39、L_Node = D、R_Node = parent2 node 数组内容变更为{B(26),parent3(39)} 第四步：CreateHaffmanTree(node, length - 1(2)) node 数组内容{B(26),parent3(39)}、length = 2 排序后 node{parent3,B},取最小结点parent3、B组成树 allL_Node[2] = B、allR_Node[2] = parent3 parent4：weight = (26+39)65、L_Node = B、R_Node = parent3 node 数组内容变更为{parent4(65)} 第五步：CreateHaffmanTree(node, length - 1(1)) length = 1 符合if(length &lt;= 1)return;结束递归，哈夫曼树创建完毕 allL_Node 1 2 3 4 5 \ NULL B D parent1 C allR_Node 1 2 3 4 5 \ NULL parent3 parent2 A E —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.13）哈夫曼编码]]></title>
    <url>%2F2019%2F08%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-13%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[哈夫曼编码哈夫曼编码是什么？哈夫曼编码是用来压缩数据的一种手段，在网络上信息的传输都是通过二进制来进行输送的（0和1），在进行数据输送的时候，首先就要将即将输送的数据进行转码，使其变为二进制再进行传输。例如： 要传输‘ABCADBBAED’这段数据。且你知道一个二进制转换编码表： | 字符 | 编码 || :—: | :—: || A | 000 || B | 100 || C | 110 || D | 111 || E | 101 | 则这段字符串会先转换成二进制码：000100110000111100100000101111 上面的二进制转换表编码是以3位进行编码的，而用哈夫曼编码进行编译转换，则会让这段字符串传输的时候能够更为简短。 哈夫曼编码的使用哈夫曼编码是通过哈夫曼树进行转换出来的，例如在上面的字符串：‘ABCADBBAED’是出现在一个文章里面的，这个文章里面含有： 字符 出现次数 A 12 B 26 C 5 D 18 E 4 根据上表进行转换为哈夫曼树 通过对哈夫曼树处理，往左走为0往右走为1，通过记录会形成一个新的转换表 | 字符 | 编码 || :—: | :—: || A | 111 || B | 0 || C | 1100 || D | 10 || E | 1101 | 根据表中的内容把要输送的字符串‘ABCADBBAED’进行转换成二进制111011001111000111110110 对比一开始用3个编码进行转换的字符串编码会发现，哈夫曼编码进行转换处理的二进制码数为24个，比前面的少了6个，可以发现运用哈夫曼编码可以使传输的二进制码被压缩成更简单二进制码。 哈夫曼编码的好处 使转换的二进制码更简洁 哈夫曼编码是通过检测传输的字符串中字符的出现频率进行生成对应的编码表。采用的是前缀编码。 因为采用的前缀的编码，进行译码的时候减少出错 …. 译码进行译码的过程很简单，通过一开始构建的哈夫曼树，进行译码。 例如：111011001111000111110110 译码过程：从根开始遇到0就走左，遇到1就走右，当到达叶结点的时候，翻译出该字符，然后重新返回根结点重新识别 译码结果：ABCADBBAED 小结： 从上面的译码过程可以看出，对哈夫曼编码编码后的二进制码进行译码的时候只需根据编码对哈夫曼树进行遍历即可。 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.12）中序线索二叉树的遍历]]></title>
    <url>%2F2019%2F08%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-12%EF%BC%89%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[中序线索二叉树在（5.11）中的线索二叉树便为中序二叉树，因其线索化时利用的是中序遍历。所以构建的线索二叉树为中序线索二叉树。 中序线索二叉树的遍历算法通过构建的中序线索二叉树的特点。叶子结点存在直接指向前驱和后继的结点的指针，在遍历的时候就可以快速的定位。 代码： 12345678910111213141516171819void Threaded_Mid_Traversal(BiTreeNode* R)&#123; if(!R)return; while(R-&gt;L_Node)&#123; R = R-&gt;L_Node; &#125; while(R)&#123; cout &lt;&lt; R-&gt;data &lt;&lt; " "; if(!R-&gt;RTag)&#123; R = R-&gt;R_Node; while(R-&gt;LTag)&#123; R = R-&gt;L_Node; &#125; &#125;else R = R-&gt;R_Node; &#125;&#125; 实验结果： 总结：通过利用线索来进行遍历就可以避免递归或者要使用栈结构来进行遍历。 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.11）线索二叉树]]></title>
    <url>%2F2019%2F08%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-11%EF%BC%89%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[线索二叉树在构造一个二叉树的时候，我们通常会用两个指针来分别代表左孩子和右孩子，但在叶结点上这两个指针往往是空的，且不但是叶结点，在少数结点上也会存在左右孩子不存在的情况下，那么这些空的指针往往会造成资源的浪费，这就为什么要存在线索二叉树，它能使这些空掉的指针能重新运用起来。 线索二叉树的构成为了实现线索二叉树能够使空的指针能被重新利用起来，所以在结点结构定义的时候再添加两个标识符变量。这些标识符存在的目的是为了区分一个结点的左右孩子是否为空，如果是空那么就会指向前驱或者后置结点，如果不为空说明这个指针是指向左右孩子的。 从上面的图可以看出来，当右标识符为&#39;0&#39;的时候说明他的右孩子指针指向的是右孩子，当标识符为&#39;1&#39;的时候，说明这个结点的右孩子指针指向的不是右孩子(即：该结点没有右孩子)而是这个结点的前驱结点，同理，左标识符便是判断其左孩子的指针是指向后置结点还是左孩子。 二叉树线索化根据上面所说的线索二叉树，从最基本的来看，线索二叉树相比普通二叉树就是在没有左孩子或者右孩子的结点中这些本该指向左右孩子的指针不为空，使其能重新废物利用。所以把一个二叉树线索化的主要思路便是遍历一个二叉树，逐一判断每个结点的左右孩子是否为空，若为空那么就让其能指向这个结点的前驱结点或者后置结点。 综上所述，线索化的主要操作就是基于遍历算法。 12345678void Tree_Threaded(BiTreeNode* R)&#123; if(!R)return; Tree_Threaded(R -&gt; L_Node); //在此区域内实现线索二叉树的主要操作... Tree_Threaded(R -&gt; R_Node);&#125; 在开始线索化之前还需要将结点结构进行变化，即要多定义两个标识符表示用来进行判断左右孩子指针的指向。 代码： 123456789struct BiTreeNode&#123; char data; BiTreeNode* L_Node; BiTreeNode* R_Node; /*标识符变量*/ int RTag; int LTag;&#125;; 其次二叉树存在没有利用的指针，线索化后，这些空指针会指向该结点的前驱结点或者后置结点，这也就是说在线索化过程中还要有两个临时变量能够指向受判断结点的前驱结点和后置结点，方便在判断该结点在没有左右孩子的情况下，使其两个指针能够快速的指向前驱和后置结点。 线索化二叉树的代码实现 代码： 123456789101112131415void Tree_Threaded(BiTreeNode* R，BiTreeNode* &amp;pre)&#123; if(!R)return; Tree_Threaded(R -&gt; L_Node,pre); if(!R-&gt;L_Node)&#123; R-&gt;L_Node = pre; R-&gt;LTag = 1; &#125; if(pre &amp;&amp; !pre-&gt;R_Node)&#123; pre-&gt;R_Node = R; pre-&gt;RTag = 1; &#125; pre = R; Tree_Threaded(R -&gt; R_Node,pre);&#125; 二叉树线索化解析：例图： 第一次： | | A | B | C | D | E || :——: | :—: | :—: | :—: | :——-: | :—: || R_Node | | | | | || L_Node | | | | nullptr | || RTag | | | | | || LTag | | | | 0 | | pre指向D 第二次： | | A | B | C | D | E || :——: | :—: | :—: | :—: | :——-: | :—: || R_Node | | E | | B | || L_Node | | D | | nullptr | B || RTag | | 0 | | 1 | || LTag | | 0 | | 0 | 1 | pre先指向B，递归至E结点后指向E 第三次： | | A | B | C | D | E || :——: | :—: | :—: | :—: | :——-: | :—: || R_Node | C | E | | B | A || L_Node | B | D | | nullptr | B || RTag | 0 | 0 | | 1 | 1 || LTag | 0 | 0 | | 0 | 1 | pre先指向E后指向A 第四次： | | A | B | C | D | E || :——: | :—: | :—: | :——-: | :——-: | :—: || R_Node | C | E | nullptr | B | A || L_Node | B | D | A | nullptr | B || RTag | 0 | 0 | 0 | 1 | 1 || LTag | 0 | 0 | 1 | 0 | 1 | pre先指向A后指向C 线索二叉树的好处：从上面可以看出，线索二叉树的一些结点空出来的指针被重新利用起来，再到达叶子结点的时候，可以直接通过左右孩子的指针快速定位到其的前驱结点或后继结点，根据这个性质在进行遍历的时候就可以直接访问这些通过线索链接起来的结点。 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5-10）前序遍历非递归实现]]></title>
    <url>%2F2019%2F08%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-10%EF%BC%89%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前序遍历的非递归实现 思路：跟中序遍历的差不多，通过栈结构，进行排序访问输出。先从根结点开始，往下进行访问和移动，因为是堆栈所以要注意，在进行左右孩子移动的时候，应该让右孩子先入栈，左孩子后入栈，根据栈结构FIBO(先进后出)的结构特点，所以左孩子会先进行访问 代码： 12345678910111213141516bool pre_Traversal(BiTreeNode* R)&#123; stack&lt;BiTreeNode*&gt; s; BiTreeNode* T = R; s.push(T); while(!s.empty())&#123; T = s.top();s.pop(); cout &lt;&lt; T-&gt;data &lt;&lt; " "; if(T-&gt;R_Node)s.push(T-&gt;R_Node); if(T-&gt;L_Node)s.push(T-&gt;L_Node); &#125; return true;&#125;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.9.1）二叉树的遍历非递归[附加]]]></title>
    <url>%2F2019%2F07%2F31%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-9-1%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92-%E9%99%84%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[代码1:1234567891011121314151617bool Mid_Traversal(BiTreeNode* Root)&#123; stack&lt;BiTreeNode*&gt; s; BiTreeNode* T = Root; while(!s.empty()||T)&#123; if(T)&#123; T = T-&gt;L_Node; s.push(T) &#125;else&#123; T = s.top(); s.pop(); cout &lt;&lt; T-&gt;data &lt;&lt; " "; T = T-&gt;R_Node; &#125; &#125; return true; &#125; 代码2：123456789101112131415161718bool Mid_Traversal(BiTreeNode* Root)&#123; stack&lt;BiTreeNode*&gt; s; BiTreeNode* T = Root; s.push(T); while(!s.empty())&#123; while(T = s.top()) s.push(T-&gt;L_Node); T = s.top();s.pop(); if(!s.empty())&#123; T = s.top();s.pop(); if (!Visit(T))return -1; s.push(T-&gt;R_Node); &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.9）二叉树的遍历非递归]]></title>
    <url>%2F2019%2F07%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-9%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[递归的优缺点二叉树的遍历可以使用递归的方式来实现，递归调用函数思路简单，且可以让代码简洁清晰，但是递归也有其不够好的地方的。总所周知程序中函数的调用是要消耗系统内存的，在小范围小幅度的递归对程序不会有太大的影响，但是如果递归的深度太大，会使内存枯竭，程序崩溃。即：递归即有好处也有坏处 递归的优点： 代码简洁 递归的缺点： 过多递归会影响系统内存和程序运行效率 二叉树非递归的代码实现及思路正如上面所说，函数递归在遍历较小的二叉树是没有太大的问题的。但若遍历深度巨大的二叉树，使用递归来遍历是不太可行的。所以二叉树非递归的方式来实现遍历也理所当然的变的重要。 二叉树非递归遍历的实现思路：通过栈数据结构，进行入栈操作，先把树的每一个结点的左孩子入栈直至访问到叶结点，随后进行访问，访问一个出栈一个，并检测此时的右孩子是否为空，若不空，重复上述的操作即可。 代码实现: 123456789101112131415161718bool Mid_Traversal(BiTreeNode* Root)&#123; stack&lt;BiTreeNode*&gt; s; BiTreeNode* T = Root; do&#123; while(T)&#123; s.push(T); T = T-&gt;L_Node; &#125; T = s.top(); s.pop(); cout &lt;&lt; T-&gt;data &lt;&lt; " "; T = T-&gt;R_Node; &#125;while(!s.Empty()||T); return true;&#125; 实验结果: 函数流程演示 第一步：A结点不空进入循环，入栈。 | 栈顶 || :—: || A | 第二步：B结点入栈、第三次循环D结点入栈。 | 栈顶 || :—: || D || B || A | 第三步：跳出循环，T指针指向栈顶,访问栈顶数据，并出栈。 T：-&gt;D 输出了D | 栈顶 || :—: || B || A | 第四步：T重新指向此时指向结点的右孩子。第一次外循环结束。 T：-&gt;D.R_Node(nullptr) 第五步：开始第二次外循环，因为T为空内循环不执行、T指向栈顶，访问栈顶数据。 T：-&gt;B 输出了B | 栈顶 || :—: || A | 第六步：T指向了B结点的右孩子E，结束第二次外循环。 T：-&gt;E 第七步：此时T不空执行内循环，E入栈,,T指向E结点的左孩子,因为E结点的左孩子为空跳出循环。 | 栈顶 || :—: || E || A | 第八步：T指向栈顶，访问栈顶数据，出栈。 T：-&gt;E 输出了E | 栈顶 || :—: || A | 第九步：T指向E结点的右孩子，因为为空所以结束第三次外循环。 T：-&gt;E.R_Node(nullptr) 第十步：因为此时T为空不执行内循环，T指向栈顶，访问栈顶数据，出栈。 T：-&gt;A 输出了A | 栈顶 || :—: || 空 | 第十一步：T指向A结点的右孩子C，因为是空栈，所以也结束第四次外循环，重新开始下一轮循环。 T：-&gt;C 第十二步：T不为空，指向内循环，入栈，更新T指向C的左孩子，为空结束内循环。 | 栈顶 || :—: || C | 第十三步：T指向栈顶，访问栈顶，出栈 T：-&gt;C 输出了C | 栈顶 || :—: || 空 | 第十四步：T指向C结点的右孩子，但为空，且栈也为空栈，跳出外循环。结束遍历操作。 结果输出：D、B、E、A、C —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.8）哈夫曼树概念及定义]]></title>
    <url>%2F2019%2F07%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-8%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[哈夫曼树概念给定n个权作为n个结点，构造一颗二叉树，若树的带权路径长度(WPL)最短，就称其为哈夫曼树也称其为最优二叉树。 相关术语及概念解释 路径和路径长度：从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数量称为路径长度。 树的路径长度：就是树根到每一个结点的路径长度之和 带权路径长度：从根结点到该结点之间的路径长度与权的乘积 树的带权路径长度：就是树的每一个结点路径长度乘以权值之和 其中树的带权路径长度(WPL)若为最小，那么就称这个数为哈夫曼树 哈夫曼树的应用 场景设置 假设要对一个班级里的50位同学进行评分，其中人员分数分配如下 | | 优秀 | 良好 | 中等 | 及格 | 不及格 || ——- | ——- | ———— | ———— | ———— | ——— || 分值a | a&gt;=90 | 80&lt;=a&lt;90 | 70&lt;=a&lt;80 | 60&lt;=a&lt;70 | a&lt;60 || 人数 | 8 | 21 | 12 | 7 | 2 | 并把他们用下面的二叉树进行统计分类 会发现 要想把所有人进行统计完毕一共需要判断 2*1 + 2*7 + 3*12 + 4*21 + 4*8 = 168次。 如果把上面的树进行变换变为如下的二叉树 一共需要判断3*2 + 7*3 + 12*2 + 21*2 + 2*8 = 109次相比前面的二叉树发现判断的次数变少了，说明用第二种二叉树进行判断分类效率更高。 从上面可以发现，判断次数的计算类似于树的带权距离计算。所以只要保证其树的带权距离最短那么效率就会越高。 哈夫曼树的生成就以上面的的例子创建哈夫曼树 第一步：对人数进行排序(也就是对权值进行排序)从大到小的顺序分别是 | 良好 | 中等 | 优秀 | 及格 | 不及格 || —— | —— | —— | —— | ——— || 21 | 12 | 8 | 7 | 2 | 第二步：取最小的两个作为左右结点(习惯性左节点小于右节点)并让其和称为其根结点 即： 第三步：将其和加入原来的从大到小排列的顺序中替代最小的两个，重新排序 | 良好 | 中等 | 及格/不及格 | 优秀 || —— | —— | —————- | —— || 21 | 12 | 9 | 8 | 第四步：取最小的两个重复第二步操作 第五步：把左右子树的和代替原来的优秀和及格/不及格，重新排序 | 良好 | 优秀、及格/不及格 | 中等 || —— | ————————- | —— || 21 | 17 | 12 | 第六步，重复第四步操作 第七步：继续替换并重新排序 | 良好 | 优秀、及格/不及格、中等 || —— | ———————————- || 21 | 29 | 第八步：重复第四步 完成哈夫曼树 根据上图可知：要完全判断分类，需要判断21*1 + 12*2 + 8*3 + 2*4 + 7*4 = 105次比一开始109更有效率，这就哈夫曼树也称最优二叉树的创建。 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（2.6）RTTI运行时类型检测]]></title>
    <url>%2F2019%2F07%2F22%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-6%EF%BC%89RTTI%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[RTTI是什么RTTI(Run Time Type Identification)运行时类型识别，它能使程序在运行时推断出基类指针或引用实际指向的内存地址是基类还是某个派生类。 C++中RTTI提供了两个操作符 dynamic_cast typeid RTTI使用的必要条件:基类一定要包含虚函数，因为在没有虚函数的时候，类就不会创建虚函数表，导致在运行时检查的时候会获取静态的类型。即只会获得指针定义的类型而不是它指向的实际类型。 dynamic_cast运算符 作用：能将基类的指针或者引用安全地转换为派生类的指针或引用。 代码定义：dynamic_cast&lt;目标类型&gt;(目标数据) 指针转换 如果转换成功：结果会返回一个正确的指针 如果转换失败：会返回一个空指针 代码演示： 1234567891011121314151617181920212223242526272829303132class person&#123; virtual void work()&#123; cout &lt;&lt; "人们在工作" &lt;&lt; endl; &#125;&#125;;class teacher:public person&#123; void work()&#123; cout &lt;&lt; "老师在讲课" &lt;&lt; endl; &#125;&#125;;class student:public person&#123; void work()&#123; cout &lt;&lt; "学生在学习" &lt;&lt; endl; &#125;&#125;;int main()&#123; person* p1 = new teacher; person* p2 = new student; student* s1 = new student; student* s2 = dynamic_cast&lt;student* &gt;(p2);//把基类指针安全的转换为子类指针 s2-&gt;work(); teacher* t1 = dynamic_cast&lt;teacher*&gt;(p2);//转化失败返回的是空指针 if (t1 == nullptr) &#123; cout &lt;&lt; "t1是空指针" &lt;&lt; endl; &#125;&#125; 实验结果: 结论：从实例可以发现，dynamic_cast的使条件是基类含有虚函数的，且如果转换失败那么会获得一个空指针，转换成功会获得正确的指针。 如果基类中不含有虚函数那么会出错 引用转换 注意：与指针不同的是如果引用用dynamic_cast进行转换并且转换失败会抛出一个std::bad_cast异常(因为不存在空引用所以会抛出异常)可以用try catch语句进行捕获。 代码演示： 12345678910111213141516int main()&#123; person* p1 = new teacher; person* p2 = new student; person&amp; p3 = *p1; teacher&amp; t2 = dynamic_cast&lt;teacher&amp;&gt;(p3); t2.work(); try&#123; student&amp; s3 = dynamic_cast&lt;student&amp;&gt;(p3); cout &lt;&lt; "没出异常！" &lt;&lt; endl; &#125;catch(std::bad_cast)&#123; cout &lt;&lt; "出异常了！！" &lt;&lt; endl; &#125; &#125; 实验结果: typeid运算符 作用：返回指针或者引用所指向对象地址的实际类型，实际上该函数会返回一个type_info类对象。 代码定义：typeid(表达式) 代码演示: 12345678910111213141516171819202122232425class person&#123; virtual void work()&#123; cout &lt;&lt; "人们在工作" &lt;&lt; endl; &#125;&#125;;class teacher:public person&#123; void work()&#123; cout &lt;&lt; "老师在讲课" &lt;&lt; endl; &#125;&#125;;class student:public person&#123; void work()&#123; cout &lt;&lt; "学生在学习" &lt;&lt; endl; &#125;&#125;;int main()&#123; person* p1 = new teacher; person* p2 = new student; cout &lt;&lt; typeid(p1).name() &lt;&lt; endl; cout &lt;&lt; typeid(p2).name() &lt;&lt; endl;&#125; 实验结果: 发现问题:咦？为什么返回的是class person*？，答案很明显：因为p1和p2的实际类型就是person*如果: 1234567int main()&#123; person* p1 = new teacher; person* p2 = new student; cout &lt;&lt; typeid(*p1).name() &lt;&lt; endl; cout &lt;&lt; typeid(*p2).name() &lt;&lt; endl;&#125; 实验结果: 因为*p1和*p2的实际类型才是teacher和student 从上面可以发现：typeid主要目的是为了比较两个指针是否指向同一种类型的对象 例如： 1234567891011121314int main()&#123; person* p1 = new teacher; person* p2 = new student; if(typeid(p1) == typeid(p2))&#123; cout &lt;&lt; "p1和p2类型相同" &lt;&lt; endl; &#125; if(typeid(*p1) == typeid(*p2))&#123; cout &lt;&lt; "*p1和*p2类型相同" &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; "*p1和*p2类型不相同" &lt;&lt; endl; &#125;&#125; 实验结果: 补充：typeid的实质12345int main()&#123; cout &lt;&lt; typeid("ShuHao").name() &lt;&lt; endl; cout &lt;&lt; typeid(100).name() &lt;&lt; endl; cout &lt;&lt; typeid(12.345).name() &lt;&lt; endl;&#125; 实验结果: 没有虚函数的情况：1234567891011121314int main()&#123; person* p1 = new teacher; person* p2 = new student; if(typeid(p1) == typeid(p2))&#123; cout &lt;&lt; "p1和p2类型相同" &lt;&lt; endl; &#125; if(typeid(*p1) == typeid(*p2))&#123; cout &lt;&lt; "*p1和*p2类型相同" &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; "*p1和*p2类型不相同" &lt;&lt; endl; &#125;&#125; 实验结果: 可以发现 *p1和*p2此时在没有虚函数的情况下类型也相同了。原因很明显：因为没有虚函数表，会默认认为是定义时的类型也就是person* 结论：要使RTTI机制能正常的使用，基类一定要含有虚函数。 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-(2.5)友元函数、友元类]]></title>
    <url>%2F2019%2F07%2F21%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2-5-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E3%80%81%E5%8F%8B%E5%85%83%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[友元函数何为友元，众所周知一个类中private里的内容是不允许除本类的其他地方进行访问的，protected类的数据也只能由其子类去访问，而友元函数的特点就是，对一个类中的private和protected都可以进行调用和访问。 12345678910class A &#123;private: int data; &#125;;void fun1(A&amp; t) &#123; t.data = 10;//报错，不能访问private成员 &#125; 实验结果: 从上面可以发现，在正常的情况下，外面的函数是不可以访问私有成员的，但如果是友元函数便可以访问 友元函数声明： 在类中： friend 返回值类型 函数名(参数)； 1234567891011121314151617class A &#123;private: int data; friend void fun1(A&amp; t); &#125;;void fun1(A&amp; t) &#123; t.data = 10; cout &lt;&lt; "类A中的私有成员data的值为 " &lt;&lt; t.data &lt;&lt; endl; &#125;int main() &#123; A a; fun1(a);&#125; 实验结果: 友元类正如友元函数一样，友元类是可以访问朋友类中的所有成员和函数 123456789101112131415161718class A &#123;private: int data; friend void fun1(A&amp; t); friend class C;//把类C定义为A的友元类&#125;;void fun1(A&amp; t) &#123; t.data = 10; cout &lt;&lt; "类A中的私有成员data的值为 " &lt;&lt; t.data &lt;&lt; endl; &#125;class C&#123; public: void GetClassA_data(A a)&#123; cout &lt;&lt; a.data &lt;&lt; endl; &#125;//可访问A的所有成员&#125;; 实验结果: 友元成员函数定义友元类，则可以对其所有成员进行访问，在某些时候是不安全且没有必要的，所有就引入了友元成员函数，只允许外类访问其的若干个公有的成员函数。 1234567891011121314151617181920212223242526272829303132class A;class C &#123;public: void GetClassA_data(A a);//将要调用A中的私有成员，所以要设置为友元函数 void SetClassA_data(int x, A&amp; a);//没有设置为友元函数不能调用类A中私有成员 &#125;;class A &#123;private: int data = 10;public: friend void C::GetClassA_data(A a);//把C中的GetClassA_data函数设置为友元函数，使其 能调用私有成员&#125;;void C::GetClassA_data(A a) &#123;//C中的成员函数，因为是类A的友元函数可以调用其私有成员 cout &lt;&lt; a.data &lt;&lt; endl;&#125;void C::SetClassA_data(int x, A&amp; a) &#123; //a.data = x;&#125;int main() &#123; A a; C c; cout &lt;&lt; "A中的私有数据data的值为： "; c.GetClassA_data(a);&#125; 实验结果： 但如果没有把成员函数设置为友元函数，则一样不能调用其私有成员。 其次，如果某类中的成员函数是另一个类的友元成员函数，那么该函数一定要是公有的(因为另一个类才能访问该函数并把该函数设置为本类的友元函数) 总结及友元的注意事项： 注意事项： 友元函数是单向的 A是B的友元，所以可以调用B中的所有成员数据，但B不能调用A中的所有数据。 友元函数没有传递性 A是B的友元，B是C的友元，不代表A是C的友元 总结： 友元函数的优缺点很明显： 优点：只要定义了非本类的函数为友元函数，那么该函数可以调用该类所有成员数据、成员函数 缺点：破坏了封装性，降低了类的可靠性和可维护性。]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.7）二叉树遍历的衍生运用]]></title>
    <url>%2F2019%2F07%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-7%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84%E8%A1%8D%E7%94%9F%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[二叉树遍历的衍生运用例图： 递归求树的深度/高度 代码实现: 12345678int GetTreeDepth(BiTreeNode* T)&#123; if(!T)return 0;//递归出口 int l = GetTreeDepth(T-&gt;L_Node); int r = GetTreeDepth(T-&gt;R_Node); return (l &gt; r) ? (l + 1) : (r + 1);&#125; 实验结果: 实现思路: 根据树的深度的概念—树中结点的最大层次或结点的最大深度，结点的深度又为结点的祖先个数+1，所以可以通过递归，从根结点开始往左右子树进行递归操作，当左右子树某一边的深度大于另一边的时候，返回最大的另一边的深度 + 1即可。 递归求得树的总结点个数 代码实现： 12345678int AllNodeCount(BiTreeNode* T)&#123; if(!T)return 0;//递归出口 int l = AllNodeCount(T-&gt;L_Node); int r = AllNodeCount(T-&gt;R_Node); return (l + r + 1);&#125; 实验结果： 实现思路：进行递归只要某个结点不为空就返回 1，通过递归进行累加，最终根结点会得到所有子树结点数量累加值。 —（本文未完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.6）树的广度优先遍历算法]]></title>
    <url>%2F2019%2F07%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-6%EF%BC%89%E6%A0%91%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[广度优先遍历二叉树 又名：层次遍历 正如名字所描述，该遍历二叉树的方式是以层进行的，期间运用的队列的知识，通过先进先出的原理。 如上图所示：整体思路是先让根结点进队并输出其数据并出队，然后让其左子树再进队，右子树再进队，通过循环重复上述过程 具体代码： 123456789101112void Traversal(BiTreeNode* R)&#123; queue&lt;BiTreeNode*&gt; Q; Q.push(R); while(!Q.empty())&#123; BiTreeNode* T = Q.front(); cout &lt;&lt; T-&gt;data &lt;&lt; " "; Q.pop(); if (T-&gt;L_Node)Q.push(T-&gt;L_Node); if (T-&gt;R_Node)Q.push(T-&gt;R_Node); &#125;&#125; 实验结果:]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（2.4）虚函数、纯虚函数、override/final、虚析构函数]]></title>
    <url>%2F2019%2F07%2F19%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-4%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81override-final%E3%80%81%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[虚函数与纯虚函数虚函数 虚函数关键字：virtual 情形： 1234567891011121314151617181920212223242526class person&#123; public: void work()&#123; cout &lt;&lt; "人们在工作" &lt;&lt; endl; &#125;&#125;;class student:public person&#123; public: void work()&#123; cout &lt;&lt; "学生在学习" &lt;&lt; endl; &#125;&#125;;class teacher:public person&#123; public: void work()&#123; cout &lt;&lt; "老师在教学" &lt;&lt; endl; &#125;&#125;;int main()&#123; person* p = new teacher; p-&gt;work();&#125; 实验结果： 发现问题：按照逻辑一个父类指针里面存储的子类对象的地址，调用同名的work()函数应该是要调用子类的函数，但结果却是调用了父类的构造函数。 解决：根据上面所述，如果这样的话父类指针可以承载子类对象的地址的作用就没有意义了，有没有可以让父类指针根据其承载的对象地址来决定调用具体哪一个同名函数呢？答案是有的，那就是虚函数，在父类中把要定义成虚函数的成员函数声明前加virtual关键字即可使其成为虚函数。 12345678910111213141516171819202122232425262728293031class person&#123; public: virtual void work()&#123; cout &lt;&lt; "人们在工作" &lt;&lt; endl; &#125;&#125;;class student:public person&#123; public: void work()&#123; cout &lt;&lt; "学生在学习" &lt;&lt; endl; &#125;&#125;;class teacher:public person&#123; public: void work()&#123; cout &lt;&lt; "老师在教学" &lt;&lt; endl; &#125;&#125;;int main()&#123; teacher* t = new teacher; person* p = new person; student* s = new student person* ps[3]&#123;t,p,s&#125;; for(int i = 0; i &lt; 3; i++)&#123; ps[i]-&gt;work(); &#125;&#125; 在基类中把work函数设定为虚函数后，后面用父类指针类型调用该函数时会动态的绑定对象即在程序运行时会根据该指针所指向对象的类型来决定调用函数。 实验结果： 注意：当父类中的某一个函数定义为虚函数的时候，继承与其的子类的同名同参函数将默认都为虚函数，也就是说子类中的该函数前加virtual和不加都没有影响 纯虚函数 代码定义： virtual 返回值类型 函数名(参数) = 0； virtual void fun1() = 0; 注意点： ①当一个基类中含有纯虚函数时，该类被称为抽象类，不能实例化对象。 ②当一个子类继承与一个抽象类时，该子类一定要重写该抽象类的纯虚函数 override/final 关键字在C++11后引入了override和final关键字，其中override关键字的作用跟Java里的一样，就是标识出该函数是重写父类的同名函数的方便检查和辨识。而final关键字就是标识出该函数不能被重写。 代码定义：返回值类型 函数名(参数) override/final{} void fun1()override{} int fun2()final{} override 具体例子： 1234567891011121314class person &#123;public: virtual void work() &#123; cout &lt;&lt; "人们在工作" &lt;&lt; endl; &#125;&#125;;class teacher :public person &#123;public: void work(int a)override&#123;//报错：因为override关键字自动检查，重写函数错误 cout &lt;&lt; "老师在教学" &lt;&lt; endl; &#125;&#125;; final 具体例子: 1234567891011121314class person &#123;public: virtual void work() final&#123; cout &lt;&lt; "人们在工作" &lt;&lt; endl; &#125;&#125;;class teacher :public person &#123;public: void work()&#123;//报错：不能重写final关键字修饰的函数 cout &lt;&lt; "老师在教学" &lt;&lt; endl; &#125;&#125;; 虚析构函数顾名思义就是定义为虚函数的析构函数。存在继承关系的父类中的析构函数一定要定义为虚函数。为什么？让我们慢慢道来 1234567891011121314151617181920212223242526class person &#123;public: person() &#123; cout &lt;&lt; "调用了父类person的构造函数person()" &lt;&lt; endl; &#125; ~person() &#123; cout &lt;&lt; "调用了父类person的析构函数~person()" &lt;&lt; endl; &#125;&#125;;class student :public person &#123;public: student() &#123; cout &lt;&lt; "调用了子类student的构造函数student()" &lt;&lt; endl; &#125; ~student() &#123; cout &lt;&lt; "调用了子类student的析构函数~student()" &lt;&lt; endl; &#125;&#125;;int main() &#123; student s;&#125; 实验结果： 从上面可以看出，当在栈区定义子类对象，其父类和子类构造函数和析构函数都被正常的调用，但是当用父类类型的指针来存储子类对象的地址，释放空间时会发现： 1234int main()&#123; person* p_s = new student; delete p_s&#125; 实验结果： 发现问题：子类的析构函数没有被调用！这意味着子类内存地址还没有正确地被释放，这样必然会引起重大的隐患。 为什么会出现这个问题？如何解决：要解决上述的问题只需把父类的析构函数定义为虚函数，为什么这样做？正如前面介绍虚函数一样，只有虚函数才能在程序运行时动态绑定识别对象。定义为虚函数，系统会根据父类指针实际指向的地址来调用对应的函数，析构函数也是一样。所以为了避免这种隐患的出现，存在继承关系的父类的析构函数一定要定义为虚函数。 解决： —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.5）二叉树的链式实现与二叉树的先、中、后序遍历]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-5%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E3%80%81%E4%B8%AD%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树的链式实现创建链表二叉树 二叉树的链表实现有两种情况 二叉链表：一个结点带有指向左右子树的指针和一个数据 三叉链表：除了带有分别指向左右子树的两个指针外还有一个指向双亲结点的指针 现以二叉链表为例创建一个二叉树 1234567891011121314struct BiTreeNode&#123; char data; BiTreeNode* L_Node = nullptr;//指向左子树的指针 BiTreeNode* R_Node = nullptr;//指向右子树的指针&#125;int main()&#123; BiTreeNode* T = new BiTreeNode(); T-&gt;data = 'A'; T-&gt;L_Node = new BiTreeNode(); T-&gt;L_Node-&gt;data = 'B'; T-&gt;R_Node = new BiTreeNode(); T-&gt;R_Node-&gt;data = 'C'; BiTreeNode* p = T-&gt;L_Node; p-&gt;L_Node = new BiTreeNode(); p-&gt;L_Node-&gt;data = 'D'; p-&gt;R_Node = new BiTreeNode(); p-&gt;R_Node-&gt;data = 'E';&#125; 二叉树的遍历 遍历对于二叉树来说是非常重要的。遍历是数结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 二叉树的遍历分为三种 前序遍历(根-左子树-右子树) 中序遍历(左子树-根-右子树) 后序遍历(左子树-右子树-根) 前序遍历 前序遍历就是先从根开始然后递归左子树再递归右子树。 例如： 遍历的结果为： A、B、D、E、C 代码实现： 1234567void Pre_Traversal(BiTreeNode* T)&#123; if(!T)return;//如果T为空那么就结束 cout &lt;&lt; T-&gt;data;//先从根开始 Pre_Traversal(T-&gt;L_Node);//递归遍历左子树 Pre_Traversal(T-&gt;R_Node);//递归遍历右子树&#125; 实验结果： 具体递归实现解释： 中序遍历 中序遍历就是先递归左子树开始然后再到根再递归右子树。 例如： 遍历的结果为： D、B、E、A、C 代码实现： 1234567void Mid_Traversal(BiTreeNode* T)&#123; if(!T)return;//如果T为空那么就结束 Mid_Traversal(T-&gt;L_Node);//递归遍历左子树 cout &lt;&lt; T-&gt;data; Mid_Traversal(T-&gt;R_Node);//递归遍历右子树&#125; 实验结果： 后序遍历 例如： 遍历的结果为： D、E、B、C、A 代码实现： 12345678void Post_Traversal(BiTreeNode* T)&#123; if(!T)return;//如果T为空那么就结束 Post_Traversal(T-&gt;L_Node);//递归遍历左子树 Post_Traversal(T-&gt;R_Node);//递归遍历右子树 cout &lt;&lt; T-&gt;data; &#125; 实验结果： 具体文字解释： ①先从Post_Traversal(T(A))开始进入函数执行Post_Traversal(T(A)-&gt;L_Node(B)) ②在Post_Traversal(T(B))中又先执行执行Post_Traversal(T(B)-&gt;L_Node(D)) ③在执行Post_Traversal(T(D))的时候因为执行D结点中的Post_Traversal(T(D)-&gt;L_Node)为空结束递归，执行下一句Post_Traversal(T(D)-&gt;R_Node)也为空结束递归，执行cout &lt;&lt; ‘D’;到这里Post_Traversal(T(D))函数执行完毕，继续执行B结点中的Post_Traversal(T(B)-&gt;R_Node(E)) ④在执行Post_Traversal(T(E))的时候发现E的左右子树都为空，那么就只执行了cout &lt;&lt; ‘E’;返回B结点执行下一句cout &lt;&lt; ‘B’;至此Post_Traversal(T(A)-&gt;L_Node(B))已经执行完毕返回至A结点 ⑤执行A结点中的Post_Traversal(T(A)-&gt;R_Node(C))也就是执行Post_Traversal(T(C))发现C结点的左右子树也为空，那么只执行了C结点中的cout &lt;&lt; ‘C’;返回A结点的函数，到这里A结点的Post_Traversal(T(A)-&gt;R_Node(C))执行完毕，再执行下一句cout &lt;&lt; ‘A’; ⑥当cout &lt;&lt; ‘A’;执行完毕后Post_Traversal(T(A))函数结束。屏幕上输出DEBCA —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.4）二叉树的顺序储存结构]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-4%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[二叉树的抽象数据结构 ADT BinaryTree Data D是具有相同特征的数据元素的集合 Relative 若D = ∅，则R = ∅； 若D ≠ ∅，则R = {H}； root唯一 Dj∩Dk = ∅ ….. Operation createBiTree(&amp;T , defination) //构建二叉树 ……. endADT]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（2.3）拷贝构造函数、继承与访问等级、函数遮蔽]]></title>
    <url>%2F2019%2F07%2F18%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-3%EF%BC%89%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%AE%BF%E9%97%AE%E7%AD%89%E7%BA%A7%E3%80%81%E5%87%BD%E6%95%B0%E9%81%AE%E8%94%BD%2F</url>
    <content type="text"><![CDATA[拷贝构造函数拷贝构造函数是什么？ 拷贝构造函数是一个特殊的构造函数。与普通构造函数不同的是，当对象执行拷贝的时候将会自动调用拷贝构造函数。 12345678910111213class student&#123; public: student()&#123; cout &lt;&lt; " 这是student()构造函数" &lt;&lt; endl; &#125;&#125;;int main()&#123; student s1;//调用student()构造函数 student s2;//调用student()构造函数 student s3 = s2;//没有调用student()构造函数 &#125; 实验结果： 为什么s3对象被创建的时候没有调用无参的构造函数呢？原因就是s3执行了拷贝操作，调用的是默认的拷贝构造函数。 拷贝构造函数 拷贝构造函数与构造函数一样，当没有自己定义的拷贝构造函数的时候，会像构造函数一样系统自动生成一个空函数体的默认拷贝构造函数。 拷贝构造函数的形参中包含一个该类对象的引用(通常是const 修饰) student(const student&amp; T); 12345678910111213141516171819class student&#123; public: /*普通构造函数*/ student()&#123; cout &lt;&lt; " 这是student()构造函数" &lt;&lt; endl; &#125; /*拷贝构造函数*/ student(const student&amp; T)&#123; cout &lt;&lt; " 这是student()拷贝构造函数" &lt;&lt; endl; &#125;&#125;;int main()&#123; student s1;//调用student()构造函数 student s2;//调用student()构造函数 student s3 = s2;//没有调用student()构造函数 &#125; 实验结果: 继承与访问等级 三种访问权限 public：可以被任意实体所访问 protected：只允许本类或者子类的成员函数来访问 private：只允许本类的成员函数访问 三种继承访问 public、protected、private | 基类中的访问权限 | 子类继承基类的继承方式 | 子类得到的访问权限 || ———————— | ——————————— | ————————— || public | public | public || protected | public | protected || private | public | 子类无访问权限 || | | || public | protected | protected || protected | protected | protected || private | protected | 子类无访问权限 || | | || public | private | private || protected | private | private || private | private | 子类无访问权限 | 总结： 子类public继承父类不改变父类的访问权限 protected继承将父类中public成员变为子类的protected成员 private继承使得父类所有成员在子类中的访问权限变为private 父类中的private成员不受继承方式的影响，子类(其他类)永远无权访问 对于父类来讲，尤其是父类的成员函数，如果你不想让外边访问，就设置为private，如果想让子类访问则设置为protected，想公开就设置为public 函数遮蔽 当出现父类中与子类中都含有同名的函数时会出现函数遮蔽现象，即子类调用该函数时，父类的重载函数将不可见 123456789101112131415161718192021222324252627282930class student &#123;public: void fun1(int i) &#123; cout &lt;&lt; "这是父类的fun1(int i)" &lt;&lt; endl; &#125; void fun1(int i,int k) &#123; cout &lt;&lt; "这是父类的fun1(int i,int k)" &lt;&lt; endl; &#125;&#125;;class person:public student&#123;public: void fun1(int i) &#123; cout &lt;&lt; "这是子类的fun1(int i)" &lt;&lt; endl; &#125;&#125;;int main()&#123; person p1; p1.fun1(1); p1.fun(2,1)//报错&#125; 实验结果： 如何解决函数遮蔽？ 用域运算符 父类名：：函数名 12345int main()&#123; person p1; p1.student::fun1(1); p1.student::fun1(1，2);&#125; 实验结果： 用using关键字(C++11) 子类中成员函数中加using 父类名：：函数名 123456789101112131415161718class person:public student&#123;public: void fun1(int i) &#123; cout &lt;&lt; "这是子类的fun1(int i)" &lt;&lt; endl; &#125; using student::fun1;&#125;;int main()&#123; person p1; p1.fun1(1); p1.fun1(1，2);&#125; 实验结果： 可以发现此时父类的重载函数也可以使用了，但是单参的fun1()函数将被子类的遮蔽。 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.3）二叉树的性质及推导]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-3%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%E5%8F%8A%E6%8E%A8%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[二叉树的性质性质1：(层级):pencil: 在二叉树的第i层上至多有2i-1个结点。 即：下层的结点最多是上层结点的2倍 性质2：(深度):pencil: 深度为k的二叉树至多有2k-1个结点。 性质3:pencil:： 对于任何一颗二叉树，若2度的结点数有n2个，则叶子结点n0的个数比为n2+1 | 符号 | 解释 || ——————- | ————————————- || n0 | 度数为0的结点数(叶结点数) || n | 总结点数 || n1 | 度数为1的结点数 || n2 | 度数为2的结点数 || B | 分枝数 | n0 = n2+1 其他公式:mag_right:： 分枝数(B)： B = n1+2n2 B = n - 1(n为总结点数)B 推导过程（n0 = n2+1）:scroll:： 因为 B = n -1① 且 n = n0 + n1 + n2② 所以B = n0 + n1 + n2 - 1 ③所以 n0 = B - n1 - n2 + 1④ 又因为B = n1+2n2 代入④ n0 = n1 + 2n2 - n1 - n2 + 1 得n0 = n2+1 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.2）二叉树]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-2%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树(Binary Tree) 二叉树是一个连通的无环图，并且每一个顶点的度不大于3。有根二叉树还要满足根结点的度不大于2。 只有一个称为根的结点 除根外，其余结点分为不相交的子集T1和T2，分别称为T的左子树和右子树，且T1和T2本身又都是二叉树 二叉树与树： | 二叉树 | 树 || ——————————————————— | ——————————— || 至多只有两个子树 | 没有限制子树的个数上限 || 子树有左右之分，其次序不能颠倒(有序树) | 子树可有序也可以无序 || 具有递归性质 | 具有递归性质 | 二叉树的五中基本形态 空树 只有一个根结点的二叉树 只有左子树 只有右子树 完全二叉树 二叉树的优点 普通树相比二叉树代码很难实现 二叉树结构简单，规律性强 所有树都可以转为唯一对应的二叉树 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.1）树的定义及概念]]></title>
    <url>%2F2019%2F07%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-1%EF%BC%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[树概念及定义 树是一个有层级结构的数据结构 定义：树是有n（n&gt;=0）个结点组成的有限集合 如果n = 0 ，称为空树 如果n &gt; 0, 则： 有一个特点的称之为为根(root)的结点，它只有直接后继，没有直接前驱。 除根以外的其他结点划分为m(m &gt;= 0)个互不相交的有限集合，T0、T1、…、Tm-1，每个集合又是一颗树，称为根的子树。和根有直接关系的结点分别是这些子树的根。 特点：每个结点有零个或多个子结点；没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除了根结点外，每个子结点可以分为多个不相交的子树。 树结构与线性结构 线性结构：一对一 树结构：一对多 | 线性结构 | 树结构 || ———————————————— | ————————————————— || 第一个元素(无前驱) | 根结点(无前驱) || 最后一个元素(无后继) | 多个叶子结点(无后继) || 其他数据元素(一个前驱、一个后继) | 树中的其他结点(一个前驱、多个后继) | 树结构的一些术语 根：唯一没有双亲的结点，其他结点都有唯一的双亲 结点的度：一个结点含有的子树的个数称为该结点的度 树的度：树结构中，最大的结点的度称为树的度 分支结点：度数不为0的结点 叶结点：度数为0的结点 孩子结点/子结点：某个结点的子树的根 双亲结点/父节点：若一个结点含有子结点，则这个结点称为其子结点的父结点 兄弟结点：同一个双亲结点的孩子结点之间互为兄弟结点 结点的祖先：从根到该节点所经分支上的所有节点 子孙：以某节点为根的子树中任一节点都称为该节点的子孙 森林：多个数的集合 子树森林：一个结点的所有子树构成的森林 结点的深度：结点的祖先个数+1 结点的高度：从结点到其子树叶结点经过的最大边数+1，叶结点的高度为1 结点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推 树的高度：高度最大的结点的高度 树的深度：树中结点的最大层次或结点的最大深度 堂兄弟结点：双亲在同一层的节点互为堂兄弟 有序树：每个结点的子树有次序之分 无序树：每个结点的子树没有次序之分 树的类型树的抽象数据类型 ADT Tree DATA 父子关系 Operator Tree() //初始化 Tree(definition) //从输入definition中创建树 Tree(const Tree &amp; T) //复制树 Node root() // 返回根结点 int depth() //获得树的高度 int size() //获得树的结点个数 Node parent(Node p) //获得结点p的双亲 Node[] children(p) //返回结点P的所有孩子 Node[] silbings(parent , p) //返回结点p的所有兄弟 Node find() //查找结点 …… endADT —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（4.4.2）查询子串位置二-KMP算法[难点]]]></title>
    <url>%2F2019%2F07%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%884-4-2%EF%BC%89%E6%9F%A5%E8%AF%A2%E5%AD%90%E4%B8%B2%E4%BD%8D%E7%BD%AE%E4%BA%8C-KMP%E7%AE%97%E6%B3%95-%E9%9A%BE%E7%82%B9%2F</url>
    <content type="text"><![CDATA[简单(BF)算法的缺陷 简单算法的实现:pencil:：就让子串与主串进行一个个判断。 例如 “acdcda”中找“cda”那么有：①c先与主串中的‘a’比较不匹配 主串后移、②c与主串中的‘c‘匹配，子串后移让d与主串中的‘b’比较。不匹配主串后移、③c与主串中的‘d’比较，匹配子串后移、④a与主串中的‘c’比较，不匹配,主串后移、⑤c与主串中的‘d’不匹配，主串后移、⑥c与子串中的‘c’匹配,子串后移，d与主串的下一个‘d’匹配，子串再后移，a与主串中的下一个‘a’匹配。找到，返回主串中第二个‘c’的位置。 发现问题​:exclamation:：从上面可以看出，在③开始子串与已经比较过的主串字符又重新比较一次，从而大大的浪费了效率。 KMP算法 正如上面所说的，简单算法，因为在最差的情况下，会进行大量的无意义的比较匹配。而KMP算法的发明者们便想：能否更加比较不匹配所给出的信息，跳过无意义的比较呢？这就是KMP算法的核心。 —（本文未完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（4.4.1）查询子串位置算法一—简单算法]]></title>
    <url>%2F2019%2F07%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%884-4-1%EF%BC%89%E6%9F%A5%E8%AF%A2%E5%AD%90%E4%B8%B2%E4%BD%8D%E7%BD%AE%E7%AE%97%E6%B3%95%E4%B8%80%E2%80%94%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[简单(BF)算法的代码实现及思路 算法作用:mag:：查找在给定的子串在主串中的位置。例如：子串“llo”在主串“hello”的位置为3。 实现思路:bulb:：BF的算法的核心就是子串对主串逐一比较。所以只需用第一个循环来匹配子串的首字符与主串中的字符是否相等，如果相等那么在对子串后面的字符与此时主串的后面的字符进行比较。 例如：要在“AB CADB CADA BCA”中查找子串“ CADA”则从主串A中第一个开始查找，因为“A”与“ ”不匹配所以子串与主串的下一个字符比较，但也不同所以后移，当到了第三个的时候开始匹配，所以主串的第四个字符与子串第二个比较…主串第五个与子串第三个比较….。但到了主串的第七个字符与子串第4个字符不一样，所以匹配失败，主串后移一位又与子串的第一位开始比较。 具体实现:computer:: 123456789101112131415161718192021int find(String str) &#123; int j = 0; int k = 0; int n = 0; for (int i = 0; i &lt; size &amp;&amp; j &lt; str.size; i++) &#123; if (this-&gt;str[k] == str.str[j]) &#123; j++; k++; &#125; else &#123; j = 0; n++; k = n; &#125; &#125; if (j &lt;= str.size)return n; return -1; &#125; 实验结果:key:: 算法优化:wrench:： 12345678910111213141516int find(String ch)&#123; int i = 0; int j = 0; while(i &lt; size &amp;&amp; j &lt; ch.size)&#123; if(str[i] == ch.str[j])&#123; i++; j++; &#125;else&#123; i = i + 1 - j; j = 0; &#125; &#125; if(j &lt;= ch.size) return i - j; return -1; &#125; —（本文完）&lt;原创&gt; 子串对主串的逐一比较. 例如要在“AB CADB CADA BCA”中查找子串“ CADA”则从主串A中第一个开始查找，因为“A”与“ ”不匹配所以子串与主串的下一个字符比较，但也不同所以后移，当到了第三个的时候开始匹配，所以主串的第四个字符与子串第二个比较…主串第五个与子串第三个比较….。但到了主串的第七个字符与子串第4个字符不一样，所以匹配失败，主串后移一位又与子串的第一位开始比较。 &#8617;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（4.3）实现字符串结构、相关操作代码和实现思路]]></title>
    <url>%2F2019%2F07%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%884-3%EF%BC%89%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%93%E6%9E%84%E3%80%81%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E4%BB%A3%E7%A0%81%E5%92%8C%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[字符串结构的实现 具体代码:computer:： 12345678910111213141516class String&#123; char* str;//字符串 int size;//字符串长度 public: String(const char* ch)&#123; /*计算ch长度*/ char* temp = ch; while(*temp++ != '\0'); str = new char[temp - ch];//创建字符串 size = temp - ch - 1; for(int i = 0; i &lt;= size; i++)str[i] = ch[i]; &#125; .......&#125; 字符串是由字符数组来实现的,所以字符串的构造函数首先要根据const char* ch（传入的字符数组）求得其长度，然后创建足够大的空间，并对其逐一赋值即可完成String类型的创建。 相关简单操作的代码实现和实现思路 返回指定位置指定长度的子串 subString() 实现思路:exclamation:：根据用户输入指定的长度来创建足够大的空间的char* temp用来储存子串，然后用循环从指定位置开始对temp进行赋值，直到长度达到用户给定的长度即可。并在后面补上一个结束符(‘\0’),因为这是一个主串中的子串，后尾赋值的时候没有结束符。最后丢入String类型的构造函数中，释放temp的空间，返回新的字符串。 具体代码:computer:： 1234567891011121314String subString(int pos,int len)&#123; char* temp = new char[len+1]; for(int i = 0,k = pos; i &lt; len;i++,k++)&#123;//对子串进行逐一赋值 temp[i] = this-&gt;str[k]; &#125; temp[len] = '\0';//末尾补上结束符 String str(temp); delete[] temp;//释放堆空间 return str;//返回新的String&#125; 实验结果: 重载运算符+=使其实现字符串的拼接 实现思路:exclamation::拼接顾名思义，是把两个字符串连起来，所以定义一个new_size用来拼接后的字符串长度，只需分别求左右运算数的size相加即可。然后更加这个new_size长度定义一个新的字符串。之后先对左运算数，进行逐一赋值，然后在对右运算数进行赋值。即可完成拼接。 具体实现:computer:: 1234567891011121314String&amp; operator+= (const String&amp; str)&#123; int new_size = this-&gt;size + str.size; char* temp = new char[new_size+1];//最后需要一个结束符所以+1 if(!temp)return *this; int i = 0; while(i &lt; this-&gt;size)&#123;temp[i] = this-&gt;str[i]&#125;; for(int k = 0; k &lt;= str.size; k++,i++)&#123; temp[i] = str[k]; &#125; delete[]this-&gt;str; str = temp; size = new_size;&#125; 实验结果: 具体完成代码:scroll:： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;using namespace std;class String &#123;public: char* str; int size;public: /*构造函数*/ String(const char* str) &#123; const char* temp = str; while (*temp++ != '\0'); this-&gt;str = new char[temp - str]; if (!this-&gt;str)throw "内存分配失败"; size = temp - str - 1; for (int i = 0; i &lt;= size; i++)this-&gt;str[i] = str[i]; &#125; /*返回指定位置指定长度的子串*/ String subString(int pos, int len) &#123; if (pos &lt; 0 || pos &gt;= size)throw "指定位置超界"; if (pos + len &gt;= size)throw"待获取子串超界"; char* temp = new char[len + 1]; for (int i = 0, k = pos; i &lt;= len ; i++, k++) &#123; temp[i] = this-&gt;str[k]; &#125; temp[len] = '\0'; String str(temp); delete[]temp; return str; &#125; /*重载运算符+=*/ String&amp; operator+=(const String&amp; str) &#123; int new_size = this-&gt;size + str.size; char* temp = new char[new_size + 1]; if (!temp)return *this; int i = 0; while (i &lt; this-&gt;size) &#123; temp[i] = this-&gt;str[i]; i++; &#125; for (int k = 0; k &lt;= str.size; k++, i++) &#123; temp[i] = str.str[k]; &#125; delete[] this-&gt;str; this-&gt;str = temp; size = new_size; &#125; &#125;;int main() &#123; String str("hello world "); cout &lt;&lt; "原字符串为:" &lt;&lt; str.str &lt;&lt; endl; String str2 = str.subString(2, 3); cout &lt;&lt; "其位置2开始长度为3的字串为 : " &lt;&lt;str2.str &lt;&lt; endl; String str3("ShuHao"); str += str3; cout &lt;&lt; str.str &lt;&lt; endl;&#125; —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（2.2）类中的static函数/成员变量、类函数const后缀、mutable]]></title>
    <url>%2F2019%2F07%2F12%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-2%EF%BC%89%E7%B1%BB%E4%B8%AD%E7%9A%84static%E5%87%BD%E6%95%B0-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E7%B1%BB%E5%87%BD%E6%95%B0const%E5%90%8E%E7%BC%80%E3%80%81mutable%2F</url>
    <content type="text"><![CDATA[static关键字 静态关键字，无论是变量还是函数，只要加static关键字就会把其存储在静态常量区，与栈区堆区区分使用。静态，顾名思义就是不会动态变化的值。例如有一个静态变量，它会一直保持它原本的值，即便在某个函数段的生命期结束。 静态变量在普通函数 123456789101112int fun1(int a)&#123; static int b = 10;//静态变量，再重新进入函数体的时候会按照上次进入函数体的状态。 //即：静态变量只会初始化一次(默认初始化为0)。 cout &lt;&lt; "此时b的值为: " &lt;&lt; b &lt;&lt; endl; b+=a; return b;&#125;int main()&#123; cout &lt;&lt; fun1(1) &lt;&lt; endl; cout &lt;&lt; fun1(2) &lt;&lt; endl;&#125; 实验结果： 从上面的实验结果可以看出，静态变量在普通函数中只会初始化一次，假若没有给初始值，将默认初始化为0，因为静态变量是存储在静态常量区，所以即便过了在fun1函数的生命期，仍没有被回收，下次再次调用该函数时，静态变量会保存上次调用时的数据。 类中的静态变量 1234567891011//student.hclass student&#123; public： static int num;//声明 .... &#125;//student.cppint student::num = 10;//定义(定义时不需要再加static关键字) 类中的静态变量的特点： 它不是某个对象所拥有的，而是整个类拥有的，即每一个对象都共享该静态变量 在类中，静态变量只是声明因为还没有分配空间 只能在一个.cpp文件中定义并初始化类中的静态变量(分配内存)，否则会报变量重定义错误 在定义时不用再加static关键字 在定义时要用::(域运算符)标识是某个类中的变量，不然会当成普通变量定义 静态变量的体现： 12345678910student person1;person1.num = 11;cout &lt;&lt; "这是person1的num： "&lt;&lt; person1.num &lt;&lt; endl;student person2;person2.num = 12;cout &lt;&lt; "这是person2的num： "&lt;&lt; person2.num &lt;&lt; endl;cout &lt;&lt; "此时person1的num： " &lt;&lt; person1.num &lt;&lt; endl;cout &lt;&lt; "用类名来调用的num: " &lt;&lt; student::num &lt;&lt; endl; 实验结果: static成员函数 更静态变量一样，是属于类的，即调用时可以不用依靠对象来调用，直接类名::函数名来调用。 1234567891011121314151617//student.hclass student&#123; public： string name; static int num;//声明 static void setnum(int a); &#125;//student.cppint student::num = 10;//定义(定义时不需要再加static关键字)void student::setnum(int a)&#123; num = a;//修改静态变量 name = "xiaoming"//错误，因为name是属于对象的&#125; 值得注意的是，在静态函数中不能调修改非静态成员，因为非静态成员是每个对象各自有的，而不是共享的。 类中const函数后缀、mutableconst函数后缀 在类中，可以对成员函数后面添加const后缀 作用：告诫编译器，带后缀的成员函数不会修改成员变量。 具体代码: 1234567class student&#123; string name; public: void fun1() const&#123; name = "xiaoming";//报错：因为在const后缀中的函数中不允许修改成员变量 &#125;&#125; 编译后报错 : mutable mutable关键字的作用即是反制const后缀成员函数。 作用让某个成员变量可以在const后缀的成员函数中修改。 具体代码: 12345678class student&#123; mutable string name; public: void fun1() const&#123; name = "xiaoming";//编译通过 &#125;&#125; —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（4.2）实现字符串strlen和strcpy]]></title>
    <url>%2F2019%2F07%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%884-2%EF%BC%89%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2strlen%E5%92%8Cstrcpy%2F</url>
    <content type="text"><![CDATA[实现字符串中的简单操作一strlen() 作用：返回字符串的长度 实现思路：因为在c/c++中字符串是以char*指针来实现的，并且这些字符串中的末尾都有一个‘\0’结束符，所以在c/c++中可以利用指针和地址来求得字符串的长度，首先定义一个临时指针然后用待求字符串长度的字符串对其进行赋值，再用循环对这个临时指针进行自加移动，当判断在某个地址中的数据为‘\0’结束符的时候，再让其与原来的字符串相减，即可得到字符串的长度。 具体实现: 123456int strlen(const char* str)&#123; const char* temp = str; while(*temp != '\0')&#123;temp++;&#125; return temp - str;&#125; 实验结果: strcpy() 作用：进行字符串复制操作 实现思路：因为这个函数本身是实现复制操作，所以可以用原字符串对目标字符串进行逐一赋值即可实现。用一个临时指针存储目标字符串，然后用原字符串对这个临时指针进行逐一修改赋值，然后返回目标字符串即可。 具体实现: 123456char* strcpy(char* p,const char* s)&#123; char* temp = p; while((*temp++ = *s++) != 0); return p&#125; 实验结果: 错误记录：在编写strcpy()时，忘记了char*p是一个指针，结果直接运用循环对其进行自加移动赋值修改，然后再返回该指针。 错误代码: 12345char* strcpy(char* p , const char* s)&#123; while((*p++ = *s++) != 0); return p;&#125; 实验结果: 错误总结:上述错误代码中，因为p是一个指针，在循环的时候虽然是进行了逐一修改赋值，但指针也随之移动了，所以结果s不再是指向该字符串的首字符地址，而是指向了未知的末尾地址，从而造成指针p变成野指针。返回的结果也就想当然的是乱码了。 —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
        <tag>错误记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-(4.1)字符串]]></title>
    <url>%2F2019%2F07%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-4-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[(字符)串类型定义及概念串的一些概念 以(&quot;Hello world&quot;)为例 主串：即整个字符串被称为主串。 str = “Hello World”；str就是主串 子串：在主串中的一小段。(顺序相同) &quot;llo&quot;是主串“Hello World”的字串、“eH”不是该主串的字串(顺序错了) 位置：某个字符、或字符段的第一个字符位于主串的位置下标。 例如字串“llo”在主串&quot;Hello World&quot;的位置为3 串相等：当两个字符串之间，完全相同(长度相同，每个字符相同且位置相同)称为两个串相等 ”hello world“与“Hello World”不相等(字符不相等) 空串：串长度为为0的字符串被称为空串。 注意：空串与空格串不一样，空格串中的空格也算一个字符长度 串的抽象数据类型 ADT String Data：字符序列，以c/c++为例，char*类型数据，字符序列 Operation： bool init(T,char*) //初始化一个字符串 int find(S ,T) //查找字符串中是否存在字串 String strcat(T , S) //拼接字符串 String subStr(S,pos,size) //将s中的pos位置开始size长度的字串获取 bool inserStr(s,pos,T) //将T插入到s的pos位置 bool deleteStr(S,pos,size) //将S的pos位置开始的size长度的字串删除 bool copy(T,S) //将S拷贝给T int size() //获得字符串长度 void clear() //清空字符串 ……. endADT —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（2.1）类与构造函数]]></title>
    <url>%2F2019%2F07%2F08%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-1%EF%BC%89%E7%B1%BB%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[C++中的构造函数定义 在类中构造函数是在类对象创建时自动调用的，且不能主动调用构造函数，给类充当对其成员变量继续初始化的职能。 1234567891011121314151617class student&#123; int id; string name; public: student(); student(int i,string n);&#125;;student::student()&#123; cout &lt;&lt; "无参构造函数" &lt;&lt; endl;&#125;student::student(int i,string n)&#123; id = i; name = n; cout &lt;&lt; "带参构造函数 " &lt;&lt; endl;&#125; 构造函数的特点就是函数名没有返回值，函数名与类名相同，当没有定义构造函数的时候，系统会默认调用默认构造函数(函数体为空)。 在创建对象时如果是在栈区的定义方法如下： 1234567student person1(1000, "xiaoming");//最常用student person2;//调用无参构造方法student person3&#123;1021,"zhangsan"&#125;;//用大括号与小括号一样/*其余的定义方法(类堆区定义)*/student person4 = student(123, "lisi");student person5 = student(); 在创建对象的时候回调用相对应的有参或者无参的构造函数。 实验结果: 在创建对象时如果是在堆区的定义方法如下: 123student* person1 = new student(100,"xiaoming");student* person2 = new student();//student* person3 = new student;效果与person2的一样 堆区创建对象时应用指针来接收。 实验结果: 函数中的默认参数 默认参数在函数声明时就添加上。 给定默认参数的形参往右的形参都需要给与默认参数 void fun (int a , int b = 12, int c)错误 void fun (int a , int b = 12 , int c = 10)正确 含有默认参数的函数重构时需要注意参数识别混乱的问题 123456789101112int fun1(int a,int b,int c)&#123; return a+b+c;&#125;/*下方两个函数，在使用时会混乱*/int fun1(int a,int b,int c = 12)&#123; return a+b+c;&#125;int fun1(int a,int b)&#123; return a+b;&#125; 如上所示，第二个函数和第三个函数在使用时会混乱，因为你给定两个参数给函数fun1(1,2)时，不能识别你是要使用只有两个参数的函数(第三个函数),还是有默认值、三个参数的函数(第二个函数)。 类的隐式转换及explicit隐式转换 当类创建一个对象的时候若此类中有一个构造函数只含有一个参数，那么在对象创建的时候会发生隐式转换。隐式装换说白了就是没有显示表现类型转换，而是直接隐藏着进行类型转换。例如： 1234567891011121314class student&#123; int id; public: student(int i);&#125;;student::student(int i)&#123; id = i; cout &lt;&lt; "调用了student::student(int i)这个构造函数" &lt;&lt; endl; cout &lt;&lt; "id: " &lt;&lt; id;&#125;int main()&#123; student person = 100;//在没有重载运算符=的情况下，100被“赋值”给了student类的对象person&#125; 实验结果: 如上所示，本应该整型的100(int)在没有对其强制转换的情况下居然赋值给了一个student类对象，实质上这里发生了隐式转换，因为student类中含有一个只有一个参数的构造函数，当一个数字对其student类对象进行赋值的时候先调用了这个一个参数的构造函数，即先把整数转换成一个student对象再进行对象拷贝操作。 12345student person;int a = 100;person = a;/*实质上发生了如下的操作*/person = student(a);//把整型转换成对象再对其进行对象拷贝。 更奇妙的是，如果你以一个括号进行如上赋值，括号内的最后一个值将会隐式转换并调用student的单参构造函数。 123456789101112131415161718192021222324class student&#123; int id; public: student(); student(int i);&#125;;/*无参构造函数*/student::student() &#123; cout &lt;&lt; "无参构造函数" &lt;&lt; endl;&#125;/*带一个参数构造函数*/student::student(int i)&#123; id = i; cout &lt;&lt; "调用了student::student(int i)这个构造函数" &lt;&lt; endl; cout &lt;&lt; "id: " &lt;&lt; id;&#125;int main()&#123; student person; person = (100,200,300,400);//这样操作也会产生隐式转换的问题 //括号内最后一个数字(400)会进行隐式装换&#125; 实验结果: explicit关键字 为了解决上面的隐式转换的问题，可以在类中单参的构造函数声明前加explicit让其成为显示的构造函数。 12345678910111213141516171819202122class student&#123; int id; public: student(); explicit student(int i);//让隐藏的单参构造函数显现。&#125;;/*无参构造函数*/student::student() &#123; cout &lt;&lt; "无参构造函数" &lt;&lt; endl;&#125;/*带一个参数构造函数*/student::student(int i)&#123; id = i; cout &lt;&lt; "调用了student::student(int i)这个构造函数" &lt;&lt; endl; cout &lt;&lt; "id: " &lt;&lt; id;&#125;int main()&#123; student person = 100;//报错，无法找到匹配的构造函数&#125; 实验效果： 注意:只有单参构造函数的存在下才有如上所说的隐式转换的问题，所以explicit关键字只能作用于单参构造函数的声明上，在多参数构造函数声明加此关键字没有作用。 对于单参构造函数一般都需要加explicit关键字，除非某些极少例子允许隐式转换。 对应的如果要使其函数隐式调用可以加implicit 构造函数的初始化列表 先看下面一个例子 1234567891011class number&#123; int a; int b; int c; public: number(int n1,int n2,int n3);&#125;number::number(int n1,int n2,int n3):a(n1),b(n2),c(n3)&#123; &#125; 在构造函数定义后以一个冒号开头，后接成员变量+括号，括号里加要对成员变量初始化的原值，就被称为构造函数的初始化列表。 构造函数的初始化列表有以下特点 初始化列表中，成员变量的赋值是根据你定义成员变量的先后进行的。即可以不按顺序。例如： 上方先定义a,在定义b，其次是c，那么在初始化列表中对其进行初始化的时候，是先对a进行初始化其次是b，然后是c。 12345678910111213141516class number&#123; int a ; int b ; int c ; public: number(int n1,int n2,int n3);&#125;number::number(int n1,int n2,int n3):a(b),b(c),c(n3)&#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; endl;&#125;int main ()&#123; number n(100,200,300);&#125; 实验结果： 解释: 首先因为a先定义，所以先对a进行初始化，但此时b为-858993460，所以a被赋值为-858993460，其次是b，因为此时c也为-858993460，所以b也被赋值成-858993460，最后到c，成被传进的300赋值，所以现在c才为300，而前面对a,b赋值时c都还不是300。 为什么要用构造函数初始化列表来对成员变量进行赋值？ 如果是在构造函数中对成员变量赋值，那么这时程序干了两件事，首先对成员变量初始化，其次对其进行赋值操作。所以如果用初始化列表进行初始化，可以免除一步，从而提高程序效率。 高大上，帅，显得程序员专业。 —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（3.5）顺序存储结构队列]]></title>
    <url>%2F2019%2F07%2F06%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%883-5%EF%BC%89%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[顺序队列算法即实现思路顺序储存结构的队列定义(以char类型为例) 实现思路：因为顺序队列是要基于数组来实现队列的操作，所以可以定义两个数值头数值(front)和尾数值(rear)，在创建队列的时候根据capacity(队列容量)的大小创建线性表，然后让头数值和尾数值都为0代表数组下标为0的第一个数据的位置，入队时对rear进行操作移动即可实现，出队只需移动front即可完成出队。 12345678910111213class SqQueue&#123; char* datas;//线性表 int capacity;//队列容量 int front;//队首 int rear;//队尾 public: SqQueue(int c)&#123; capacity = c; datas = new char[capacity]; front = rear = 0; &#125; &#125; 顺序队列 入队操作 思路：因为顺序队列是要通过数组来实现队列的数据结构。所以可以先定义两个值分别代表尾数值和头数值，创建队列时，这头尾两个数值均为0，代表为数组第一个元素。入队时只需让下标为尾数值的数组元素进行添值即可。 具体实现： 1234567bool push(T e)&#123; if(rear == capacity) return false; datas[rear] = e; rear++; return true;&#125; 出队操作 思路：直接让头数值进行自加即可实现出队操作 具体实现： 123bool pop()&#123; front++;&#125; 出现一个问题:前面只是实现了基本的队列应该有的操作，如果对其进行出队操作，一定量的数据出队后会照成队列无法使用的情况。为此可以对顺序队列进行改造优化使它成为环状的顺序队列从而可以循环使用。 循环队列 入队操作： 思路：相比顺序队列，循环队列在入队操作时只是对尾数值进行改进使其只能在队列容量之内循环变化。即：rear = (rear+1)%capacity 算法解释：(以容量为5的队列为例) 第一步：push入队一个元素rear让其从初值0加1再取模5【(0+1)%5 = 1%5 = 1】以此类推，第二个数据入队，rear为2….第四个为4。 第二步：当到达尾数值即下标为4的时候再进行上方的运算。即【(4+1)%5 = 5%5=0】重置尾数值为0。 具体实现： 1234567bool push(T e)&#123; if((rear+1)%capacity == front)//满队判断 return false; datas[rear] = e; rear = (rear+1)%capacity; return true;&#125; 满队的处理：这里是用(rear+1)%capacity == front来作为满队判断的，即队首和队尾都只隔了1。例如：当队首为3，队尾为2为满队。因为(2+1)%5 = 3%5 = 3 出队操作 思路：与顺序队列相同，只是队头也要控制在capacity队列容量之内，即front = (front + 1)% capacity。 具体实现： 123456bool pop()&#123; if(front == rear)//空队判断 return false front = (front + 1)% capacity; return true;&#125; 具体代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt; class SqQueue &#123; T* datas; int capacity; int rear; int front;public: /*构造函数*/ SqQueue(int c = 10) &#123; capacity = c; datas = new T[capacity]; rear = front = 0; &#125; /*入队操作*/ bool push(T e) &#123; if ((rear + 1) % capacity == front) return false; datas[rear] = e; rear = (rear+1)%capacity; return true; &#125; /*出队操作*/ bool pop() &#123; if (rear == front) return false; front = (front + 1) % capacity; &#125; void tr(void(*fb)(T&amp; e)) &#123; for (int i = front; i &lt; rear; i++) &#123; fb(datas[i]); &#125; &#125;&#125;;void Print(char&amp; a) &#123; cout &lt;&lt; a &lt;&lt; " ";&#125;int main() &#123; SqQueue&lt;char&gt; s; cout &lt;&lt; "数据a入队了" &lt;&lt; endl; s.push('a'); s.tr(Print); cout &lt;&lt; endl; cout &lt;&lt; "数据b入队了" &lt;&lt; endl; s.push('b'); s.tr(Print); cout &lt;&lt; endl; cout &lt;&lt; "数据c入队了" &lt;&lt; endl; s.push('c'); s.tr(Print); cout &lt;&lt; endl; cout &lt;&lt; "数据d入队了" &lt;&lt; endl; s.push('d'); s.tr(Print); cout &lt;&lt; endl; cout &lt;&lt; "数据e入队了" &lt;&lt; endl; s.push('e'); s.tr(Print); cout &lt;&lt; endl; cout &lt;&lt; "头数据出队了 " &lt;&lt; endl; s.pop(); s.tr(Print); cout &lt;&lt; endl; cout &lt;&lt; "头数据出队了 " &lt;&lt; endl; s.pop(); s.tr(Print); cout &lt;&lt; endl; cout &lt;&lt; "头数据出队了 " &lt;&lt; endl; s.pop(); s.tr(Print); cout &lt;&lt; endl; cout &lt;&lt; "头数据出队了 " &lt;&lt; endl; s.pop(); s.tr(Print); cout &lt;&lt; endl; cout &lt;&lt; "头数据出队了 " &lt;&lt; endl; s.pop(); s.tr(Print); cout &lt;&lt; endl;&#125; 实验结果: —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-(1.7)数据类型转换]]></title>
    <url>%2F2019%2F07%2F04%2FC%2B%2B%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-(1.7)%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[C语言风格的类型转换12345678/*隐式转换*/int a = 100;double b = 2.3;cout &lt;&lt; a+b &lt;&lt;endl;//结果转换成double型/*显示转换*/double c = 2.345;cout &lt;&lt; (int)c &lt;&lt;endl;//结果转换成整型 c++的强制类型转换 C++中的强制类型装换提供它们其目的是拥有更丰富的含义和功能，更好的类型检查机制。 代码定义： 强制类型转换名&lt;type&gt;(express) type:目标数据类型 express：转换的原数据目标 static_cast静态转换 在编译时进行类型转换。 使用场合 相关类型转换：int-&gt;double 123double a = 2.345; int b = static_cast&lt;int&gt;(a); cout &lt;&lt; b; 继承关系转换：子类-&gt;父类 父类a = statci_cast&lt;父类&gt;(子类数据) 万用指针(void*)与其他类型指针之间转换 1234567int a = 100; int* a_ptr = &amp;a; void* n = a_ptr; int* temp = n;//报错：不能把万能指针转换成int* int* temp = static_cast&lt;int*&gt;(n);//允许 注意：对万能指针进行转换时要注意转换的安全性和准确性。（例：不能把string转换成double类型） 使用错误的场合 除万能指针的转换，其余指针类型之间不能相互转换 123456double a = 12123;double* a_ptr = &amp;a;int* t = static_cast&lt;int*&gt;(a_ptr);//报错，不同指针类型间不能转换double* b = static&lt;double*&gt;(a_ptr);//允许：同种类型可以转换(没有意义) dynamic_cast动态转换 在运行时进行类型识别和检查。 const_cast常量转换 编译时对数据进行指针和引用常量和变量直接的相互转换。 12345678const int a = 100; a = 200;//报错：不能修改常量的数值。 int b = const_cast&lt;int&gt;(a);//报错：const_cast只能去除指针或引用的const const int* a_ptr = &amp;a; int* b_ptr = const_cast&lt;int*&gt;(a_ptr);//允许 注意: 不要对变为变量的指针修改其里面的值。例如上方：*b_ptr = 200；//不可以，不要这样干，风险较大。 reinterpret_cast重新解释 在编译时，处理无关系类型的转换。（例如：int-&gt;int*、double*-&gt;int*) 使用场合 把整型转换成指针类型、不同类型指针之间的转换。 int-&gt;int*、double*-&gt;int* 把一个指针转换成整型。 int*-&gt;int —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（3.4）队列及链式队列的实现]]></title>
    <url>%2F2019%2F07%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%883-4%EF%BC%89%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列的基本概念及定义 定义： 队列与栈相似，相比栈的先进后出，队列是先进先出为特征的，队列的增添必须是在队列后边进行添加，删除则在前面，正与它的名字一样，队列这种数据结构跟平常时人们买票排队一样，先去排的会先买到票，后面来的只能先排着队。 特征：先进先出(FIFO,First In First Out) 队列的抽象数据类型 ADT Queue Data 线性关系(a1,a2,…,an) Operation bool push(e) 入队操作 bool pop() 出队 T&amp;front() 获得队首数据 bool empty() 判断队列是否为空 void clear() 清空队列 …….. 链式队列实现算法及思路 入队操作 思路：因为队列是先进先出的，所以要使一个指针能始终能指向新进来的元素，方便后续出队操作。所以可以先让尾指针的next指针指向这个新入队的元素，然后再让尾指针指向这个元素。 具体代码实现: 123456789101112bool push(T e)&#123; Node* p = new Node; if(!p)return false; p-&gt;data = e; p-&gt;next = nullptr; rear-&gt;next = p; rear = p; return true&#125; 出队操作 思路：先进先出，此时可以直接删除第一个数据，即头结点next指向的数据。但要记住这操作不能在队列为空的情况下使用。 具体代码实现： 1234567891011bool pop()&#123; if(rear == head) return false; Node* p = head-&gt;next; head-&gt;next = p-&gt;next; delete p; return true; &#125; 具体代码实现情况： 入队(完成) push(T e) 出队(完成) pop() 是否为空(完成) IsEmpty(); 获得队首元素(完成) getFirst() 清空队列(完成) clear() 具体代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;class Queue &#123; struct Node &#123; T data; Node* next; &#125;; Node* head; Node* rear;public: Queue() &#123; head = new Node; head-&gt;next = nullptr; rear = head; &#125; /*入队操作*/ bool push(T e) &#123; Node* p = new Node; p-&gt;data = e; p-&gt;next = nullptr; rear-&gt;next = p; rear = p; return true; &#125; /*出队操作*/ bool pop() &#123; if (head == rear) return false; Node* p = head-&gt;next; head-&gt;next = p-&gt;next; delete p; return true; &#125; /*是否为空*/ bool IsEmpty() &#123; return head == rear; &#125; /*获得首元素*/ T getFirst() &#123; return head-&gt;next; &#125; /*清空队列*/ bool clear() &#123; Node* p = head-&gt;next; Node* q = nullptr; while (p != rear) &#123; q = p; p = p-&gt;next; delete q; &#125; delete rear; rear = head; return true; &#125; void Ta(void(*fb)(T&amp; e)) &#123; Node* p = head; while (p != rear) &#123; p = p-&gt;next; fb(p-&gt;data); &#125; &#125;&#125;;template &lt;typename T&gt; void print(T&amp; e) &#123; cout &lt;&lt; e &lt;&lt; " ";&#125;int main() &#123; Queue&lt;char&gt; q; cout &lt;&lt; "a数据进队了" &lt;&lt; endl; q.push('a'); q.Ta(print); cout &lt;&lt; endl; cout &lt;&lt; "b数据进队了" &lt;&lt; endl; q.push('b'); q.Ta(print); cout &lt;&lt; endl; cout &lt;&lt; "c数据进队了" &lt;&lt; endl; q.push('c'); q.Ta(print); cout &lt;&lt; endl; cout &lt;&lt; "d数据进队了" &lt;&lt; endl; q.push('d'); q.Ta(print); cout &lt;&lt; endl; cout &lt;&lt; "清空队列" &lt;&lt; endl; q.clear(); cout &lt;&lt; "e数据进队了" &lt;&lt; endl; q.push('e'); q.Ta(print); cout &lt;&lt; endl; cout &lt;&lt; "f数据进队了" &lt;&lt; endl; q.push('f'); q.Ta(print); cout &lt;&lt; endl; cout &lt;&lt; "g数据进队了" &lt;&lt; endl; q.push('g'); q.Ta(print); cout &lt;&lt; endl; cout &lt;&lt; "h数据进队了" &lt;&lt; endl; q.push('h'); q.Ta(print); cout &lt;&lt; endl; cout &lt;&lt; "首数据出队了" &lt;&lt; endl; q.pop(); q.Ta(print); cout &lt;&lt; endl; cout &lt;&lt; "首数据出队了" &lt;&lt; endl; q.pop(); q.Ta(print); cout &lt;&lt; endl; cout &lt;&lt; "首数据出队了" &lt;&lt; endl; q.pop(); q.Ta(print); cout &lt;&lt; endl;&#125; 实验结果: —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈的应用-括号匹配]]></title>
    <url>%2F2019%2F07%2F02%2F%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8-%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[括号匹配 对一段字符串进行检查和判断括号是否匹配。例如：{（）[]{}} 匹配。即出现一个左括号就一定要一个相对应的右括号与其匹配。 实现思路：可以对一个字符串进行扫描和检查，如果是左括号那么就入栈，如果遇到一个与之匹配的右括号，那么就使其出栈。最后判断栈是否为空从而判断括号是否匹配即可。 以（{heheda}[123]())为例。 第一步扫描上方字符串。发现第一个左括号‘(’使其入栈，第二个&#39;{&#39;入栈，发现&#39;}&#39;为右括号，与栈顶数据进行匹配发现，此时栈顶就是&#39;{&#39;与之匹配那么就出栈。（类似消消乐） 具体代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include"LKStack.h"#include&lt;iostream&gt;bool CheckStr(string str) &#123; LkStack&lt;char&gt; stack; cout &lt;&lt; "字符串：" &lt;&lt; str &lt;&lt; " "; for (int i = 0; i &lt; str.length(); i++) &#123; /*如果是左括号那么就入栈，等待匹配*/ if (str[i] == '[' || str[i] == '&#123;' || str[i] == '(') &#123; stack.push_back(str[i]); &#125; /*如果是右括号那么就对栈顶数据进行判断，如果匹配那么就使此时的栈顶数据出栈*/ if (str[i] == ']' || str[i] == '&#125;' || str[i] == ')') &#123; /*排除只出现右括号没出现左括号的情况，和多出有右括号的情况*/ if (stack.isEmpty()) &#123; cout &lt;&lt; "括号不匹配！" &lt;&lt; endl; return false; &#125; if (!stack.isEmpty() &amp;&amp; str[i] == ']' &amp;&amp; stack.GetTop() == '[') stack.pop(); if (!stack.isEmpty() &amp;&amp; str[i] == '&#125;' &amp;&amp; stack.GetTop() == '&#123;') stack.pop(); if (!stack.isEmpty()&amp;&amp; str[i] == ')' &amp;&amp; stack.GetTop() == '(') stack.pop(); &#125;&#125; /*如果空栈那么就说明左括号全部匹配完毕，括号匹配成功，反之括号不匹配*/ if (stack.isEmpty()) &#123; cout &lt;&lt; "括号匹配成功！" &lt;&lt; endl; return true; &#125; else &#123; cout &lt;&lt; "括号不匹配！" &lt;&lt; endl; return false; &#125; &#125;int main() &#123; CheckStr("12312()()[]&#123;&#123;&#125;&#125; "); CheckStr("&#125;"); CheckStr("[()(),hello&#123;&#125;]"); CheckStr("test"); CheckStr("()(&#125;[]");&#125; 实验结果： —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法性能分析]]></title>
    <url>%2F2019%2F07%2F02%2F%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[算法性能分析好的算法应当满足 正确性：算法应能满足具体问题的需求 可读性：算法应应易于阅读和理解 健壮性：输入数据非法时，算法也能适当作出反应或进行处理 高效性：算法执行时间短，占用存储空间少 时间复杂度 程序：算法在计算机上的实现 程序的执行时间取决于如下因素： 算法本身 问题规模 编程语言 硬件性能 选择一个“基本操作”，分析基本操作执行的次数 用该基本操作的重复次数表示算法的执行时间，一般为问题规模n的函数f(n)，简称“频度”。 算法的时间复杂度为：和f(n)同阶的简化无穷大量T(n) = O(f(n))]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表应用- 两数相加]]></title>
    <url>%2F2019%2F06%2F29%2F%E9%93%BE%E8%A1%A8%E5%BA%94%E7%94%A8-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[两数相加 问题： 给定两个非空链表来表示两个非负整数。位数按照逆序方式储存，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。你可以假设除了数字0之外，这两个数字都不会以零开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出: 7 -&gt; 0 -&gt; 8 原因: 342 + 465 = 807 一些算法的思路： 先把一个数字转换为一个链表 243 转换为 2 -&gt; 4 -&gt; 3 所以先用一个 将数字转换为链表的函数 12345678Lklist ToLKlist(int r) &#123; Lklist stack; while (r) &#123; stack.push(r % 10); r /= 10; &#125; return stack;&#125; 实现思路：对进来的数字，直接模10取个位，然后后插入一个链表中，然后取十位……以此类推直到把所以值都后插入链表中。 转换数字后就会得到两个链表。然后进行相加。相加时得实现把链表转换成数字，例如 2 -&gt; 4 -&gt; 3转换成数字342。 123456789101112int number(Lklist num) &#123; int result = 0; int len = num.Getlength(); int i = 1; while (!num.IsEmpty()) &#123; result += num.getfirst() * i; num.deletefirst(); i *= 10; &#125; return result;&#125; 实现思路：因为获得的数字链表是2 -&gt; 4 -&gt; 3，而实际对应的数字是342，所以可以先把第一个个位数字获得，加上十位，百位。 最后一步把相加的结果再ToLKlist()用变为链表。 具体实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;iostream&gt;using namespace std;class Lklist &#123; struct LNode &#123; int data; LNode* next; &#125;; LNode* head; int length;public: Lklist() &#123; head = new LNode; head-&gt;next = nullptr; length = 0; &#125; /*前插操作*/ bool push(int e) &#123; LNode* p = new LNode; if (!p)return false; p-&gt;data = e; p-&gt;next = head-&gt;next; head-&gt;next = p; length++; return true; &#125; /*后插操作*/ bool push_back(int e) &#123; LNode* p = head; LNode* q = new LNode(); int j = 0; while (p-&gt;next) &#123; p = p-&gt;next; &#125; if (!p)return false; q-&gt;data = e; q-&gt;next = 0; p-&gt;next = q; length++; return true; &#125; /*删除第一个数据操作*/ bool deletefirst() &#123; if (!head-&gt;next) return false; LNode* p = head-&gt;next-&gt;next; delete head-&gt;next; head-&gt;next = p; length--; return true; &#125; /*获得第一个元素*/ int getfirst() &#123; return head-&gt;next-&gt;data; &#125; /*判断是否为空链表*/ bool IsEmpty() &#123; return head-&gt;next == nullptr; &#125; /*获得链表长度*/ int Getlength() &#123; return length; &#125;&#125;;/*转换为数字*/int number(Lklist num) &#123; int result = 0; int len = num.Getlength(); int i = 1; while (!num.IsEmpty()) &#123; result += num.getfirst() * i; num.deletefirst(); i *= 10; &#125; return result;&#125;/*数字转换为链表*/Lklist ToLKlist(int r) &#123; Lklist stack; while (r) &#123; stack.push(r % 10); r /= 10; &#125; return stack;&#125;/*两数相加核心代码*/Lklist TwoNumberAdd(Lklist num1, Lklist num2) &#123; int a = number(num1); int b = number(num2); return ToLKlist(a + b);&#125;int main() &#123; int a; int b; Lklist s; cout &lt;&lt; "请输入第一个数： "; cin &gt;&gt; a; cout &lt;&lt; endl &lt;&lt; "请输入第二个数： "; cin &gt;&gt; b; s = TwoNumberAdd(ToLKlist(a), ToLKlist(b)); int i = 0; int len = s.Getlength(); while (!s.IsEmpty()) &#123; cout &lt;&lt; s.getfirst(); if (i &lt; len - 1) &#123; cout &lt;&lt; "-&gt;"; i++; &#125; s.deletefirst(); &#125;&#125; 实验结果: 标准参考答案：1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public : ListNode* addTwoNumber(ListNode* l1, ListNode* l2) &#123; int x = 0; int y = 0; int carry = 0; int sum = 0; ListNode* h = nullptr; ListNode** t = &amp;h; while (l1!=nullptr||l2!=nullptr) &#123; x = getValueAndMoveNext(l1); y = getValueAndMoveNext(l2); sum = carry + x + y; ListNode* node = new ListNode(sum % 10); *t = node; t = (&amp;node-&gt;next); carry = sum / 10; &#125; if (carry &gt; 0) &#123; ListNode* node = new ListNode(carry % 10); *t = node; &#125; return h;&#125;private: int getValueAndMoveNext(ListNode*&amp; l) &#123; int x = 0; if (l != nullptr) &#123; x = l-&gt;val; l = l-&gt;next; &#125; return x; &#125;&#125;; 参考答案的核心算法思路： ListNode* addTwoNumber(ListNode* l1, ListNode* l2) 这步先把两个链表的第一个元素取出存入X和Y中，然后让其想加并加上一个进位carry数。以(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)为例。 第一步： 取出两个链表中的第一个元素2和5。 第二步： 让其相加并加上一个进位数即sum = carry(此时为0) + 2 + 5 = 7 第三步： 把结果7模上10并push_back进结果链表。此时结果为7并且是结果链表的第一个数据 然后重置进位carry即：carry = sum / 10,因为2 + 5 = 7小于10所以不用进位。 第四步： 循环上面的步骤 第二次循环中4和6的和是10，模上10取余后的结果为0，push_back进结果链表作为第二个数据 因为10是大于等于10的，所以要进位，故进行carry = sum / 10时，carry结果会为1作为下一次循环，sum = carry + x + y中的进位 总体来看，首先因为题目描述为 位数按照逆序方式储存，所以这里运用了普通加法运算。即：从个位开始相加，满10进1至下位的思路。 个人实现代码优化后：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;iostream&gt;using namespace std;class LKlist &#123;public: struct LNode &#123; int data; LNode* next; &#125;; LNode* head; int length;public: LKlist() &#123; head = new LNode(); head-&gt;next = nullptr; length = 0; &#125; bool push_back(int e) &#123; LNode* p = new LNode; LNode* t = head; p-&gt;data = e; while (t-&gt;next) &#123; t = t-&gt;next; &#125; t-&gt;next = p; p-&gt;next = nullptr; length++; return true; &#125; bool IsEmpty() &#123; return head-&gt;next == nullptr; &#125; bool deletefirst() &#123; if (!head-&gt;next) return false; LNode* p = head-&gt;next-&gt;next; delete head-&gt;next; head-&gt;next = p; length--; return true; &#125; int getfirst() &#123; return head-&gt;next-&gt;data; &#125; int Getlength()&#123; return length; &#125;&#125;;int getValueAndMoveNext(LKlist&amp; l) &#123; int x = 0; LKlist::LNode* T; if (l.head-&gt;next) &#123; x = l.head-&gt;next-&gt;data; T = l.head-&gt;next-&gt;next; delete l.head-&gt;next; l.head-&gt;next = T; &#125; return x;&#125;LKlist addTwoNumber(LKlist&amp; l1, LKlist&amp; l2) &#123; int x = 0; int y = 0; int sum = 0; int carry = 0; LKlist h; while (!l1.IsEmpty() || !l2.IsEmpty()) &#123; x = getValueAndMoveNext(l1); y = getValueAndMoveNext(l2); sum = carry + x + y; h.push_back(sum % 10); carry = sum / 10; &#125; if (carry &gt; 0) &#123; h.push_back(carry % 10); &#125; return h;&#125; 实验结果: —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈的应用-进制的转换]]></title>
    <url>%2F2019%2F06%2F29%2F%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8-%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[数制转换 以十进制转八进制为例，十进制转八进制的时候是把十进制模8取其余数直至除尽，最终结果为余数从下到上的数。 例如： 结合数据结构栈，可以发现转换最终结果跟栈的出栈一样，所以用栈来实现十进制的转换就较为方便 123456789101112void changeNumber(int n,int b)&#123;//n为十进制数，b为将要转的进制数 Stack&lt;int&gt; stack；//定义一个栈 while(n)&#123; stack.push(n%b);//获取余数并入栈 n = n/b;//更新n &#125; while(!stack.isEmpty())&#123;//出栈并输出。直至为空栈 cout &lt;&lt; stack.getTop();//获得栈顶元素 stack.pop();//每输出一个就出栈一个数据 &#125; &#125; 代码实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;using namespace std;/***********链栈实现************/template&lt;typename T&gt;class Stack &#123; struct LNode &#123; T data; LNode* next; &#125;; LNode* head;public: Stack() &#123; head = new LNode; head-&gt;next = nullptr; &#125; /*入栈操作*/ bool push(T e) &#123; LNode* p = new LNode; if (!p)return false; p-&gt;data = e; p-&gt;next = head-&gt;next; head-&gt;next = p; return true; &#125; /*出栈操作*/ bool pop() &#123; if (!head-&gt;next) return false; LNode* p = head-&gt;next-&gt;next; delete head-&gt;next; head-&gt;next = p; return true; &#125; /*获得栈顶元素*/ T getTop() &#123; return head-&gt;next-&gt;data; &#125; /*判断是否为空栈*/ bool IsEmpty() &#123; return head-&gt;next == nullptr; &#125;&#125;;/*********************************//*数据转换*/void ChangeNumber(int n,int b) &#123; Stack&lt;int&gt; stack; int result = 0; while (n) &#123; stack.push(n % b); n = n / b; &#125; while (!stack.IsEmpty()) &#123; cout &lt;&lt; stack.getTop(); stack.pop(); &#125; &#125;int main() &#123; ChangeNumber(75, 8);&#125; 实验结果: —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ vector容器常用操作和内存释放]]></title>
    <url>%2F2019%2F06%2F29%2FC-vector%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%2F</url>
    <content type="text"><![CDATA[一、对字符串的处理 对字符串每一个字符进行遍历修改操作 12345678910111213141516#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int main() &#123; string ifo = "ShuHaoHwang"; for (auto iter = ifo.begin(); iter != ifo.end(); iter++) &#123; *iter = toupper(*iter); &#125; cout &lt;&lt; ifo &lt;&lt; endl;&#125; 二、查找配置项信息及内存释放 用迭代器及vector容器实现通过一个配置项名就能查询获得相应配置项的信息，最后利用vector进行内存释放。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;struct conf&#123; char confname[40];//配置项名 char confid[100];//配置项信息&#125;;char* getifo(vector&lt;conf*&gt;&amp; a, const char* s) &#123; vector&lt;conf*&gt;::iterator iter; for (iter = a.begin(); iter != a.end(); iter++) &#123; if (strcmp((*iter)-&gt;confname, s) == 0) &#123;//如果找到对应配置项名，就返回其配置项的信息 return (*iter)-&gt;confid; &#125; &#125; return nullptr;&#125;int main() &#123; conf* server = new conf; conf* server2 = new conf; /*配置项名1*/ strcpy_s(server-&gt;confname,sizeof(server-&gt;confname),"ServerName"); /*配置信息1*/ strcpy_s(server-&gt;confid, sizeof(server-&gt;confid), "1区"); /*配置项名2*/ strcpy_s(server2-&gt;confname, sizeof(server2-&gt;confname), "ServerID"); /*配置信息2*/ strcpy_s(server2-&gt;confid, sizeof(server2-&gt;confid), "10000"); vector&lt;conf*&gt; cinfo; cinfo.push_back(server);//把结构指针放入容器 cinfo.push_back(server2); vector&lt;conf*&gt;::iterator iter; /*查找信息*/ char* temp; temp = getifo(cinfo, "ServerName"); if (temp != nullptr) &#123; cout &lt;&lt; "ServerName: " &lt;&lt; temp &lt;&lt; endl; &#125; /*释放内存*/ for (iter = cinfo.begin(); iter != cinfo.end(); iter++) &#123; delete (*iter);//因为*iter是一个指针 &#125; cinfo.clear();//最后清空容器 &#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>技术类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++迭代器的失控范例和解决方案]]></title>
    <url>%2F2019%2F06%2F28%2FC-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%A4%B1%E6%8E%A7%E8%8C%83%E4%BE%8B%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[迭代器失控范例情形一： 很多在使用迭代器类型进行遍历容器的操作进行对容器容量的变化都会导致迭代器的失控，即输出错误的值。例如：要对vector容器进行push_back()操作、对vector容器进行插入操作、删除操作。都会使end()函数返回的迭代器类型位置错乱，导致出现可能会修改未被使用内存的风险，从而使程序崩溃。 例如： 1234567891011vector&lt;int&gt; arrays&#123;12,35,56,78&#125;;vector&lt;int&gt;::iterator iter = arrays.begin();for(iter;iter!=arrays.end();iter++)&#123; cout &lt;&lt; *iter &lt;&lt;endl; arrays.push_back(2);&#125;//或者下面这种情况for(iter;iter!=arrays.end();iter++)&#123; cout &lt;&lt; *iter &lt;&lt;endl; arrays.insert(1,100);&#125; 实验结果： 在一般情况下，如果只是要对容器进行添加一个元素，可以使用下面的方法。 123456789101112vector&lt;int&gt; arrays&#123;12,35,56,78&#125;;vector&lt;int&gt;::iterator iter = arrays.begin();for(iter;iter!=arrays.end();iter++)&#123; cout &lt;&lt; *iter &lt;&lt;endl; arrays.push_back(2); break;//添加元素后直接跳出&#125;//再进行一次迭代器遍历for(iter;iter!=arrays.end();iter++)&#123; cout &lt;&lt; *iter &lt;&lt;endl; arrays.push_back(2);&#125; 实验结果： 如果真的在实际项目中要进行在迭代器遍历容器的时候对容器多次进行增添内容，可以使用下面的方法。 123456789101112131415vector&lt;int&gt; arrays&#123;12,35,56,78&#125;;vector&lt;int&gt;::iterator iter = arrays.begin();int i = 0//用来控制插入次数（循环次数） while(iter != arrays.end())&#123; iter = arrays.insert(iter,100); if(i &gt; 5) break; iter++; i++; &#125;for(iter = arrays.begin(); iter != arrays.end(); iter++)&#123; cout &lt;&lt; *iter &lt;&lt; endl;&#125; 实验结果： 实现思路:因为arrays.insert()的返回值是一个迭代器类型，所以在循环中不断刷新循环的起始位置(因为是前插，所以end()的值没有发生变化)。多次更新迭代器的起始begin()的值，从而使迭代器类型的指向不会失控。 同样的如果使用push_back(): 123456789101112131415161718vector&lt;int&gt; arrays&#123;12,35,56,78&#125;;vector&lt;int&gt;::iterator iter = arrays.begin();int i = 0//用来控制插入次数（循环次数） while(iter != arrays.end())&#123; arrays.push_back(100);//不断更新iter的值起始 iter = arrays.begin() if(i &gt; 5) break; iter++; i++; &#125;for(iter = arrays.begin(); iter != arrays.end(); iter++)&#123; cout &lt;&lt; *iter &lt;&lt; endl;&#125; 实验结果： 总体：即每对容器的容量进行变化一次便刷新迭代器的值。使其成为新的迭代器进行操作，就可以避免容器的失控。弊端：麻烦，代码较繁杂。 情形二： 如果在某个时候要对容器进行清空操作，多数下使用容器自带的clear()函数即可。但在某些特殊情况下，要对vector容器的某些元素进行删除，就得使用容器自带的` `函数。但是这样做就是对容器容量进行修改操作，会使迭代器指向失控。 例如： 12345vector&lt;int&gt; arrays&#123;12,35,56,78&#125;vector&lt;int&gt;::iterator iter;for(iter = arrays.begin(); iter != arrays.end(); iter++)&#123; arrays.erase(iter);&#125; 使用结果 如果真的要进行这样的操作可以这样做： 12345678910vector&lt;int&gt; arrays&#123;12,35,56,78&#125;vector&lt;int&gt;::iterator iter = arrays.begin();while(iter != arrays.end())&#123; iter = arrays.erase(iter);//直接让erase函数来更新迭代器指向的位置&#125;//for版for(iter; iter != arrays.end(); )&#123; iter = arrays.erase(iter);&#125; 实验结果： 实现思路：因为erase()函数是清除该位置的数据，并返回下一个元素的位置，所以可以通过它来对迭代器进行更新，从而不会时迭代器指向失控。 此情形更好的实现版本 1234567vector&lt;int&gt; arrays&#123;12,35,56,78&#125;vector&lt;int&gt;::iterator iter = arrays.begin();while(!arrays.empty())&#123;//如果不为空就继续 auto iter = arrays.begin();//每开始一轮循环就更新迭代器的指向。 arrays.erase(iter);&#125; —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>技术类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（1.6）迭代器]]></title>
    <url>%2F2019%2F06%2F26%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%881-6%EF%BC%89%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[迭代器的基本概念; 迭代器是一种遍历容器元素的一种数据类型，这种数据类型类似指针。 通过迭代器可以读取容器中的数据元素，也可以修改里面的数据元素 容器迭代器类型：(vector为例) 代码定义： 12vector&lt;int&gt; arrays = &#123;12,34,88&#125;;vector&lt;int&gt;::iterator iter;//迭代器定义，其中vector&lt;int&gt;::iterator是数据类型 操作 begin()/end() 用来返回迭代类型。 具体用法: rend()/rbegin() 这个是配套于vector&lt;int&gt;::r_iterator iter 具体用法: 实际运用： 1.用for语句遍历一个容器： 1234567vector&lt;int&gt; arrays = &#123;12,56,88,96&#125;; vector&lt;int&gt;::iterator iter = arrays.begin(); for (iter = arrays.begin(); iter != arrays.end(); iter++) &#123; cout &lt;&lt; *iter &lt;&lt; endl; &#125; 实验结果： 可以看出，迭代器类型是一个类似于指针一样的东西，允许自增/自减。在获得值或者修改的时候是用*iter进行操作。 const_iterator迭代器 不能改变迭代器指向的地址的内容。类似常量指针。 12345678vector&lt;int&gt; arrays = &#123;12,56,88,96&#125;; vector&lt;int&gt;::const_iterator iter = arrays.begin(); for (iter = arrays.begin(); iter != arrays.end(); iter++) &#123; cout &lt;&lt; *iter &lt;&lt; endl; (*iter)++;//报错。不能修改值 &#125; 使用情形1： 如果你的容器类型是常量的话const vector&lt;int&gt; arrays，那么你就只能且一定要常量迭代器。 cbegin()/cend()（C++11后才有的新特性） 这两个函数与begin()/end()很相似，只是无论迭代器类型是常量迭代器还是普通迭代器都返回一个常量迭代器 原来的begin()/end()会根据迭代器类型来返回。 迭代器失控 正常操作： 1234vector&lt;int&gt;arrays = &#123;12,56,88,96&#125;;for(auto a::arrays)&#123; cout &lt;&lt; a &lt;&lt; endl;&#125; 运行结果： 错误操作: 1234567891011121314vector&lt;int&gt;arrays = &#123;12,56,88,96&#125;;for(auto a::arrays)&#123; cout &lt;&lt; a &lt;&lt; endl; arrays.push_back(100);&#125;//上面等价于vector&lt;int&gt;arrays = &#123;12,56,88,96&#125;;vector&lt;int&gt;::iterator iter;for(iter = arrays.begin(); iter != arrays.end(); iter++)&#123; cout &lt;&lt; *iter &lt;&lt; endl; arrays.push_back(100);&#125; 运行结果: 结论：千万不要在迭代器操作过程中，千万不要改变vector(容器)的容量。这样错误的操作即：从容器删除，增加（使容器容量改变），可能会使迭代器指针失控，不能代表容器中的元素,在多数情况下程序会奔溃。 如果一定要在循环中进行容量增减操作： 1234567891011vector&lt;int&gt;arrays = &#123;12,56,88,96&#125;;vector&lt;int&gt;::iterator iter;for(iter = arrays.begin(); iter != arrays.end(); iter++)&#123; cout &lt;&lt; *iter &lt;&lt; endl; arrays.push_back(100); break；//直接break；&#125;//再开一个迭代器循环，此时的迭代器指针的值将重新赋值。for(iter = arrays.begin(); iter != arrays.end(); iter++)&#123; cout &lt;&lt; *iter &lt;&lt; endl;&#125; —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（3.3）链栈]]></title>
    <url>%2F2019%2F06%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%883-3%EF%BC%89%E9%93%BE%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈的链式实现算法及思路 栈的链式实现是以前插法为基础的。即以头结点next指向的是栈顶，进行入栈出栈等操作。 入栈 思路：创建好空链栈后，每插入一个数据，便创建一个新的结点p，让p结点的next指针等于head的next指针，让head的next指针再指向新结点p，从而完成push_back操作。 具体实现： 12345678bool push_back(T e)&#123; LNode*p = new LNode(); p-&gt;data = e; p-&gt;next = head-&gt;next; head-&gt;next = p; return true;&#125; 出栈 思路：直接让head的next指针指向head-&gt;next-&gt;next即跳过原栈的数据，所以可以先让一个临时的p指向head-&gt;next,然后让head的next指针直接指向p的next指针。之后释放p的空间。(注意：进行出栈操作要首先判断是否空栈) 具体实现： 123456789bool pop()&#123; LNode* p = head-&gt;next; if(!head-&gt;next)&#123; head-&gt;next = p-&gt;next; delete p; return true; &#125; return false;&#125; 析构函数 思路：析构函数就是链栈的销毁操作。总体上先把所有的数据进行出栈并释放空间，最后再把头结点释放了。所以要先用循环，分别释放每一个数据的空间。循环结束的判断条件是head-&gt;next 为空。 具体实现： 12345678~LkStack()&#123; LNode*p = head-&gt;next; while(p)&#123; head-&gt;next = p-&gt;next; delete p; p = head-&gt;next; &#125;&#125; 具体代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;class LkStack&#123; struct LNode &#123; T data; LNode* next; &#125;; LNode* head;public: LkStack() &#123; head = new LNode(); head-&gt;next = nullptr; &#125; ~LkStack() &#123; LNode* p = head-&gt;next; while (p) &#123; head-&gt;next = p-&gt;next; delete p; p = head-&gt;next; &#125; delete head; &#125; /*入栈操作*/ bool push_back(T e) &#123; LNode* p = new LNode(); p-&gt;data = e; p-&gt;next = head-&gt;next; head-&gt;next = p; return true; &#125; /*出栈操作*/ bool pop() &#123; if (!isEmpty()) &#123; LNode* p = head-&gt;next; head-&gt;next = p-&gt;next; delete p; return true; &#125; return false; &#125; /*是否为空*/ bool isEmpty() &#123; if (!head-&gt;next) return true; return false; &#125; /*获得栈顶数据*/ T&amp; GetTop() &#123; return head-&gt;next-&gt;data; &#125;&#125;;int main() &#123; LkStack&lt;int&gt; stack; cout &lt;&lt; "入栈了数据1" &lt;&lt;endl; stack.push_back(1); cout &lt;&lt; "入栈了数据2" &lt;&lt;endl; stack.push_back(2); cout &lt;&lt; "入栈了数据3" &lt;&lt;endl; stack.push_back(3); cout &lt;&lt; "入栈了数据4" &lt;&lt;endl; stack.push_back(4); cout &lt;&lt; "入栈了数据5" &lt;&lt;endl; stack.push_back(5); while (!stack.isEmpty()) &#123; cout &lt;&lt; stack.GetTop() &lt;&lt; endl; stack.pop(); &#125;&#125; —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++个人学习路线]]></title>
    <url>%2F2019%2F06%2F25%2FC-%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[此文章是加密文章，请输入密码后查看. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>个人随感</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习计划</tag>
        <tag>目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（1.5）vector容器详解]]></title>
    <url>%2F2019%2F06%2F25%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%881-5%EF%BC%89vector%E5%AE%B9%E5%99%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[vector的基本介绍及概念 标准库中的一个集合或者动态数组，可以存放若干个对象。它能把其他对象装起来，也称为容器。 代码定义： vector&lt;typename&gt; name; 在vector之后加一对&lt;&gt;,其&lt;&gt;内部填数据类型 定义及初始化vector对象 例：vector&lt;int&gt; arrays;创建一个int型的空的vector对象，里面没有包含任何元素。 初始化： 往空vector容器添加元素： arrays.push_back(100);往arrays容器中加入一个100。 元素拷贝的初始方式 vector&lt;int&gt;arrays2(arrays);把arrays直接拷贝进arrays2。 vector&lt;int&gt;arrays3 = arrays;同上。 用列表初始化(C++11标准后才有的新特性) vector&lt;int&gt;arrays4 = {12,32,45,67}; 创建指定数量的元素 vector&lt;int&gt; arrays5(15,-200);创建15个int类型的元素，每个元素都是-200。(不给初值就给默认初始值为0) vector&lt;string&gt; arrays6(5,&quot;hello&quot;);同上。 多种初始化方式 vector&lt;int&gt; arrays7{10};初始化，给一个元素，该元素数据是10. vector arrays8{“hello”};同上。 vector arrays8{10};分配10个string类型的数据都为“”(空串)。 因为10是整型，string类型不匹配所以分配10个元素空间作处理。 注意：要想正常的通过{}进行初始化，那么{}里边的值的类型，必须跟vector类型相同。 vector对象的操作 最常用的是不清楚具体元素数量，通过vector动态增加/简述，故一般使用前先创建一个空容器。vector&lt;int&gt; arrays 具体操作： 判断容器是否为空(bool) arrays.empty() 在容器末尾添加一个元素 arrays.push_back(int num) 返回容器总长度(元素个数) arrays.size() 清空容器 arrays.clear() 可以类似数组一样的用法(下标从0开始) arrays[n] 赋值 vector&lt;int&gt; arrays2; arrays2 = arrays; 注意：这里是类似普通数据类型的赋值一样，不是拷贝！ 123vector&lt;int&gt; arrays2; arrays2 = arrays;//此时array2里的 元素 及 元素个数 跟arrays一样。array2 = &#123;12,34,55,67&#125;//此时array2长度变为4，元素分别是12,34,55,67 相等 两个vector相等，首先元素要相同，对应位置的元素相同。 for循环遍历 for(auto &amp; v: arrays){} for(vector&lt;int&gt; v: arrays){} for遍历一些注意点： 1234for(auto v:arrays)&#123;//千万不要这样使用！！！ arrays.push_back(88);//在遍历的时候再往里面插入新元素，会导致arrays结构混乱 cout &lt;&lt; v &lt;&lt; endl;&#125; 原因：因为遍历的时候会记录arrays最后一个值的地址，如果插入新的值，会照成地址紊乱，输出乱值。 结论：千万不要在for遍历语句或类似操作中，改变遍历源的数值（删除/增加都不可以），调试找bug的时候会非常难发现。 —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（3.2）顺序栈的实现]]></title>
    <url>%2F2019%2F06%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%883-2%EF%BC%89%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[顺序栈的实现与算法思路（以char数据类型为例） 入栈push(char e)； 思路：在栈未满的情况下，直接对top(栈顶)指针指向的地址内容进行赋值，修改完毕后，直接top++移动栈顶至下一个位置。如果栈满则调用扩容操作。 具体实现： 1234567bool SqStack::push(char e) &#123; if ((top - data) == capacity)//容量满了就进行扩容 realloc(); *top = e; top++;//直接修改并移动top指针 return true;&#125; 出栈pop(); 思路：在没有空栈的情况下，直接让top自减一。 具体实现： 1234567bool SqStack::pop() &#123; if (top == data)//判断是否空栈。 return false; top--; return true; &#125; 顺序栈的实现情况 出栈(完成) push(char e) 入栈(完成) pop() 扩容(完成) realloc() 遍历(完成) Traverse(void(*fb)(char&amp; e)) 获得栈顶数据(完成) GetTop() 是否为空栈(完成) IsStackEmpty() 获得栈总容量(完成) GetCapacity() 具体代码： 123456789101112131415161718192021222324252627282930313233343536//Sqstack.h#ifndef _SQSTACK_H_#define _SQSTACK_H_ class SqStack &#123; char* top = nullptr; char* data = nullptr; int capacity;public: /*构造函数*/ SqStack(int c = 5); /*入栈操作*/ bool push(char e); /*出栈操作*/ bool pop(); /*遍历*/ void Traverse(void(*fb)(char&amp;e)); char GetTop(); bool IsStackEmpty(); int GetCapacity();private: /*扩容*/ bool realloc();&#125;; /*打印*/ void Print(char&amp; e);#endif // !_SQSTACK_H_ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//Sqstack.cpp#include&lt;iostream&gt;#include"Sqstack.h"using namespace std;/*构造函数*/SqStack::SqStack(int c) &#123; capacity = c;//默认给一个初值 data = new char[capacity]; top = data;&#125;/*扩容*/bool SqStack::realloc() &#123; char* n_data = new char[2 * capacity]; for (int i = 0; i &lt; capacity; i++) &#123; n_data[i] = data[i]; &#125; delete[]data; data = n_data; top = data + capacity;//这里要注意top也有重新赋值新的地址 capacity *= 2; cout &lt;&lt; "扩容成功！！" &lt;&lt; endl; return true;&#125;/*入栈操作*/bool SqStack::push(char e) &#123; if ((top - data) == capacity) realloc(); *top = e; top++; return true;&#125;/*出栈操作*/bool SqStack::pop() &#123; if (top == data) return false; top--; return true; &#125;/*遍历*/void SqStack::Traverse(void(*fb)(char&amp; e)) &#123; for (int i = 0; i &lt; top - data; i++) &#123; fb(data[i]); &#125; &#125;/*获得栈顶元素*/char SqStack::GetTop() &#123; return*(top - 1);&#125;/*判断是否空栈*/bool SqStack::IsStackEmpty() &#123; if (top == data) return true; return false;&#125;/*获得容量*/int SqStack::GetCapacity() &#123; return capacity;&#125;/*打印*/ void Print(char&amp; e) &#123; cout &lt;&lt; e &lt;&lt; " "; &#125; 123456789101112131415161718192021222324252627//main.cpp#include&lt;iostream&gt;#include"Sqstack.h"using namespace std;int main() &#123; SqStack stack; cout &lt;&lt; "入栈一个数据a" &lt;&lt; endl; stack.push('a'); stack.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "入栈一个数据b" &lt;&lt; endl; stack.push('b'); stack.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "入栈一个数据c" &lt;&lt; endl; stack.push('c'); stack.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "入栈一个数据d" &lt;&lt; endl; stack.push('d'); stack.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "入栈一个数据e" &lt;&lt; endl; stack.push('e'); stack.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "入栈一个数据f" &lt;&lt; endl; stack.push('f'); stack.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "出栈一个数据" &lt;&lt; endl; stack.pop(); stack.Traverse(Print); cout &lt;&lt; endl; &#125; —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（3.1）栈]]></title>
    <url>%2F2019%2F06%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%883-1%EF%BC%89%E6%A0%88%2F</url>
    <content type="text"><![CDATA[初识栈 定义：栈(stack)是限定仅在表尾插入和删除操作的线性表。 允许插入和删除的一段称为栈顶(top),另一段称为栈底(bottom)。 不含任何数据元素的栈称为空栈。 特点： 先进后出 后进先出 **注意：** 栈又被称为后进先出(Last in First out)的线性表 栈的插入操作，被称为进栈，也称压栈、入栈(push) 栈的删除操作也称出栈，也称为弹栈(pop) 示意图： 栈的抽象数据类型 ADT 栈(Stack) Data 栈的数据对象集合为{a1,a2,a3,…,an},每一个元素的类型均为同一个数据类型。其中除了第一个数据为，每个元素有且只有一个直接前驱元素，除了最后一个数据外，每个元素有且只有一个直接的后继元素。数据元素之间的关系是一对一的关系， Operation InitStack；初始化，创建一个空栈 destoryStack; 销毁栈 StackEmpty；判断是否为空 clearStack； 清空栈 getTop；获得栈顶元素 push 压栈 pop 出栈 stacklength；获得栈的长度 endADT 注意：栈本身就是一个线性表结构、线性表的顺序储存和链式存储，对于栈来说也同样适用 —（本文未完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（1.4）函数新特性、const关键字精解]]></title>
    <url>%2F2019%2F06%2F23%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%881-4%EF%BC%89%E5%87%BD%E6%95%B0%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%81const%E5%85%B3%E9%94%AE%E5%AD%97%E7%B2%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[函数 函数定义中，形参如果不会使用，则可以不给形参变量名，只给数据类型。 例如：int func(int a,int) 函数定义只能有一个，函数声明可以有多个。 其余概念： 函数声明是可以只有形参类型，没有形参名。 函数组织： 函数声明在头文件中。 函数定义单独在一个cpp文件中。(内联函数除外) 注意:在头文件定义函数时容易出现函数重复定义的报错。 函数新特性： 以往的函数是 [^前置返回类型]: 把函数返回类型放在函数之前，这种写法，叫前置返回类型。 `` 123void func(int a)&#123;//前置返回类型 return;&#125; 新版的可以由后置返回类型即：返回值写在函数后边 123auto func(int a)-&gt;int&#123;//后置返回类型 return a;&#125; 前面放auto,表示函数返回类型放在参数列表之后，而放在参数列表之后的返回类型是通过-&gt;开始的。 内联函数(inline关键字) 在函数前加inline使其变为内联函数。例：inline void func() 只在定义前面加关键字inline。 内联函数干了什么？ 使编译器在编译时能够识别内联函数里的内容并尝试把其与被调用的地方进行替换，此举节省了函数调用带来的消耗，从而可以提供程序运行效率。 使用场合： 当函数体很小，但调用很频繁的这种函数，应使用内联函数以提高效率。 与其他函数定义不同的是：内联函数的定义应该放在头文件。 使用不当： 不应该把太长的代码块的函数变为内联函数。 不用把有循环，函数递归的函数变为内联函数。 这些容易时代码膨胀,且如果在内联函数运行的时间比调用函数更慢，内联函数就没有意义了。 为什么要把内联函数定义在头文件：内联函数是为了告诉编译器标识的函数可以再调用时进行替换，只有这样做编译器才会把函数体里面的内容直接替换到调用的地方，如果你在函数声明的前面加inline编译器就不能直接获得函数体里面的内容，所以内联函数因在函数定义前加关键字inline。 正因为这样才建议把内联函数定义在头文件中，在每个调用该inline函数的文件中包含该头文件。这种方法保证了每个inline函数只有一个定义，且程序员无需复制代码，并且不可能在程序的生命周期中引起无意的不匹配的事情。 函数杂合用法总结：void函数： 函数返回类型为void，表示函数不返回任何类型。但是可以调用一个返回值类型为void，让其成为另一个返回值为void的函数的返回值。 123456789void func1()&#123; cout &lt;&lt; "hello" &lt;&lt; endl; return;&#125;void func2()&#123; return func1();//返回一个另一个返回值为void的函数&#125; 函数返回指针： 这是一个及其错误且危险的写法，即通过函数返回函数里面一个临时变量的地址。函数中的变量的生命期只限于函数内部，当函数结束时临时变量直接被系统回收，但这种情况，把已回收的临时变量的地址在外面继续被使用。即使用了野指针里面的值，用了不是属于自己的地址里的数据（使程序崩溃）。 123456789int* myfunc()&#123; int t = 9; return &amp;t;&#125;int main()&#123; int* p = myfunc(); *p = 6;&#125; 函数返回引用： 同上。如果在函数外头用一个引用来获取这个函数的返回值，就会造成把系统已回收的内存进行使用这是很危险的。但如果你是用一个非引用变量来接收其返回值，只是单单获取它的值而不是得到它的地址。所以这样做是安全的 123456789101112int&amp; myfunc()&#123; int t = 9; return t;&#125;int main()&#123; int&amp; p = myfunc(); p = 6;//错误用法造成t和p的地址是相同的，即：&amp;p = &amp;t 。修改了被回收的地址中的值。 int k = myfunc(); k = 3;//安全，因为k只接收到值，即&amp;k != &amp;t&#125; const关键字： const char*、char const *、char* const的区别 const char*： 这样定义是对指针指向的地址定义为常量。即指针可以发生变化，但不能修改指针指向的值。 123456789101112int main()&#123; char str[]&#123; "hello" &#125;; const char* a = str; a++;//允许，指针地址值可以发生变化 *a = 'f';//报错，不能修改内容 /*不仅仅是char，其余类型都是如此*/ int b = 4; int const * p = &amp;b; p++;&#125; char const*: 等价于const char* char*const 与上面相反，这样定义的是指针常量，即指针不能进行移动，但可以修改指针所指向的数值。 123456int main()&#123; int a = 4; int * const b = &amp;a; b++;//报错，不能修改指针指向的地址 *b = 9；//允许，可以修改指针地址的内容。&#125; 扩展：const char* const 这个是const char* 与char* const的结合，即：不能修改指针指向的地址里面的内容，也不能改变指针的指向。 const char&amp; 这样定义使这个引用只能绑在一个变量上，而不能再次切换绑定对象，且不能修改其内容值。 12345678int main()&#123; int a = 4; int c = 6; const int&amp; b = a; b = c;//报错，不能改变绑定对象 b = 2;//报错，不能修改其内容 &#125; —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.9）顺序存储结构与链式存储结构的逆置]]></title>
    <url>%2F2019%2F06%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-9%EF%BC%89%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E9%80%86%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[顺序结构的逆置算法与思路： 夹逼法： 思路：通过对数组头部和尾部相互对调并向中间靠近。 实现：(假设以整型为数据类型实现) 12345678910//length为顺序表总长度。bool Convert()&#123; int temp;//用来对换位置时使用的临时变量 for(int i = 0; i &lt; length/2; i++)&#123;//注意：length要除于2！！！！length要除于2！！！！ temp = datas[i]; datas[i] = datas[length - 1 - i];//前后换位置并向中间靠近 datas[length - 1 - i] = temp; &#125; return true;&#125; 注意：这里的length是要除于2的，因为只需向中间靠近即可而不是再往中间远离。即：移动的范围只是数组长度的一半。 算法优化： 12345678910//length为顺序表总长度。bool Convert()&#123; int temp;//用来对换位置时使用的临时变量 for(int i = 0 ，j = length - 1; i &lt; j; i++,j--)&#123; temp = datas[i]; datas[i] = datas[j];//前后换位置并向中间靠近 datas[j] = temp; &#125; return true;&#125; 此方法更能体现夹逼法。 链式存储结构的逆置算法与思路： 思路：把头结点和数据结点断开，然后把数据结点一个个前插进链表。（循环链表和单向链表均适用）,具体做法先让一个结点指针p保存第一个数据的地址，然后让头结点的next指针归零（即：使其与数据结点断开），开始循环：让一个临时指针指向p的下一个数据的地址，然后把这个第一个数据插入头结点后面（此时p指向为第一个数据的地址），即：p-&gt;next = head-&gt;next;head -&gt;next = p;其次移动指针p到下一个数据，这里就要运用到一开始的临时指针了。循环上面的操作，直到把所有数据都前插完毕。 实现1(单向链表)： 12345678910111213141516bool Convert()&#123; LNode* p = head-&gt;next; LNode* temp = nullptr;//临时指针 head-&gt;next = nullptr; while(p)&#123; temp = p-&gt;next;//获取下一个数据的值 p-&gt;next = head-&gt;next;//前插 head-&gt;next = p; p = temp;//移动指针到下一个数据 &#125; return true;&#125; 实现2(循环链表) 12345678910111213141516bool Convert()&#123; LNode* p = head-&gt;next; LNode* temp = nullptr;//临时指针 head-&gt;next = nullptr; while(p!=head)&#123; temp = p-&gt;next;//获取下一个数据的值 p-&gt;next = head-&gt;next;//前插 head-&gt;next = p; p = temp;//移动指针到下一个数据 &#125; return true;&#125; 前后只是循环条件发生变化。 —（本文完）&lt;原创&gt;&lt;待增添修改&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.8）线性表的顺序存储结构和链式存储结构之间的比较]]></title>
    <url>%2F2019%2F06%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-8%EF%BC%89%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[顺序结构与链式结构的比较： 顺序结构 链式结构 按序号下标读取 直接读取通过A[index]即可获的数据+++ 要从头开始找，找的下标才能获取数据—- 内存实验 要先规定好顺序结构的长度，可能没有利用好空间或空间不够用，不够用时还要扩容可能没有足够的空间或多出空间—- 按需要分配，想要一个就一个可利用很小的碎片空间+++ 插入元素 插入一个元素需要不断移动后面的元素，速度慢，消耗相比大—- 直接插入，速度快，消耗相比小+++ 删除 需要移动元素—- 直接删除+++ —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（1.3）范围for语句、动态分配、nullptr]]></title>
    <url>%2F2019%2F06%2F21%2FC%2B%2B%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%881-3%EF%BC%89%E8%8C%83%E5%9B%B4for%E8%AF%AD%E5%8F%A5%EF%BC%8C%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[For循环新特性： 可以使用for语句进行遍历数组（c++11新特性） 123456789101112131415#include&lt;iostream&gt;using namespace std;int main()&#123; int nums[] = &#123;1,2,5,6,8,21&#125;; int nums2[]&#123;33,1,75,45&#125;;//数组的新定义方法。 for(auto x:nums)&#123; cout &lt;&lt; x &lt;&lt; " "; &#125; cout &lt;&lt; endl &lt;&lt; endl;//auto自动判断数组类型。 for(auto x:nums2)&#123; cout &lt;&lt; x &lt;&lt; " "; &#125;&#125; 运行效果： 优化： 很显然通过这个for循环遍历数组是用过把数组内的每一个元素复制进x里面进行输出的。这里的复制操作将消耗一部分的效率。为提高程序运行效率这里可以采用引用来进行遍历。 123for(auto&amp;x : nums)&#123; cout &lt;&lt; x &lt;&lt; " ";&#125; 动态分配内存基本概念： 简述c语言与c++语言的内存分配不同： | C语言 | C++语言 || ——————————————— | —————————————————————- || 程序区、静态存储区、动态存储区 | 堆、栈、全局/静态区、常量存储区、程序代码区 | 其中C++语言： 栈：一般函数内的局部变量都会存在这。例如 int a = 4 此时这个a就是存储在栈区的（由编译器自动完成分配和释放，速度快，有限）。 堆：由程序员自己分配和释放。用new/malloc分配，delete/free释放。忘记释放后，当程序结束后才会被系统收回。 全局/静态存储区：存储全局变量和static变量，程序结束后被回收。 常量存储区： const定义的和一些字符串。 程序代码区 堆和栈的不同用途和区别 | 栈 | 堆 || ———————————————————— | —————————————————————————————— || 空间有限，分配速度快，程序员控制不了 | 只要不超出时间拥有的物理内存，也在操作系统运行你嫩功能分配最大内存大小之内，都可以分配。分配速度慢，好处是灵活。随时分配随时释放。 | malloc和free 这两个是c语言中对内存动态处理的函数（c++中的new和delete是关键字） void *malloc(int Numbytes): Numbytes:要分配的字节数。分配成功返回被分配内存的指针，分配失败则返回NULL； 1int* p = malloc() void free (void *FirstByte): 将之前malloc分配的内存空间还给程序。 12345678int* p = NULL;p = (int*)malloc(4*sizeof(int));if(p!=NULL)&#123; //分配成功 *p = 5; cout &lt;&lt; *p &lt;&lt; endl; free(p);&#125; 补充：字符串拷贝函数 strcpy(char*p,char*s)与strcpy_s(char*p,int size,char*s) strcpy()函数不安全：当指针s的字符串的长度大于指针p分配的内存时仍然继续往里进行拷贝字符串且不报错，使程序变的不再稳定。 strcpy_s()函数给定了一个size来限定指针s的长度，如果实际指针s的字符串长度大于size那么程序就会弹窗报错。 使用strcpy函数 123456789101112#include&lt;iostream&gt;using namespace std;int main() &#123; char* p = NULL; p = (char*) malloc(20 * sizeof(char)); strcpy(p, "Hello ShuHaoHwang"); cout &lt;&lt; p &lt;&lt; endl;&#125; 结果编译不通过并报错： 使用strcpy_s函数 情况1：源字符串实际长度小于size值。 123456789101112#include&lt;iostream&gt;using namespace std;int main() &#123; char* p = NULL; p = (char*) malloc(20 * sizeof(char)); strcpy_s(p, 2,"Hello ShuHaoHwang"); cout &lt;&lt; p &lt;&lt; endl;&#125; 结果运行报错： 情况2：正常情况。 123456789101112#include&lt;iostream&gt;using namespace std;int main() &#123; char* p = NULL; p = (char*) malloc(20 * sizeof(char)); strcpy_s(p, 20,"Hello ShuHaoHwang"); cout &lt;&lt; p &lt;&lt; endl;&#125; 正常运行： new和delete new/delete和malloc/free一样干了同样的事——分配和释放空间，同时new，delete还干了更多事情。 new与delete配对使用。malloc与free配对使用。 不要重复释放指针。 new的一般使用格式： 指针变量名 = new 类型; int* p = new int; 指针类型名 = new 类型(初始值)； int* p= new int(2);//给初始值 指针类型名 = new 类型[内存单元个数] (数组); int* p = new int[10]; 注意:当用指针分配一个数组的时候用 delete[] 指针名 mallo/free与new/delete的区别： malloc/free new/delete 只做了分配和释放内存工作 除了分配和释放内存，还进行了初始化工作(new)，和清理工作(delete)等 nullptr： nullptr是意为空指针。先看一段代码： 1234567891011121314#include&lt;iostream&gt;using namespace std;int main() &#123; int* a = 0; int* b = NULL; int* c = nullptr; cout &lt;&lt; "0 == NULL? " &lt;&lt; (a == b) &lt;&lt; endl &lt;&lt; "0 == nullptr? " &lt;&lt; (a == c) &lt;&lt; endl &lt;&lt; "NULL == nullptr? " &lt;&lt; (b == c) &lt;&lt; endl;&#125; 实验结果： 从实验结果发现对于指针来说他们三者并没有不同，都代表这空指针指向0x000000，但实质上nullptr是一个指针。NULL是一个数字它等于0；即： 12int p = NULL;//成立！p的值为0。int a = nullptr;//报错：数据类型不一致。 根据下面的代码探索nullptr和NULL： 12345678910#include&lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; typeid(NULL).name() &lt;&lt; endl; cout &lt;&lt; typeid(nullptr).name() &lt;&lt; endl; &#125; 提示:typeid(数据名).name():返回的是该数据的数据类型 实验结果： nullptr与NULL数据类型不同。nullptr本质上是一个指针，引入这个关键字的目的是区别代表数字时的NULL和代表指针空地址时的NULL防止混淆。 实际用法：在重载函数时nullptr会被识别成指针从而调用指针类型的重载 结论：对于指针的初始化，以往用到和指针有关的NULL的场合，能用nullptr的大家全部用nullptr取代NULL。 —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.7）双向链表]]></title>
    <url>%2F2019%2F06%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-7%EF%BC%89%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[双向链表 与单向链表的不同之处： 单向链表 双向链表 只知道后继节点，不知道前驱节点。每次查找只能从头开始查找。 相比单向链表增加了一个前驱指针，使前驱节点很快就能被找到 双向链表由于有了前后指针。可以使其从前往后走，也可以从后往前走。 根据双向链表具有前后两个指针的这个特性 在插入算法和删除算法中都有很好的优势 插入算法： 12345678910111213141516171819202122bool InsertElement(int index, T e) &#123; LNode* node = new LNode(); LNode* p = head; node-&gt;data = e; int j = 0; while (j &lt; index)//直接定位到要插入的位置即可 &#123; p = p-&gt;next; j++; &#125; p-&gt;prior-&gt;next = node;//指定位置的前一个数据的next指针指向新插入的数据地址 node-&gt;prior = p-&gt;prior;//新插入数据的prior指针指向原来位置数据的前一个数据地址 p-&gt;prior = node;//插入位置的前一个数据更变为新插入的数据地址 node-&gt;next = p;//新插入数据的next指针指向插入位置的地址 length++;//链表总长度加1 return true; &#125; 删除算法 12345678910111213141516bool DeleteElement(int index) &#123; LNode* p = head; int j = 0; while (j &lt; index)//直接定位到要删除的数据结点 &#123; p = p-&gt;next; j++; &#125; p-&gt;prior-&gt;next = p-&gt;next;//待删除的数据的前一个数据的next指针指向待删除数据的下一个数据的地址 p-&gt;next-&gt;prior = p-&gt;prior;//待删除数据的下一个数据的prior指针指向待删除数据的前一个数据 delete p;//释放待删除数据的空间 return true; &#125; 删除算法即可以直接跳过待删除数据结点。 其他测试代码详情：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;class BSLkList &#123; struct LNode &#123; T data; LNode* next; LNode* prior; &#125;; LNode* head; LNode* rear; int length;public: BSLkList() &#123; head = new LNode(); head-&gt;next = head; head-&gt;prior = head; rear = head; length = 0; &#125; /*后插操作*/ bool Push_back(T e) &#123; length++; LNode* node = new LNode(); LNode* p = head; if (!node) return false; while (p-&gt;next != head) &#123; p = p-&gt;next; &#125; node-&gt;data = e; p-&gt;next = node; node-&gt;next = head; node-&gt;prior = p; rear = node; return true; &#125; /*插入操作*/ bool InsertElement(int index, T e) &#123; LNode* node = new LNode(); LNode* p = head; node-&gt;data = e; int j = 0; while (j &lt; index) &#123; p = p-&gt;next; j++; &#125; p-&gt;prior-&gt;next = node; node-&gt;prior = p-&gt;prior; p-&gt;prior = node; node-&gt;next = p; length++; return true; &#125; /*删除操作*/ bool DeleteElement(int index) &#123; LNode* p = head; int j = 0; while (j &lt; index) &#123; p = p-&gt;next; j++; &#125; p-&gt;prior-&gt;next = p-&gt;next; p-&gt;next-&gt;prior = p-&gt;prior; delete p; return true; &#125; /*遍历操作*/ void Traverse(void(*fb)(T&amp; e)) &#123; LNode* p = head-&gt;next; while (p != head) &#123; fb(p-&gt;data); p = p-&gt;next; &#125; &#125; /*指定位置遍历操作*/ void Traverse(T e, void(*fb)(T&amp; e)) &#123; LNode* s = GetDataAddress(e); LNode* p = s; do &#123; if(s!=head) fb(s-&gt;data); s = s-&gt;next; &#125; while (s != p); &#125; private: /*获得指定结点地址操作*/ LNode* GetDataAddress(T e) &#123; LNode* p = head; while (p-&gt;next != head) &#123; if (p-&gt;data == e) return p; p = p-&gt;next; &#125; return NULL; &#125;&#125;;template&lt;typename T&gt;void Print(T&amp;e) &#123; cout &lt;&lt; e &lt;&lt; " ";&#125;int main() &#123; BSLkList&lt;char&gt; list; cout &lt;&lt; "后插入了一个A数据" &lt;&lt; endl; list.Push_back('A'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后插入了一个B数据" &lt;&lt; endl; list.Push_back('B'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后插入了一个C数据" &lt;&lt; endl; list.Push_back('C'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; "在2号位置插入了一个p数据" &lt;&lt; endl; list.InsertElement(2, 'p'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "在2号位置插入了一个p数据" &lt;&lt; endl; list.InsertElement(2, 'p'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; "删除了3号位置的数据" &lt;&lt; endl; list.DeleteElement(3); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "删除了1号位置的数据" &lt;&lt; endl; list.DeleteElement(1); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; "从B数据开始遍历" &lt;&lt; endl; list.Traverse('B', Print); cout &lt;&lt; endl;;&#125; 测试效果图： —(本文完)&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.6.1）附加：循环链表的优点之从指定结点开始遍历]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-6-1%EF%BC%89%E9%99%84%E5%8A%A0%EF%BC%9A%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E7%82%B9%E4%B9%8B%E4%BB%8E%E6%8C%87%E5%AE%9A%E7%BB%93%E7%82%B9%E5%BC%80%E5%A7%8B%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[体现循环链表的优点之从指定结点开始遍历​ 上一篇总结文章介绍了循环链表的基本概念和个人理解，但我觉得能很好区分非循环链表和循环链表初了链表的合并，还有一个就是循环链表可以从指定的结点开始遍历整个链表，这是非循环链表所做不到的。非循环链表每次遍历只能从头一个个开始遍历每一个元素，而循环链表就不同了，因为它的尾部是与头部相连的，这样就可以实现从某一个结点开始就可以遍历到链表每一个结点上，大大提高了效率。 这里通过遍历函数来体现这一特性。 123456789101112131415161718192021222324252627282930313233//查找链表中的某一个元素并获得它的地址LNode* GetDataAddress(T e) &#123; LNode* p = head-&gt;next; while (p != head) &#123; if (p-&gt;data == e) return p; p = p-&gt;next; &#125; return NULL; &#125;/*从某一个结点进行遍历*/ void Traverse(T e,void(*fb)(T&amp; t)) &#123; LNode* p = GetDataAddress(e);//获得指定结点的地址 LNode* q = p; if (!p) &#123; cout &lt;&lt; "链表为空" &lt;&lt; endl; return; &#125; do &#123; if(p!=head)//越过头结点 fb(p-&gt;data); p = p-&gt;next; &#125; while (p != q); &#125; 思路：先获得指定结点的地址先记录下来，并再用一个指针记下这个位置（便于判断）。其次这里使用的是do-while循环结构（使用do-while循环可以避免while循环漏遍历一个指定结点的数据），先调用函数指针的内容，然后移动指针p。直到指针p再次等于原来的指定结点的地址就停止。 具体实验代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;class CLkList&#123; struct LNode &#123; T data;//数据 LNode* next;//指向下一个数据的指针 &#125;; LNode* head;//头指针 LNode* rear;//尾指针 int length;public: /*构造函数*/ CLkList() &#123; head = new LNode(); length = 0; if (!head)throw"No Memory";//若没有new出来就抛出异常 head-&gt;next = head; rear = head-&gt;next; &#125; /*后插入操作*/ bool push_back(T e) &#123; length++; LNode* p = head-&gt;next; LNode* q = new LNode(); while (p-&gt;next != head) &#123; p = p-&gt;next; &#125; if (!p)return false; q-&gt;data = e;//进行data赋值 rear = q; q-&gt;next = head; p-&gt;next = q;//原最后一个元素数据的next指向这个新插入的空间地址 //length++; return true; &#125; /*获得指定结点地址操作*/ LNode* GetDataAddress(T e) &#123; LNode* p = head-&gt;next; while (p != head) &#123; if (p-&gt;data == e) return p; p = p-&gt;next; &#125; return NULL; &#125; /*遍历操作*/ void Traverse(void(*fb)(T &amp; t)) &#123; LNode* p = head-&gt;next;//从头结点开始遍历每一个元素的data while (p != head) &#123; fb(p-&gt;data); p = p-&gt;next; &#125; &#125; /*从某一个结点进行遍历*/ void Traverse(T e,void(*fb)(T&amp; t)) &#123; LNode* p = GetDataAddress(e);//从头结点开始遍历每一个元素的data LNode* q = p; if (!p) &#123; cout &lt;&lt; "链表为空" &lt;&lt; endl; return; &#125; do &#123; if(p!=head) fb(p-&gt;data); p = p-&gt;next; &#125; while (p != q); &#125;private:&#125;;template&lt;typename T&gt;void Print(T&amp; e) &#123; cout &lt;&lt; e &lt;&lt; " ";&#125;int main() &#123; CLkList&lt;char&gt; list; cout &lt;&lt; "后面插入了一个a数据" &lt;&lt; endl; list.push_back('a'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个b数据" &lt;&lt; endl; list.push_back('b'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个c数据" &lt;&lt; endl; list.push_back('c'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个d数据" &lt;&lt; endl; list.push_back('d'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "从b数据开始遍历链表； " &lt;&lt; endl; list.Traverse('b', Print); cout &lt;&lt; endl; cout &lt;&lt; "从c数据开始遍历链表； " &lt;&lt; endl; list.Traverse('c', Print); cout &lt;&lt; endl; &#125; 运行结果： 小结：​ 这里只是单单用遍历体现了循环链表的这个特点。 ​ 其实不单单在遍历操作上，这个更可以在查找操作上体现出这个优点，例如：在指定结点开始寻找其后的某个值、删除操作也可以运用上。 —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.6）循环链表（单向链表）、清空链表与销毁链表]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-6%EF%BC%89%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[循环链表 相较于非循环链表 在非循环链表中，最后一个元素的next指针是空指针，造成浪费。 每次寻找后继指针的时候都要重新从头开始找。 循环链表 尾指针直接指向表头，使最后一个元素的next指针被利用起来。 从每一个元素开始都能遍历表中每一个元素。 便于类似于链表合并这样的算法实现。 其他不同： 循环链表与非循环链表的判断条件发生了变化 判断的具体解释（循环链表） 判断到前驱结点： 1234while (p-&gt;next != head) &#123; p = p-&gt;next; &#125; ​ 因为最后一个结点的next指针不再是空指针而是一个指向head的指针，所以在while循环中如果p的next指针下一个为head指针那么这时指针p就定位到head的前驱指针了。 判断到头结点： 1234while (p != head) &#123; p = p-&gt;next; &#125; ​ 这个也很好判断，不断移动指针p当等于头结点时就跳出循环，此时p定位到头结点。 循环链表的尾指针 循环链表通常是有一个尾指针的它指向的是最后一个元素的地址。 尾指针的好处： 找head指针非常方便。rear-&gt;next的值便是head。 便于链表的合并。 代码实现空表时的尾指针： 1234567891011121314151617181920212223class CLkList&#123; struct LNode &#123; T data;//数据 LNode* next;//指向下一个数据的指针 &#125;; LNode* head;//头指针 LNode* rear;//尾指针 int length;public: /*构造函数*/ CLkList() &#123; head = new LNode(); length = 0; head-&gt;next = head; rear = head-&gt;next;//空表时的尾指针 &#125;&#125; 当插入一个元素后尾指针的变化 123456789101112131415161718192021//从链表最后面插入元素bool push_back(T e) &#123; length++; LNode* p = head-&gt;next; LNode* q = new LNode(); while (p-&gt;next != head) &#123; p = p-&gt;next; &#125; if (!p)return false; q-&gt;data = e;//进行data赋值 rear = q;//因为是从最后面插入那么此时这个最后一个元素的的地址是尾指针指向的 q-&gt;next = head; p-&gt;next = q;//原最后一个元素数据的next指向这个新插入的空间地址 return true; &#125; 链表合并的实现: 具体思路（链表2合并到链表1）：先获得链表2的头结点的地址（即：链表2的指针head）然后让链表1的head指针指向链表2的指针head-&gt;next指向的地址（即：链表2的第一个元素的地址），然后让链表2的指针rear（尾指针）指向链表1的head-&gt;指向的地址（即指向链表1的第一个元素）最后delete 链表2的head指针。完成合并操作。 合并前： 合并后： 具体实现： 1234567891011121314bool ListCombine(CLkList* s) &#123; LNode* t_head_of_s = s-&gt;head;//获得链表2的head指针 s-&gt;rear-&gt;next = head-&gt;next;//让链表2的尾指针指向链表1的第一个元素 head-&gt;next = t_head_of_s-&gt;next;//让链表1的head-&gt;next指针指向链表1第一个元素 delete t_head_of_s;//释放原链表2的head指针 return true;&#125; 循环链表具体代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;class CLkList&#123; struct LNode &#123; T data;//数据 LNode* next;//指向下一个数据的指针 &#125;; LNode* head;//头指针 LNode* rear; int length;public: /*构造函数*/ CLkList() &#123; head = new LNode(); length = 0; if (!head)throw"No Memory";//若没有new出来就抛出异常 head-&gt;next = head; rear = head-&gt;next; &#125; /*往后插入操作*/ bool push_back(T e) &#123; length++; LNode* p = head-&gt;next; LNode* q = new LNode(); while (p-&gt;next != head) &#123; p = p-&gt;next; &#125; if (!p)return false; q-&gt;data = e;//进行data赋值 rear = q; q-&gt;next = head; p-&gt;next = q;//原最后一个元素数据的next指向这个新插入的空间地址 //length++; return true; &#125; /*获得链表长度*/ int GetLength() &#123; return length; &#125; /*插入元素操作*/ bool InsertElement(int index,T e) &#123; LNode* p = head; LNode* q = new LNode(); int j = 0; while ( j &lt; index-1) &#123; p = p-&gt;next; j++; &#125; q-&gt;data = e; q-&gt;next = p-&gt;next; p -&gt; next = q; length++; return true; &#125; /*删除操作（下标型）*/ bool DeleteElement(int index) &#123; LNode* p = head; LNode* q = head-&gt;next; int j = 0; while (j &lt; index-1) &#123; p = p -&gt; next; q = q -&gt; next; j++; &#125; p-&gt;next = q-&gt;next; delete q; length--; return true; &#125; /*删除操作（找值型）*/ bool DeleteElement(T e) &#123; LNode* p = head; LNode* q = head-&gt;next; while (q != head) &#123; if (q-&gt;data == e) &#123; p-&gt;next = q-&gt;next; delete q; length--; return true; &#125; p = p-&gt;next; q = q-&gt;next; &#125; return false; &#125; /*清空链表操作*/ bool ListClean() &#123; length = 0; LNode* p = head-&gt;next; LNode* q; while (p-&gt;next != head)//定位到头结点之前，清空初头结点的外的其他数据空间 &#123; q = p -&gt; next; delete p; p = q; &#125; head-&gt;next = head; return true; &#125; /*合并操作*/ bool ListCombine(CLkList* s) &#123; LNode* t_head_of_s = s-&gt;head; s-&gt;rear-&gt;next = head-&gt;next; head-&gt;next = t_head_of_s-&gt;next; length += s-&gt;length; delete s-&gt;head; return true; &#125; /*遍历操作*/ void Traverse(void(*fb)(T &amp; t)) &#123; LNode* p = head-&gt;next;//从头结点开始遍历每一个元素的data while (p != head) &#123; fb(p-&gt;data); p = p-&gt;next; &#125; &#125;private:&#125;;template&lt;typename T&gt;void Print(T&amp; e) &#123; cout &lt;&lt; e &lt;&lt; " ";&#125;int main() &#123; CLkList&lt;char&gt; list; cout &lt;&lt; "后面插入了一个a数据" &lt;&lt; endl; list.push_back('a'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个b数据" &lt;&lt; endl; list.push_back('b'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个c数据" &lt;&lt; endl; list.push_back('c'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个d数据" &lt;&lt; endl; list.push_back('d'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "在2号位置插入p数据" &lt;&lt; endl; list.InsertElement(2, 'p'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "删除测试 " &lt;&lt; endl; cout &lt;&lt; "2号位置的数据被删除了" &lt;&lt; endl; list.DeleteElement(2); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "数据a删除了" &lt;&lt; endl; list.DeleteElement('a'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "数据b删除了" &lt;&lt; endl; list.DeleteElement('b'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "list2: " &lt;&lt; endl; CLkList&lt;char&gt; list2; cout &lt;&lt; "后面插入了一个v数据" &lt;&lt; endl; list2.push_back('v'); list2.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个n数据" &lt;&lt; endl; list2.push_back('n'); list2.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个m数据" &lt;&lt; endl; list2.push_back('m'); list2.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "list2合并到list" &lt;&lt; endl; list.ListCombine(&amp;list2); cout &lt;&lt; "合并后：" &lt;&lt; endl; list.Traverse(Print); cout &lt;&lt; endl; //清空list list.ListClean(); cout &lt;&lt; "清空完成" &lt;&lt; endl; &#125; 销毁链表与清空链表的区别： 销毁链表 清空链表 具体解释 包括头结点全部清空全部delete 保留头结点其他数据元素全部delete清空 产生的后果 头指针丢失，链表无法使用 清空链表后，保留了头结点，只是元素被清空了（即链表回到初始空表状态）还可以使用。 —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-(1.2)auto、头文件防卫]]></title>
    <url>%2F2019%2F06%2F18%2FC%2B%2B%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-(1.2)auto%E3%80%81%E5%A4%B4%E6%96%87%E4%BB%B6%E9%98%B2%E5%8D%AB%2F</url>
    <content type="text"><![CDATA[Auto auto：变量的自动类型推断。 可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型。（声明时要初始化） 自动推断发生在编译期间，所以使用auto不会造成程序效降低。 头文件防卫式声明 语法： 123456#ifndef _文件名_H#define _文件名_H内容#endif 为什么要用到头文件防卫式声明？ 目的：为了防止头文件中多重、重复定义内容。 情景假设： 假设一个工程里面有两个个头文件.h文件。里面都有自己的内容 123//head1.hint number1 = 8； 123//head2.hint number2 = 5; 1234567891011//main.cpp#include&lt;iostream&gt;#include"head1.h"#include"head2.h"using namespace std;int main()&#123; cout &lt;&lt; number1 &lt;&lt; endl; cout &lt;&lt; number2 &lt;&lt; endl;&#125; 编译运行情况： 假设在head2.h也include了head1.h，且在main.cpp里面也分别include了head1.h和head2.h再进行编译就会出现： 错误原因：出现了number1重复定义的错误，为啥呢？因为在执行main.cpp文件编译的时候已经对head1.h里面的内容进行了编译定义，但到了head2.h的文件的时候又include了head1.h意味着又重复定义了一次head1.h里面的内容从而造成head1.h里的number1重复定义的错误。 如何解决？——对头文件进行防卫式定义 即对head1.h文件编辑 1234567//head1.h#ifndef _HEAD1_H//如果head1.h没有被定义那么就执行下面的内容#define _HEAD1_H//定义head1.hint number1 = 8；#endif//结束如果 当main.cpp执行编译操作的时候head1.h是没有定义的。所以#ifndef下面的内容将被执行即先定义head1.h文件。但到了include”head2.h”的时候发现head2.h里面也有include“head1.h”但此时head1.h已经被定义了，故#ifndef不成立下面的内容就没有被执行了，从而避免了头文件重复定义的情况。 结论：所以以后定义头文件的时候都可以进行防卫式定义然后就可以随便include定义的头文件了避免这些错误了。 —(本文完)&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-(1.1)命名空间]]></title>
    <url>%2F2019%2F06%2F17%2FC%2B%2B%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-(1.1)%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[命名空间的基本概念简介基本概念 命名空间就是为了防止名字冲突引入的一种机制。系统中可以定义多个命名空间，每个命名空间都有自己的名字，不可以同名。 可以把命名空间看成一个作业域，在这个命名空间定义的函数，跟你另外一个命名空间里定义的函数，即便同名，也互不影响。 命名空间定义： 1234namespace 命名空间名&#123; void fb()&#123;&#125;//函数 ....&#125; 命名空间的定义可以不连续，甚至可以写在多个文件中，如果以为没有定义这个命名空间，那么相当于定义命名空间，如果已经定义了，那么就算打开这个命名空间并可以往里面添加新成员的声明； 情形 假设同一个工程里面有两个project.cpp和project2.cpp文件并分别给两个程序员去编写，在编写过程中张三和李四都定义了同名、返回值相同、参数也相同的void Print()函数，在编译时将会出现： 找到一个或多个多重定义的符号 void_cdecl Print(void)已在project2.obj中定义的错误 如何去解决这种问题呢？分别去改函数名或许是个好方法，但是如果这样的情况多了起来难免就太麻烦了。这里就可以用命名空间来解决具体： 123456//project1.cppnamespace ZhangSan &#123; void Print() &#123; cout &lt;&lt; "这是张三的Print函数" &lt;&lt; endl; &#125;&#125; 这样就解决了这种重名的问题。如果要调用张三的这个同名函数就可以用 命名空间名::实体名（函数名）的方法调用张三的Print函数 （其中“ : : “是作用域运算符）。 12345int main() &#123; ZhangSan::Print();//张三的 Print();//李四的&#125; 运行情况： 但是每次调用的时候都要用命名空间名::实体名（函数名）的方法岂不是也太麻烦了。 所以这里就要用上using关键字了，只要在头文件引入语句下面加入： using namespace ZhangSan就可以了 1234567891011#include&lt;iostream&gt;#include"project2.h"//张三命名空间定义所在的头文件using namespace std;using namespace ZhangSan;//使用的张三的命名空间int main() &#123; Print();//张三的&#125; 运行情况: —(本文完)&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-(2.5)链表存储结构的算法]]></title>
    <url>%2F2019%2F06%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882.5%EF%BC%89%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[链表储存结构 链表（LinkedList） 定义: 每个元素用一个指针（以存储下一个数据的地址）相互串联起来为存储方式的物理存储结构 对应线性表操作： 前插数据元素 Insert_Front() 后插数据元素 Push_back() 插入数据 Insert_Element() 删除数据 Delete_Element() 获得数据 Get() 设置数据 Set() 遍历链表 Traverse() …… 对应一些算法实现思路 插入操作： 思路：先通过移动指针获得要插入位置前一个元素的地址，然后创建一个新的元素空间让要插入的数据对其进行赋值，然后将前一个数据的next指针指向这个新空间的地址，而原来next指针指向的地址赋值给新空间的next指针 具体实现： 123456789101112131415bool InsertElement(int index, T e) &#123; LNode* p = head;//这里的p是指向头结点的指针，目的是要从第一个数据开始往下算下标 int j = 0; while (p &amp;&amp; j &lt; index-1)//定位到要插入元素位置的前一个元素（即：寻找前驱结点） &#123; p = p-&gt;next; ++j; &#125; LNode* s = new LNode();//创建一个链表数据空间 s-&gt;data = e;//把要插入的数据放入这个空间 s-&gt;next = p-&gt;next;//这个新的空间的下一个指针地址是上一个元素的下一个元素地址 p-&gt;next = s;//上一个元素的下一个指针地址变为新空间的地址 return true; &#125; 删除操作： 思路：根据要删除的位置的下标先让一个指针定位到这个位置的前一个元素。这时要先创建一个临时的指针指向将删除的元素的地址（此步目的是获得下一个元素的地址，因为删除后不能获得要删除元素next指针的地址），然后将待删除的元素的前一个元素的next指针等于这个临时指针的next指针，最后delete这个临时指针。 具体实现： 1234567891011121314bool DeleteElement(int index) &#123; LNode* p = head;//定位到头结点 int j = 0;//从第0个元素开始移动指针 while (p &amp;&amp; j &lt; index - 1) &#123;//找到要删除元素数据的前一个位置 p = p-&gt;next; ++j; &#125; LNode* q = p-&gt;next;//用一个临时指针存储要删除数据元素的位置（目的为了获取待删除数据元素的下一个数据元素的位置） p-&gt;next = q-&gt;next;//把前一个数据元素的下一个指针地址存储 delete q;//释放临时指针（即：要删除数据元素）的空间 length--; return true; &#125; 链表存储结构代码实现情况： 前插操作（完成） bool InsertFront(T e) 后插操作（完成） bool push_back(T e) 插入操作（完成） bool InsertElement(int index, T e) 删除操作（完成） bool DeleteElement(int index) 获得操作（完成） bool Get(int index,T&amp; e) 修改操作（完成） bool Set(int index, T e) 遍历操作（完成） void Traverse(void(*fb)(T&amp; t)) 代码详细123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;class LkList&#123; struct LNode &#123; T data;//数据 LNode* next;//指向下一个数据的指针 &#125;; LNode* head;//头指针 int length;public: /*构造函数*/ LkList() &#123; head = new LNode(); length = 0; if (!head)throw"No Memory";//若没有new出来就抛出异常 head-&gt;next = 0; &#125; /*获得数据操作*/ bool Get(int index,T&amp; e) &#123; LNode* p = head-&gt;next;//这里的p指向的下一个元素的头指针 int j = 1; while (p &amp;&amp; j &lt; index) &#123; p = p-&gt;next;//把p的指针往后一个元素头指针移动 ++j; &#125; if (!p || j &gt; index) return false; e = p-&gt;data;//获得数据 return true; &#125; /*插入元素操作*/ bool InsertElement(int index, T e) &#123; LNode* p = head;//这里的p是指向头结点的指针，目的是要从第一个数据开始往下算下标 int j = 0; while (p &amp;&amp; j &lt; index-1)//定位到要插入元素位置的前一个元素（即：寻找前驱结点） &#123; p = p-&gt;next; ++j; &#125; if (!p || j &gt; index) return false; LNode* s = new LNode();//创建一个链表数据空间 s-&gt;data = e;//把要插入的数据放入这个空间 s-&gt;next = p-&gt;next;//这个新的空间的下一个指针地址是上一个元素的下一个元素地址 p-&gt;next = s;//上一个元素的下一个指针地址变为新空间的地址 length++; return true; &#125; /*删除元素操作*/ bool DeleteElement(int index) &#123; LNode* p = head;//定位到头结点 int j = 0;//从第0个元素开始移动指针 while (p &amp;&amp; j &lt; index - 1) &#123;//找到要删除元素数据的前一个位置 p = p-&gt;next; ++j; &#125; if (!p || j &gt; index) return false; LNode* q = p-&gt;next;//用一个临时指针存储要删除数据元素的位置（目的为了获取待删除数据元素的下一个数据元素的位置） p-&gt;next = q-&gt;next;//把前一个数据元素的下一个指针地址存储 delete q;//释放临时指针（即：要删除数据元素）的空间 length--; return true; &#125; /*前插操作*/ bool InsertFront(T e) &#123; LNode* q = new LNode();//创建一个新数据空间 if (!q)return false; q-&gt;data = e;//对要插入的数据进行赋值到这个空间的data q-&gt;next = 0;//避免第一个数据next指针出现野指针的问题 q-&gt;next = head-&gt;next;//与头结点相连 head-&gt;next = q;//这个next指针指向第二个数据的位置 length++; return true; &#125; /*往后插入操作*/ bool push_back(T e) &#123; LNode* p = head;//从头结点开始让指针指向最后一个数据元素的地址 LNode* q = new LNode(); int j = 0; while (p-&gt;next)//如果p-&gt;next为空指针，意味着找到了最后一个数据元素的地址 &#123; p = p-&gt;next; &#125; if (!p)return false; q-&gt;data = e;//进行data赋值 q-&gt;next = 0;//因为是后插，说明后面没有数据元素地址，让这个空间的next指针赋值为0 避免野指针问题 p-&gt;next = q;//原最后一个元素数据的next指向这个新插入的空间地址 length++; return true; &#125; /*设置操作*/ bool Set(int index, T e) &#123; LNode* p = head;//从头结点开始寻找要修改的位置 int j = 0; while (p &amp;&amp; j &lt; index) &#123; p = p-&gt;next; ++j; &#125; if (!p || j &gt; index) return false; p-&gt;data = e;//数据进行修改 return true; &#125; /*遍历操作*/ void Traverse(void(*fb)(T&amp; t)) &#123; LNode* p = head-&gt;next;//从头结点开始遍历每一个元素的data while (p) &#123; fb(p-&gt;data); p = p-&gt;next; &#125; &#125;private:&#125;;template&lt;typename T&gt;void Print(T&amp;t) &#123; cout &lt;&lt; t &lt;&lt; " ";&#125;int main() &#123; LkList&lt;char&gt; List; cout &lt;&lt; "前插了一个A " &lt;&lt; endl; List.InsertFront('A'); List.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "前插了一个B " &lt;&lt; endl; List.InsertFront('B'); List.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后插了一个C " &lt;&lt; endl; List.push_back('C'); List.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "在第4个位置插入了O " &lt;&lt; endl; List.InsertElement(4, 'O'); List.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "在第4个位置插入了G " &lt;&lt; endl; List.InsertElement(4, 'G'); List.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "删除了第2位的元素 " &lt;&lt; endl; List.DeleteElement(2); List.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "把第3位的数据修改成I" &lt;&lt; endl; List.Set(3,'I'); List.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "获得第4位的数据 " &lt;&lt; endl; char ch; List.Get(4, ch); cout &lt;&lt; ch &lt;&lt; endl;&#125; —（本文完)&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-(2.4)初识链表]]></title>
    <url>%2F2019%2F06%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882.4%EF%BC%89%E5%88%9D%E8%AF%86%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表基本概念 结点包括数据域和指针域。 链表是有n个结点链结成，第一个结点的存储位置叫做头指针，最后一个结点的指针为“空”。 相较于顺序表存储结构的优点： 不用定义时规定长度。 存储的元素个数不受限制。 插入和删除元素时，不用移动其他元素。 链表的头指针和头结点 基本概念 头指针：链表中第一个结点的储存位置。 头结点：在单链表的第一个结点前附设的一个结点。 头指针 头结点 若链表有头结点，则是指向头结点的指针；若没有则是链表指向第一个结点的指针 头结点是为了操作的统一和方便而设立的，放在第一个结点之前 其数据域一般无意义（可以存储链表的长度） 头指针具有表示作用，所以常常有头指针表示链表的名字 有了头结点，在第一个结点前插入和删除第一个结点时，操作与其他结点的操作就统一了 无论链表是否为空，头指针均不为空。头指针是链表的必要元素 头结点不一定是链表的必须要素 链表存储结构 链表存储结构的特点是如何将数据域与“指标”（指针域）配对，以及指示下一条数据的内存位置。 链表存储结构中，数据存储在内存中分散的位置。各个数据由一个指针相互连接 一个数据中的指针域存放的是下一个数据的地址。 由于数据储存在不同的位置，每一个数据只能通过指针域中的指针来访问 删除：删除元素时只需将前一个数据的指针域指向要删除数据的下一个数据的地址即可，从而避免了顺序表存储结构多次的数据调换的麻烦。 添加：添加只需把要添加的位置的前一个数据的指针指向新数据，再让新数据的“指标”指向后一个数据的地址即可。 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.3）顺序表存储结构代码、算法实现]]></title>
    <url>%2F2019%2F06%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882.3%EF%BC%89%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81%E3%80%81%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[顺序表储存结构 顺序表(SqList) 定义： 顺序表存储结构是一个以连续空间地址存储为方式的物理结构 实现线性表相应操作： SqList（） 初始化线性表：创建一个空的线性表List SqList.InsertElement（index ， e） 在线性表List的index下标处插入元素e SqList.DeleteElement（ index， *e) 删除线性表List中的第i个元素，并返回删除元素指针e SqList.GetLength（） 获得线性表的长度 SqList.DeleteAllElement（） 清空线性表 SqList.find（e） 查找线性表中的元素e ………. 一些基础算法的实现思路 插入算法： 思路：根据想要插入的下标为准，用循环各各数值往后移动（即：相互覆盖赋值）空出指定下标进行插入赋值。从最后一个元素开始往后赋值 具体实现： 12345678910void InsertElement(int index, Datas t) &#123; length++;//因为要插入一个新的元素，故实际长度要加1 for (int i = length; i &gt; index; i--) &#123;//先把后面的元素全部往后覆盖赋值 datas[i] = datas[i - 1]; &#125; datas[index] = t;//在目标index位置插入新元素 &#125; 删除算法： 思路：根据要删除元素的下标为目标往前覆盖赋值。 具体实现： 1234567void DeleteElement(int index) &#123; for (int i = index; i &lt; length-1; i++) &#123; datas[i] = datas[i + 1]; &#125; length--;//每删除一个length（实际长度）将减少 &#125; 扩容： 思路：先判断是否是否满了，（即：用最大容量与实际长度相互比较如果相等那么就算满了），确定满容后先重新获得一个跟大的空间容量，然后把原来的线性表数组对其进行赋值。Delete原线性表数组，地址等于新扩容后的地址，完成扩容操作。 具体实现： 1234567891011121314if(length == capacity)//判断使用扩容的时机void realloc() &#123; T* p = new T[2 * capacity];//最大容量扩大两倍 for (int i = 0; i &lt; length; i++) &#123;//把原顺序表赋值到新顺序表 p[i] = datas[i]; &#125; delete[]datas;//清空原线性表里的元素 datas = p;//把新扩容后线性表的地址赋给datas p = NULL;//避免临时指针p变为野指针 capacity *= 2;//总容量扩大 &#125; 根据线性表用顺序存储结构实现的操作完成情况： 增加元素（完成） bool Push_back(T) 查找元素（完成） bool GetElement(int index,T&amp;c) 扩容（完成） bool realloc() 删除元素（完成） bool DeleteElement(int index) 插入元素(完成) bool InsertElement(int index, T t) 清空元素（完成）&lt;待完善修改&gt; bool DeleteAllElement() 代码详细：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include&lt;iostream&gt;#define MAX_SIZE 1 //定义最大容量using namespace std;template&lt;typename T&gt;class SqList&#123;private: T* datas; //线性表 int length = 0;//实际容量 int capacity;//总容量public: /*构造函数*/ SqList() &#123; capacity = MAX_SIZE;//总容量等于最大容量（进行初始化） datas = new T[capacity]; cout &lt;&lt; "初始化成功！！！" &lt;&lt; endl; &#125; /*获得总容量*/ int GetLength() &#123; return length; &#125; /*查找并取值操作*/ bool GetElement(int index, T&amp; c) &#123; if (index &lt; 0 || index &gt; length) return false; c = datas[index]; return true; &#125; /*增加元素操作*/ bool Push_back(T NewElem) &#123; if (length == capacity)//判断顺序表是否满了 &#123;//如果满了调用扩容操作 if(!realloc())//如果扩容失败那么Push_back也失败 return false; &#125; datas[length] = NewElem; length++; return true; &#125; /*设置元素操作*/ bool SetElement(int index, T t) &#123; if (index&lt;0 || index&gt;length)//判断下标是否输入正确 return false; datas[index] = t; return true; &#125; /*插入元素操作*/ bool InsertElement(int index, T t) &#123; if (index&lt;0 || index&gt;length)//判断下标是否输入正确 return false; length++;//因为要插入一个新的元素，故实际长度要加1 if (length == capacity)//判断顺序表是否满了 &#123;//如果满了调用扩容操作 if (!realloc())//如果扩容失败那么Push_back也失败 return false; &#125; for (int i = length; i &gt; index; i--) &#123;//先把后面的元素全部后退 datas[i] = datas[i - 1]; &#125; datas[index] = t;//在目标index位置插入新元素 return true; &#125; /*删除元素操作*/ bool DeleteElement(int index) &#123; if (index&lt;0 || index&gt;length)//判断下标是否输入正确 return false; for (int i = index; i &lt; length-1; i++) &#123; datas[i] = datas[i + 1]; &#125; length--;//每删除一个length（实际长度）将减少 return true;//删除动作完成后返回true &#125; /*清空元素操作*/ bool DeleteAllElement() &#123; int len = length; for (int i = 0; i &lt; len; i++) &#123; DeleteElement(0); &#125; return true; &#125; /*查找元素操作*/ int find(T e, int pos = 0) &#123; for (int i = pos; i &lt; length; i++) &#123; if(datas[i] == e) return i; &#125; return -1; &#125;private: /*扩容操作*/ bool realloc() &#123; T* p = new T[2 * capacity];//最大容量扩大两倍 cout &lt;&lt; "扩容成功！！！" &lt;&lt; endl; if (!p)return false; for (int i = 0; i &lt; length; i++) &#123;//把原顺序表赋值到新顺序表 p[i] = datas[i]; &#125; delete[]datas;//清空原线性表里的元素 datas = p;//把新扩容后线性表的地址赋给datas p = NULL;//避免临时指针p变为野指针 capacity *= 2;//总容量扩大 return true;//更换扩容操作完成后宣布扩容操作成功 &#125;&#125;;//打印顺序表操作template&lt;typename T&gt;//模版void Print(SqList&lt;T&gt;&amp; L) &#123; T e; for (int i = 0; i &lt; L.GetLength(); i++) &#123; L.GetElement(i, e); cout &lt;&lt; e &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; int main() &#123; SqList&lt;char&gt; List; char ch; if (!List.GetElement(1, ch)) cout &lt;&lt; "未找到" &lt;&lt; endl; cout &lt;&lt; "加入A" &lt;&lt; endl; List.Push_back('A'); Print(List); cout &lt;&lt; "加入B" &lt;&lt; endl; List.Push_back('B'); Print(List); cout &lt;&lt; "修改下标为1的B为G" &lt;&lt; endl; List.SetElement(1, 'G'); Print(List); cout &lt;&lt; "加入C" &lt;&lt; endl; List.Push_back('C'); Print(List); cout &lt;&lt; "加入D" &lt;&lt; endl; List.Push_back('D'); Print(List); cout &lt;&lt; "在下标为2的位置插入O" &lt;&lt; endl; List.InsertElement(2, 'O'); Print(List); cout &lt;&lt; "删除下标为1的G" &lt;&lt; endl; List.DeleteElement(1); Print(List); cout &lt;&lt; "寻找M的下标为： " &lt;&lt; List.find('M') &lt;&lt; endl; cout &lt;&lt; "清空了所有元素" &lt;&lt; endl; List.DeleteAllElement(); cout &lt;&lt; "加入F" &lt;&lt; endl; List.Push_back('F'); Print(List); cout &lt;&lt; "寻找A的下标为： " &lt;&lt; List.find('A') &lt;&lt; endl; cout &lt;&lt; "在下标9位置插入G" &lt;&lt; endl; List.InsertElement(9, 'G'); Print(List);&#125; —(本文完)&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大学学习个人计划及路线规划]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E5%8F%8A%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! U2FsdGVkX1+6JxBtQMLH3e2oGhxHH0apJh2wu0I8SpEOLcGdiTcerxHrpjg8AcZZ47MBybAZ/mvFDa8xO8Ujed3JhPpElmrVYCtxaljuy01HSccQJq8KiBHLPVD6H9rMHlnxRlX3VuNUosANV9qXoKFM1E78pWyA1Aba1Tp/1dLtG2TLaIvjPKWMg4CFKEtXxGUyekIvahwo26TDtAqauRUNRKDyOPhZqsa51yE57MnCTtek5hc+Ml7OOY/hc+NPO+g5pIQkAD6dc5xgbG+oA9LD7PKwfQJoBaBAnladn33BEG0RP0UnAVtNoXlIN8i0iX2x3UFgvjIfxvKnHEGW7yN0LDgCF2IqjjbffIhgoh5GrtDCKgR8yIEUuwzUCjYGx24JaWnk136G8AWXVuW9VzBwsnWLNILPYh3UPdgDBUJzCzzstXy1Aj7xPJSQQBjFYoIjuspm2CcJDyllg1Ux1MdqhcKtEYpxjWqq/6P3Lr5nArLwWOgHll/q6XPmV4MhmyGO6J9t6xLz9mB2UPXrwxHLPy534Ne+YYx7KwM8KtmbLN+ra7r33HthNbwqgYO0cEvoh8D996AxRfzNBlkouANzTv95VZMkxuoxQYxn+MO1HUP5CQuG8crw4ifB5uXWcHMaOU0OehYJIXlnyUGQ7E7XG/oXk5slWlIVGeH8yKsBTkGwofz9Ic+HSaxBrLmjEPcR9DOeEFAunNFYnd9xpnuRMB0xA/EF2W1TmPReKuTQ66aXKyw7FwV5QNzDgDJjpkLhENM3BgQID5POYlDJvhLEqNHEe8t6GvQ5M4S8oAKphuazf4kVm0GYQRACGzSD+IQFqQuixIdfqG7U+dHXfDf7OEGDm8BZf+L5kvjqJWacnnjZhbbLzO8c/OlTDvxOVZOYjZoCntb6KL2MTdFPQi8DWEYzxQWub951h/bCaYc9MDnLbHVdZpZiaqCVi9v9sgxvQKEa1xFNKVajI78kVzii1nXsCwl20FsRxIqb6EoNXxoJx08+ArPSeum9qiM4mD7lapz1+goWSntN2UlYckamoxFEJIiXnHbBLYpM7ysFb2I4oHCcWa7UnyObG4xoUlrOA5k6qFMdDNXVGG9pJv+SKWxtA+jDa1qZ/uxQQZZ7XglAlvWMsK3n2JpOoWIi3gzD43qXQleoxdmd1a7vBTFF44lEKCV5o1SlI+oc33blBBJVl0nD+LU51s5uSAjRLJb4076OPbQ0ffo9iIkrlNQQveaPNDLgobDO5RxBBD2j9jTWHiFL5U5b5zzuvk1DoLtRKd3bbdeOFSpzfHUmDw==]]></content>
      <categories>
        <category>个人随感</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
        <tag>目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.2）顺序表存储结构]]></title>
    <url>%2F2019%2F06%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882.2%EF%BC%89%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[顺序表结构 顺序存储结构的线性表—顺序表 定义：指的是用一段地址连续的存储单元依次存储线性表的数据元素（数组） 顺序表的构成 需要定义线性表的最大存储空间 define int Max_SIZE = 255; 线性表里需要有统一类型的元素集合 12345678910111213141516#define int MAX_SIZE = 255;//最大存储长度 /*定义线性表*/typedef int ElemType;//给int起一个别名 ElementTypetypedef struct&#123; int num;char* name;&#125;ElementType;/*定义顺序表结构*/typedef struct &#123; ElementType Datas[MAX_SIZE]; int length;//当前长度&#125;SeqList; —(本文完)&lt;待完善&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[石膏球（练习）]]></title>
    <url>%2F2019%2F06%2F14%2F%E7%9F%B3%E8%86%8F%E7%90%83%EF%BC%88%E7%BB%83%E4%B9%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>绘画</category>
        <category>练习</category>
      </categories>
      <tags>
        <tag>绘画练习</tag>
        <tag>素描</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习心得体会]]></title>
    <url>%2F2019%2F06%2F14%2FJava%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[​ 先简单说一下我对于编程这一门课程个人感受吧，编程说难也难，但说它简单也不过分。难，难在程序编写过程的中的思考方式。简单，就简单在一旦你掌握了基本语句和方法的基础下，有着一个活跃的思维思考能力，程序编程基本都是水到渠成的事。接下来我就简单说下我个人对于Java学习过程中一些心得和学习方法供大家参考一下吧。 心得：​ 首先我在大一是有接触过C++的，刚拿到课本也是一头雾水，看不明白。但在深入学习后，我认为掌握一门程序语言重要的不是知道它具体的语法和规则，而是运用这些语法和规则时的思维。为什么编程的思维很重要呢？这是一个很现实的问题，如今知识更新快，社会发展非常快，意味着编程语言的变化也是很无常的，或许你刚掌握了java语言，市场上就有了更好的编程语言。这就意味着你要继续学习新的语言和知识，如果此时你有一个活跃的编程思维，去接触新的语言学会它会非常容易。 说了这么多思维很重要，那编程思维到底是怎样的？举个小例子：假设你要编程一个超市商品结账的程序，先不要想怎么去编写它。先去思考一下，假如你在超市工作并给一个顾客买的两个东西结账。结账时你要做的事情：你要先识别他买的两个东西单价分别是多少钱，买了多少个，总金额多少，付钱结账最后打印一个小票给这个顾客。简化下来就是：1.识别物品，2.计算金额3.打印信息。好的！接下来用编程来搞定它，1.识别物品从你一大堆的商品信息中找到这个商品的信息。怎么编这个功能？用循环被一个个找。找到同名的商品并得到它的金额信息就可以了。2.计算金额 用循环累加，3.打印出信息 完成本次结账，程序结束。从上面可以看出编这个程序思考方向：明确你程序要干的事情是什么（目的是结账），干这个事情有什么动作（1.识别食品找到对应的价格2.计算总金额3.打印信息），完成这些动作要用什么方法（1.可以用循环来找或其他方法2.每一项金额累加3.打印上面步骤得到的数据信息）。你能在看见一个动作就能想到一个方法去解决它。这就要靠活跃的思维，怎么样用你所学到的编程规则与语句对应想出编写针对它解决它的方法，这就是一个编程的思维。 学习方法：​ 根据上文所述的思维的方式我说下我自己的学习方法供大家参考。 根据自己的想法用自己的话去总结每一章学习的知识：这里要注意！自己每次学习完一章内容尽量地去总结且一定要根据自己的话和自己的思考去总结不能网上复制粘贴一下概念知识。这样做有两个好处：①加固加深你所学的知识，毕竟是根据自己思考后总结出来的、②培养独立的学习思考能力（说白了就是把你学到的知识用自己的理解写一个类似于教材的总结）。 建立编程错误库：其实很多人在编程的时候都会遇到红标报错，这是很正常的事情我们本来就是在试错中才能积累经验。你每一次出错，如果你有时间可以编写一个文档计入每一次遇到的新的报错 并且记录下错因是什么 怎么去解决，这样遇到同样的错误就会有条件反射：“哦！我以前犯过NullPointException的错误，这个错误是空指针错误，原因是有一个对象没有给它空间，应该调用它的构造方法去解决它。”慢慢的就会有独立去解决这些错误的能力了。当然如果你没有多余的时间，也可以让自己的脑子去记下来QWQ。 找个好（ji）朋友进行讨论和思维碰撞：单干是很寂寞的。可以找一个好朋友、舍友进行思维碰撞和讨论。这也很重要！为什么，因为每一个对同一个问题的思考方式、方向都不可能完全相同的。通过思维的交汇，朋友间能相互提高且提高的跟快。再者可以有效的避免一些舍友之间的矛盾。 兴趣主导目标引领：有一个学习目标是很重要的，当然这得取决你不会去排斥它，就如编程。你主动爱它虽然它不会爱你_(:з」∠)_。但你排斥它，它也一定会排斥你这也是必然的。所以学好一门课首先是要培养出对它的兴趣，然后java语言与其他编程语言一样，学习它时候是要用大量的课余时间去练习它。练习也是要有目的的，你可以就按每次作业的要求去学习它，在完成作业后，你也可以自己想一点小玩意供自己去练习。例如：你看见你去钱用的很乱，你就会想编一个记账的小程序，然后就有一个目标出现了。你就会根据你的小目标去主动学习主动搜索你所需要的知识。学习一门课程，只要你站在主动的一方，一切问题就非常好解决了。 从初学就养成良好的编码习惯：这里有些人可能有点疑问，码是我编的，我想咋编就咋编我看得懂就ok这样的思想是很错误的。首先这样做DEbug会非常辛苦，现在是小程序可能体会不出来，当你编写几百行几万行以上的代码就会痛苦的不得了。（个人亲试过：你体验过自己编了700多行代码的程序，de一个bug蹦出一堆bug的快感吗？）。这里我非常推荐一点要写注释！特别是自己想的方法。这样做有两个好处：①这样你编写这个方法的时候思路会比较明确，知道每一步要怎么去做。 ②.对于以后工作写文档会有用处，未来的代码是要给别人看的。 然后我提一点其他的好习惯吧。㈠定义变量的时候命名让它有意义，且在定义的时候一个变量占一行，有关联的变量尽量相近定义。㈡善用回车换行，这里举一个简单的例子吧。每个方法尽量用两个回车来分开。这样做，一是方便注释，二是方便分辨每一个方法体，且美观。这里要注意回车换行适度就行，不宜太多。其他方法可以搜索网上资料。这里就不一一叙述了。养成良好的编程习惯一是方便你自己，二来也对未来工作有非常大的帮助。 尽量先靠自己去想怎么做：不要一遇到不会就百度、参考其他同学的代码。切记！有人会说，参考后我会自己去理解，之后也不是会变成我自己的知识吗？这样说吧：这样做好比你在海上航行，你知道答案了就像你知道目的地的准确位置了，接下来你只需把船开过去即可，但正常情况下，你应该要靠自己的能力去找目的地而不是知道它在哪的前提下去航海。未来工作也是这样。一个是逆向思考，另一个是正向思考。两者是不一样的。所以我们一定要先独立思考。直到真的完全不会了再去参考学习。每次都参考别人的东西去学习，会导致一个依赖感长期的逆向思考，到了真的要自己动手的时候发现一点都不会。这也解释了一些同学看得懂代码，自己动手却什么都不会的原因。 ​ 最后我先明确我的这些理解和见解只供大家去参考。我的一些理解和心得可能没有你们的好，学习方法或许你的也会更棒。所以不要太局限于我的见解QAQ。 —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>个人随感</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>心得体会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.1）线性表的抽象数据类型]]></title>
    <url>%2F2019%2F06%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882.1%EF%BC%89%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[线性表 定义： 零个或多个数据元素的有限序列。 特点: 它是一个序列 数据元素之间是有有序的。 数据元素之间是一对一的关系。 有限性 两个数据元素的有限序列称为空表。 常见线性表的操作： 删除 插入 创建 初始化 清空 查找 线性表的抽象数据类型 ADT 线性表(List) Data 线性表数据元素是一个集合{a_1 , a_2 , a_3 , …. , a_n},数据元素的类型DataType（int , char ,…)。 除了第一个（a_1）元素外，每个元素有且只有一个直接的前驱元素。 例如 : a_2的前驱元素是a_1。 除了最后一个（a_n）元素外，每一个元素有且只有一个直接的后继元素。 例如: a_3是a_2的后继元素。 Operation InitList（*List） 初始化线性表：创建一个空的线性表List InsertElement（*List ， index ， e） 在线性表List的index下标处插入元素e DeleteElement（List ， index， e) 删除线性表List中的第i个元素，并返回删除元素指针e GetLength（*List） 获得线性表的长度 IsEmpty（*List） 判断线性表是否为空表 ClearList（*List） 清空线性表 ExsitElement（*List ， e） 查找线性表中的元素e endADT 个人理解：​ 在实际上，线性表可以理解为一群人在排队，排队的都是人（数据元素类型相同），然后他们是排成一条线的。首先排队的人肯定是有限的（即：有限性）其次他们每一个人是相互连成一条线的，即一个人跟着一个人有顺序（即：一对一、有序的）。 ​ 再者，这队排队的人，除了第一个人前面没人，最后一个人后面没人外。其中每一个人都是前后都有人的。例如第二个人的前面是第一个人（即：第一个人为第二个人的前驱元素），而第三个人是第二个人的后面（即：第三个人为第二个人的后继元素）。 ​ 这队排队的人是在等待上车的。他们之间可能会有人在中途想上厕所从而离开了队伍（即：删除），又或者有人在后面加入进去了（即：增加），这时检票员也会一一核对信息对照人员表查找每一个人是否到齐了（即：查找），这时上厕所的人回来了因为这队人是有顺序的，所以这位回来的也可以插入原来的位置（即：插入）。 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2）第二章预习]]></title>
    <url>%2F2019%2F06%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882%EF%BC%89%E7%AC%AC%E4%BA%8C%E7%AB%A0%E9%A2%84%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[问题： 线性表的顺序存储的优点和缺点有哪些？ 线性表的删除和插入算法的思路？ 数组长度和线性表长度的区别？ 顺序存储结构的三大属性？ —（本文未完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-(1.2)抽象数据类型]]></title>
    <url>%2F2019%2F06%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%881.2%EF%BC%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[抽象数据类型数据类型 定义： 计算机中，内存空间是最有限的，不同的类型的数据分配的内存空间大小不同。 例如：在C++ 中 整型占4个字节，双精度浮点数占8个字节等等 数据类型就是指一组性质相同的值和集合及定义在此集合上的一些操作的总称 例如在C/C++语言中的数据类型中是按取值不同分类的数据类型 原子型（不可再分）：不可再分的数据类型。例如：int(整型)、double（双精度浮点型）等等 结构型（可再分）：若干个数据类型（包括原子型和结构型）组成的一个组合。例如：数组，类，结构体（C/C++）等。 抽象数据类型（Abstruct Data Type[ADT]) 定义：是对已有的数据类型进行抽象 抽象数据类型是指一个数据**模型**及定义在该模型上的一组操作 - 模板： ADT 抽象数据类型名 Data 数据元素之间的逻辑关系的定义 Operation 操作1 初始条件 操作结果描述 操作2 … 操作n … endADT 个人理解：通过套用上面的模板 解释int（整型数据类型） int（整型） 是以线性结构存储一个int（整型）数据类型占4个字节 Operation 操作1：加法 需要两个数 结果为两个数的和 操作2：减法 需要两个数 结果为两个数的差 操作3：乘法 … 操作4：除法 … 个人总结： 用自己的话简述下列术语： 数据：类似一个或几个人的全部基本信息（姓名、性别、爱好等）。 数据元素：人基本类型里面的单一个姓名、性别等。 数据对象：单一个人的基本信息。 数据结构：数据通过一定的结构、关系（计算方法【算法】）存储起来就是数据结构 例如：上面所说的数据 —多个人的基本信息 一般是用列表格的形式存储的，即所用的是线性逻辑结构存储的。 存储结构（物理结构）：是对逻辑结构在计算机上的表示。即对上面的数据结构在计算机进行实习，如果是顺序存储结构，那么这些个人基本信息可能是用数组储存起来的。 数据类型：例如 整型、浮点型就是一个数据类型，数据类型是一组相同值和其每个值之间特有的关系上的操作的总称。例如整型，它每一个数据元素都是一个整数，他们可以进行加减乘除等操作。 抽象数据类型：类似于数据类型，但是把一些东西抽象化成数据类型。例如游戏角色，它的数据元素（对比就是整型里面的整数）有很多，例如武器、玩家属性等、这个数据类型可以执行的动作有移动攻击等。 数据结构和抽象数据类型的概念与程序设计语言中的数据类型概念的区别 抽象数据类型是对软件设计过程中问题模型抽象出来的逻辑结构和在逻辑结构上的运算。 数据结构是计算机处理元素的组织形式的相互关系。 程序设计语言中的数据类型是已经实现了的数据结构。 即：一个还没有被实现（抽象数据类型）一个是已经实现的了（程序设计语言中的数据类型） 而数据结构是指： 数据的相互之间存在一种或多种特点关系的数据元素的集合。 --（本文完）&lt;待完善&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java模拟考心得体会]]></title>
    <url>%2F2019%2F06%2F12%2FJava%E6%A8%A1%E6%8B%9F%E8%80%83%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[今天进行了Java期末考试的模拟考，颇有心得与感触，以本文进行叙述：遇到的问题比较多：例如 &gt;&gt; 与 &gt;&gt;&gt;运算符 这里的意思是这样的 &gt;&gt;有符号的右移这是对二进制的数来说的 int i=8，那么 i &gt;&gt; 2就是二进制往右移两位，即：（0）1000【8】 往右移两位就是 （0）0010【2】，而&gt;&gt;&gt;就是不考虑符号位。 jpane的默认布局是流式布局 （我居然写BorderLayout） 其次是swing包里面的 按钮监听器不太熟 警示： 千万不要在程序设计或填空 题目里面用Shift + F 格式化 切记切记！！ 其他知识点： 按钮监听器重写方法：public void actionPerformed(ActionEvent event) 对于子类可以从父类继承的成员变量，只要子类中声明的成员变量和父类中的成员变量同名时，子类就隐藏了继承的成员变量，子类自己声明定义的方法操作与父类同名的成员变量是指子类重新声明定义的这个成员变量。 —（本文完）]]></content>
      <categories>
        <category>个人随感</category>
      </categories>
      <tags>
        <tag>心得体会</tag>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（1.1）数据结构的基本概念]]></title>
    <url>%2F2019%2F06%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%881.1%EF%BC%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[数据结构的基本概念五个基本概念：数据 定义：描述客观事物的符号，是计算机中可以操作的对象。 个人理解：类似于整型，或者一个文件都是可以看出数据。实际情况：例如我输入的账号密码就算是为数据 数据元素 定义：组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。 数据元素是数据结构的聚焦点 个人理解：把数据比喻成一个文件夹，那么数据元素就应该是里面的一个不可分的文件（高达模型上面的一个零件？）。 数据项 定义： 一个数据元素可以由若干个数据项组成。 个人理解 ： 数据元素比作对象，那么数据项就类似于对象的属性（成员变量）。例如：上面输入信息时，用户名和密码分别就算是数据项 数据对象 定义： 性质相同的数据元素的集合，是数据的子集。 个人理解：这个应该是介于数据和数据项中间的东西 数据结构（data structure） 定义：数据结构是相互之间存在一种或多种特定关系的数据元素的集合。 数据元素 + 特定关系 = 数据结构 总结：用实际情形来描述，你在一个网站上进行注册，要求填写个人形象，其中里面的姓名、密码就是 数据项 ，每一个数据项组成的就是一个 数据元素 ，数据元素一多起来就统称为：数据 逻辑结构 集合结构 图形结构（图） 树形结构（皇帝与丞民） 线性结构 物理结构 定义：又叫存储结构，是指数据的逻辑结构在计算机中的存储形式。 顺序存储结构 ：类似于数组 ，把数据元素存储在地址连续的储存单元里。 链式存储结构 ：把数据元素存放在任意的存储单元里 类似于数组，但可以不连续，每一个数值直接有一个类似于绳子或链条的东西相互绑定。 类似指针 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[石膏立方体（练习）]]></title>
    <url>%2F2019%2F06%2F11%2F%E7%9F%B3%E8%86%8F%E7%AB%8B%E6%96%B9%E4%BD%93%EF%BC%88%E7%BB%83%E4%B9%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>绘画</category>
        <category>练习</category>
      </categories>
      <tags>
        <tag>绘画练习</tag>
        <tag>素描</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[置顶]欢迎来到ShuHaoHwang的博客！！]]></title>
    <url>%2F2019%2F06%2F11%2F%5B%E7%BD%AE%E9%A1%B6%5D%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%9C%AC%E5%8D%9A%E4%B8%BB%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%81%EF%BC%81%2F</url>
    <content type="text"><![CDATA[本博客将先会以个人的学习总结为主，之后将更新一些技术性的文章，欢迎与博主进行探讨、一起思维碰撞。在吉珠的小伙伴还可以联系博主哦！ 欢迎留言，博主在有空之余将一一进行查看并回复。]]></content>
  </entry>
</search>
