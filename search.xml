<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.9）顺序存储结构与链式存储结构的逆置]]></title>
    <url>%2F2019%2F06%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-9%EF%BC%89%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E9%80%86%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[顺序结构的逆置算法与思路： 夹逼法： 思路：通过对数组头部和尾部相互对调并向中间靠近。 实现：(假设以整型为数据类型实现) 12345678910//length为顺序表总长度。bool Convert()&#123; int temp;//用来对换位置时使用的临时变量 for(int i = 0; i &lt; length/2; i++)&#123;//注意：length要除于2！！！！length要除于2！！！！ temp = datas[i]; datas[i] = datas[length - 1 - i];//前后换位置并向中间靠近 datas[length - 1 - i] = temp; &#125; return true;&#125; 注意：这里的length是要除于2的，因为只需向中间靠近即可而不是再往中间远离。即：移动的范围只是数组长度的一半。 算法优化： 12345678910//length为顺序表总长度。bool Convert()&#123; int temp;//用来对换位置时使用的临时变量 for(int i = 0 ，j = length - 1; i &lt; j; i++,j--)&#123; temp = datas[i]; datas[i] = datas[j];//前后换位置并向中间靠近 datas[j] = temp; &#125; return true;&#125; 此方法更能体现夹逼法。 链式存储结构的逆置算法与思路： 思路：把头结点和数据结点断开，然后把数据结点一个个前插进链表。（循环链表和单向链表均适用）,具体做法先让一个结点指针p保存第一个数据的地址，然后让头结点的next指针归零（即：使其与数据结点断开），开始循环：让一个临时指针指向p的下一个数据的地址，然后把这个第一个数据插入头结点后面（此时p指向为第一个数据的地址），即：p-&gt;next = head-&gt;next;head -&gt;next = p;其次移动指针p到下一个数据，这里就要运用到一开始的临时指针了。循环上面的操作，直到把所有数据都前插完毕。 实现1(单向链表)： 12345678910111213141516bool Convert()&#123; LNode* p = head-&gt;next; LNode* temp = nullptr;//临时指针 head-&gt;next = nullptr; while(p)&#123; temp = p-&gt;next;//获取下一个数据的值 p-&gt;next = head-&gt;next;//前插 head-&gt;next = p; p = temp;//移动指针到下一个数据 &#125; return true;&#125; 实现2(循环链表) 12345678910111213141516bool Convert()&#123; LNode* p = head-&gt;next; LNode* temp = nullptr;//临时指针 head-&gt;next = nullptr; while(p!=head)&#123; temp = p-&gt;next;//获取下一个数据的值 p-&gt;next = head-&gt;next;//前插 head-&gt;next = p; p = temp;//移动指针到下一个数据 &#125; return true;&#125; 前后只是循环条件发生变化。 –（本文完）&lt;原创&gt;&lt;待增添修改&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.8）线性表的顺序存储结构和链式存储结构之间的比较]]></title>
    <url>%2F2019%2F06%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-8%EF%BC%89%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[顺序结构与链式结构的比较： 顺序结构 链式结构 按序号下标读取 直接读取通过A[index]即可获的数据+++ 要从头开始找，找的下标才能获取数据— 内存实验 要先规定好顺序结构的长度，可能没有利用好空间或空间不够用，不够用时还要扩容可能没有足够的空间或多出空间— 按需要分配，想要一个就一个可利用很小的碎片空间+++ 插入元素 插入一个元素需要不断移动后面的元素，速度慢，消耗相比大— 直接插入，速度快，消耗相比小+++ 删除 需要移动元素— 直接删除+++ –（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（1.3）范围for语句、动态分配、nullptr]]></title>
    <url>%2F2019%2F06%2F21%2FC%2B%2B%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%881-3%EF%BC%89%E8%8C%83%E5%9B%B4for%E8%AF%AD%E5%8F%A5%EF%BC%8C%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[此文章是加密文章，请输入密码后查看. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.7）双向链表]]></title>
    <url>%2F2019%2F06%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-7%EF%BC%89%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[双向链表 与单向链表的不同之处： 单向链表 双向链表 只知道后继节点，不知道前驱节点。每次查找只能从头开始查找。 相比单向链表增加了一个前驱指针，使前驱节点很快就能被找到 双向链表由于有了前后指针。可以使其从前往后走，也可以从后往前走。 根据双向链表具有前后两个指针的这个特性 在插入算法和删除算法中都有很好的优势 插入算法： 12345678910111213141516171819202122bool InsertElement(int index, T e) &#123; LNode* node = new LNode(); LNode* p = head; node-&gt;data = e; int j = 0; while (j &lt; index)//直接定位到要插入的位置即可 &#123; p = p-&gt;next; j++; &#125; p-&gt;prior-&gt;next = node;//指定位置的前一个数据的next指针指向新插入的数据地址 node-&gt;prior = p-&gt;prior;//新插入数据的prior指针指向原来位置数据的前一个数据地址 p-&gt;prior = node;//插入位置的前一个数据更变为新插入的数据地址 node-&gt;next = p;//新插入数据的next指针指向插入位置的地址 length++;//链表总长度加1 return true; &#125; 删除算法 12345678910111213141516bool DeleteElement(int index) &#123; LNode* p = head; int j = 0; while (j &lt; index)//直接定位到要删除的数据结点 &#123; p = p-&gt;next; j++; &#125; p-&gt;prior-&gt;next = p-&gt;next;//待删除的数据的前一个数据的next指针指向待删除数据的下一个数据的地址 p-&gt;next-&gt;prior = p-&gt;prior;//待删除数据的下一个数据的prior指针指向待删除数据的前一个数据 delete p;//释放待删除数据的空间 return true; &#125; 删除算法即可以直接跳过待删除数据结点。 其他测试代码详情：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;class BSLkList &#123; struct LNode &#123; T data; LNode* next; LNode* prior; &#125;; LNode* head; LNode* rear; int length;public: BSLkList() &#123; head = new LNode(); head-&gt;next = head; head-&gt;prior = head; rear = head; length = 0; &#125; /*后插操作*/ bool Push_back(T e) &#123; length++; LNode* node = new LNode(); LNode* p = head; if (!node) return false; while (p-&gt;next != head) &#123; p = p-&gt;next; &#125; node-&gt;data = e; p-&gt;next = node; node-&gt;next = head; node-&gt;prior = p; rear = node; return true; &#125; /*插入操作*/ bool InsertElement(int index, T e) &#123; LNode* node = new LNode(); LNode* p = head; node-&gt;data = e; int j = 0; while (j &lt; index) &#123; p = p-&gt;next; j++; &#125; p-&gt;prior-&gt;next = node; node-&gt;prior = p-&gt;prior; p-&gt;prior = node; node-&gt;next = p; length++; return true; &#125; /*删除操作*/ bool DeleteElement(int index) &#123; LNode* p = head; int j = 0; while (j &lt; index) &#123; p = p-&gt;next; j++; &#125; p-&gt;prior-&gt;next = p-&gt;next; p-&gt;next-&gt;prior = p-&gt;prior; delete p; return true; &#125; /*遍历操作*/ void Traverse(void(*fb)(T&amp; e)) &#123; LNode* p = head-&gt;next; while (p != head) &#123; fb(p-&gt;data); p = p-&gt;next; &#125; &#125; /*指定位置遍历操作*/ void Traverse(T e, void(*fb)(T&amp; e)) &#123; LNode* s = GetDataAddress(e); LNode* p = s; do &#123; if(s!=head) fb(s-&gt;data); s = s-&gt;next; &#125; while (s != p); &#125; private: /*获得指定结点地址操作*/ LNode* GetDataAddress(T e) &#123; LNode* p = head; while (p-&gt;next != head) &#123; if (p-&gt;data == e) return p; p = p-&gt;next; &#125; return NULL; &#125;&#125;;template&lt;typename T&gt;void Print(T&amp;e) &#123; cout &lt;&lt; e &lt;&lt; " ";&#125;int main() &#123; BSLkList&lt;char&gt; list; cout &lt;&lt; "后插入了一个A数据" &lt;&lt; endl; list.Push_back('A'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后插入了一个B数据" &lt;&lt; endl; list.Push_back('B'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后插入了一个C数据" &lt;&lt; endl; list.Push_back('C'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; "在2号位置插入了一个p数据" &lt;&lt; endl; list.InsertElement(2, 'p'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "在2号位置插入了一个p数据" &lt;&lt; endl; list.InsertElement(2, 'p'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; "删除了3号位置的数据" &lt;&lt; endl; list.DeleteElement(3); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "删除了1号位置的数据" &lt;&lt; endl; list.DeleteElement(1); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; "从B数据开始遍历" &lt;&lt; endl; list.Traverse('B', Print); cout &lt;&lt; endl;;&#125; 测试效果图： –(本文完)&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.6.1）附加：循环链表的优点之从指定结点开始遍历]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-6-1%EF%BC%89%E9%99%84%E5%8A%A0%EF%BC%9A%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E7%82%B9%E4%B9%8B%E4%BB%8E%E6%8C%87%E5%AE%9A%E7%BB%93%E7%82%B9%E5%BC%80%E5%A7%8B%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[体现循环链表的优点之从指定结点开始遍历​ 上一篇总结文章介绍了循环链表的基本概念和个人理解，但我觉得能很好区分非循环链表和循环链表初了链表的合并，还有一个就是循环链表可以从指定的结点开始遍历整个链表，这是非循环链表所做不到的。非循环链表每次遍历只能从头一个个开始遍历每一个元素，而循环链表就不同了，因为它的尾部是与头部相连的，这样就可以实现从某一个结点开始就可以遍历到链表每一个结点上，大大提高了效率。 这里通过遍历函数来体现这一特性。 123456789101112131415161718192021222324252627282930313233//查找链表中的某一个元素并获得它的地址LNode* GetDataAddress(T e) &#123; LNode* p = head-&gt;next; while (p != head) &#123; if (p-&gt;data == e) return p; p = p-&gt;next; &#125; return NULL; &#125;/*从某一个结点进行遍历*/ void Traverse(T e,void(*fb)(T&amp; t)) &#123; LNode* p = GetDataAddress(e);//获得指定结点的地址 LNode* q = p; if (!p) &#123; cout &lt;&lt; "链表为空" &lt;&lt; endl; return; &#125; do &#123; if(p!=head)//越过头结点 fb(p-&gt;data); p = p-&gt;next; &#125; while (p != q); &#125; 思路：先获得指定结点的地址先记录下来，并再用一个指针记下这个位置（便于判断）。其次这里使用的是do-while循环结构（使用do-while循环可以避免while循环漏遍历一个指定结点的数据），先调用函数指针的内容，然后移动指针p。直到指针p再次等于原来的指定结点的地址就停止。 具体实验代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;class CLkList&#123; struct LNode &#123; T data;//数据 LNode* next;//指向下一个数据的指针 &#125;; LNode* head;//头指针 LNode* rear;//尾指针 int length;public: /*构造函数*/ CLkList() &#123; head = new LNode(); length = 0; if (!head)throw"No Memory";//若没有new出来就抛出异常 head-&gt;next = head; rear = head-&gt;next; &#125; /*后插入操作*/ bool push_back(T e) &#123; length++; LNode* p = head-&gt;next; LNode* q = new LNode(); while (p-&gt;next != head) &#123; p = p-&gt;next; &#125; if (!p)return false; q-&gt;data = e;//进行data赋值 rear = q; q-&gt;next = head; p-&gt;next = q;//原最后一个元素数据的next指向这个新插入的空间地址 //length++; return true; &#125; /*获得指定结点地址操作*/ LNode* GetDataAddress(T e) &#123; LNode* p = head-&gt;next; while (p != head) &#123; if (p-&gt;data == e) return p; p = p-&gt;next; &#125; return NULL; &#125; /*遍历操作*/ void Traverse(void(*fb)(T &amp; t)) &#123; LNode* p = head-&gt;next;//从头结点开始遍历每一个元素的data while (p != head) &#123; fb(p-&gt;data); p = p-&gt;next; &#125; &#125; /*从某一个结点进行遍历*/ void Traverse(T e,void(*fb)(T&amp; t)) &#123; LNode* p = GetDataAddress(e);//从头结点开始遍历每一个元素的data LNode* q = p; if (!p) &#123; cout &lt;&lt; "链表为空" &lt;&lt; endl; return; &#125; do &#123; if(p!=head) fb(p-&gt;data); p = p-&gt;next; &#125; while (p != q); &#125;private:&#125;;template&lt;typename T&gt;void Print(T&amp; e) &#123; cout &lt;&lt; e &lt;&lt; " ";&#125;int main() &#123; CLkList&lt;char&gt; list; cout &lt;&lt; "后面插入了一个a数据" &lt;&lt; endl; list.push_back('a'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个b数据" &lt;&lt; endl; list.push_back('b'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个c数据" &lt;&lt; endl; list.push_back('c'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个d数据" &lt;&lt; endl; list.push_back('d'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "从b数据开始遍历链表； " &lt;&lt; endl; list.Traverse('b', Print); cout &lt;&lt; endl; cout &lt;&lt; "从c数据开始遍历链表； " &lt;&lt; endl; list.Traverse('c', Print); cout &lt;&lt; endl; &#125; 运行结果： 小结：​ 这里只是单单用遍历体现了循环链表的这个特点。 ​ 其实不单单在遍历操作上，这个更可以在查找操作上体现出这个优点，例如：在指定结点开始寻找其后的某个值、删除操作也可以运用上。 –（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.6）循环链表（单向链表）、清空链表与销毁链表]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-6%EF%BC%89%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[循环链表 相较于非循环链表 在非循环链表中，最后一个元素的next指针是空指针，造成浪费。 每次寻找后继指针的时候都要重新从头开始找。 循环链表 尾指针直接指向表头，使最后一个元素的next指针被利用起来。 从每一个元素开始都能遍历表中每一个元素。 便于类似于链表合并这样的算法实现。 其他不同： 循环链表与非循环链表的判断条件发生了变化 判断的具体解释（循环链表） 判断到前驱结点： 1234while (p-&gt;next != head) &#123; p = p-&gt;next; &#125; ​ 因为最后一个结点的next指针不再是空指针而是一个指向head的指针，所以在while循环中如果p的next指针下一个为head指针那么这时指针p就定位到head的前驱指针了。 判断到头结点： 1234while (p != head) &#123; p = p-&gt;next; &#125; ​ 这个也很好判断，不断移动指针p当等于头结点时就跳出循环，此时p定位到头结点。 循环链表的尾指针 循环链表通常是有一个尾指针的它指向的是最后一个元素的地址。 尾指针的好处： 找head指针非常方便。rear-&gt;next的值便是head。 便于链表的合并。 代码实现空表时的尾指针： 1234567891011121314151617181920212223class CLkList&#123; struct LNode &#123; T data;//数据 LNode* next;//指向下一个数据的指针 &#125;; LNode* head;//头指针 LNode* rear;//尾指针 int length;public: /*构造函数*/ CLkList() &#123; head = new LNode(); length = 0; head-&gt;next = head; rear = head-&gt;next;//空表时的尾指针 &#125;&#125; 当插入一个元素后尾指针的变化 123456789101112131415161718192021//从链表最后面插入元素bool push_back(T e) &#123; length++; LNode* p = head-&gt;next; LNode* q = new LNode(); while (p-&gt;next != head) &#123; p = p-&gt;next; &#125; if (!p)return false; q-&gt;data = e;//进行data赋值 rear = q;//因为是从最后面插入那么此时这个最后一个元素的的地址是尾指针指向的 q-&gt;next = head; p-&gt;next = q;//原最后一个元素数据的next指向这个新插入的空间地址 return true; &#125; 链表合并的实现: 具体思路（链表2合并到链表1）：先获得链表2的头结点的地址（即：链表2的指针head）然后让链表1的head指针指向链表2的指针head-&gt;next指向的地址（即：链表2的第一个元素的地址），然后让链表2的指针rear（尾指针）指向链表1的head-&gt;指向的地址（即指向链表1的第一个元素）最后delete 链表2的head指针。完成合并操作。 合并前： 合并后： 具体实现： 1234567891011121314bool ListCombine(CLkList* s) &#123; LNode* t_head_of_s = s-&gt;head;//获得链表2的head指针 s-&gt;rear-&gt;next = head-&gt;next;//让链表2的尾指针指向链表1的第一个元素 head-&gt;next = t_head_of_s-&gt;next;//让链表1的head-&gt;next指针指向链表1第一个元素 delete t_head_of_s;//释放原链表2的head指针 return true;&#125; 循环链表具体代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;class CLkList&#123; struct LNode &#123; T data;//数据 LNode* next;//指向下一个数据的指针 &#125;; LNode* head;//头指针 LNode* rear; int length;public: /*构造函数*/ CLkList() &#123; head = new LNode(); length = 0; if (!head)throw"No Memory";//若没有new出来就抛出异常 head-&gt;next = head; rear = head-&gt;next; &#125; /*往后插入操作*/ bool push_back(T e) &#123; length++; LNode* p = head-&gt;next; LNode* q = new LNode(); while (p-&gt;next != head) &#123; p = p-&gt;next; &#125; if (!p)return false; q-&gt;data = e;//进行data赋值 rear = q; q-&gt;next = head; p-&gt;next = q;//原最后一个元素数据的next指向这个新插入的空间地址 //length++; return true; &#125; /*获得链表长度*/ int GetLength() &#123; return length; &#125; /*插入元素操作*/ bool InsertElement(int index,T e) &#123; LNode* p = head; LNode* q = new LNode(); int j = 0; while ( j &lt; index-1) &#123; p = p-&gt;next; j++; &#125; q-&gt;data = e; q-&gt;next = p-&gt;next; p -&gt; next = q; length++; return true; &#125; /*删除操作（下标型）*/ bool DeleteElement(int index) &#123; LNode* p = head; LNode* q = head-&gt;next; int j = 0; while (j &lt; index-1) &#123; p = p -&gt; next; q = q -&gt; next; j++; &#125; p-&gt;next = q-&gt;next; delete q; length--; return true; &#125; /*删除操作（找值型）*/ bool DeleteElement(T e) &#123; LNode* p = head; LNode* q = head-&gt;next; while (q != head) &#123; if (q-&gt;data == e) &#123; p-&gt;next = q-&gt;next; delete q; length--; return true; &#125; p = p-&gt;next; q = q-&gt;next; &#125; return false; &#125; /*清空链表操作*/ bool ListClean() &#123; length = 0; LNode* p = head-&gt;next; LNode* q; while (p-&gt;next != head)//定位到头结点之前，清空初头结点的外的其他数据空间 &#123; q = p -&gt; next; delete p; p = q; &#125; head-&gt;next = head; return true; &#125; /*合并操作*/ bool ListCombine(CLkList* s) &#123; LNode* t_head_of_s = s-&gt;head; s-&gt;rear-&gt;next = head-&gt;next; head-&gt;next = t_head_of_s-&gt;next; length += s-&gt;length; delete s-&gt;head; return true; &#125; /*遍历操作*/ void Traverse(void(*fb)(T &amp; t)) &#123; LNode* p = head-&gt;next;//从头结点开始遍历每一个元素的data while (p != head) &#123; fb(p-&gt;data); p = p-&gt;next; &#125; &#125;private:&#125;;template&lt;typename T&gt;void Print(T&amp; e) &#123; cout &lt;&lt; e &lt;&lt; " ";&#125;int main() &#123; CLkList&lt;char&gt; list; cout &lt;&lt; "后面插入了一个a数据" &lt;&lt; endl; list.push_back('a'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个b数据" &lt;&lt; endl; list.push_back('b'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个c数据" &lt;&lt; endl; list.push_back('c'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个d数据" &lt;&lt; endl; list.push_back('d'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "在2号位置插入p数据" &lt;&lt; endl; list.InsertElement(2, 'p'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "删除测试 " &lt;&lt; endl; cout &lt;&lt; "2号位置的数据被删除了" &lt;&lt; endl; list.DeleteElement(2); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "数据a删除了" &lt;&lt; endl; list.DeleteElement('a'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "数据b删除了" &lt;&lt; endl; list.DeleteElement('b'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "list2: " &lt;&lt; endl; CLkList&lt;char&gt; list2; cout &lt;&lt; "后面插入了一个v数据" &lt;&lt; endl; list2.push_back('v'); list2.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个n数据" &lt;&lt; endl; list2.push_back('n'); list2.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个m数据" &lt;&lt; endl; list2.push_back('m'); list2.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "list2合并到list" &lt;&lt; endl; list.ListCombine(&amp;list2); cout &lt;&lt; "合并后：" &lt;&lt; endl; list.Traverse(Print); cout &lt;&lt; endl; //清空list list.ListClean(); cout &lt;&lt; "清空完成" &lt;&lt; endl; &#125; 销毁链表与清空链表的区别： 销毁链表 清空链表 具体解释 包括头结点全部清空全部delete 保留头结点其他数据元素全部delete清空 产生的后果 头指针丢失，链表无法使用 清空链表后，保留了头结点，只是元素被清空了（即链表回到初始空表状态）还可以使用。 –（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-(1.2)auto、头文件防卫]]></title>
    <url>%2F2019%2F06%2F18%2FC%2B%2B%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-(1.2)auto%E3%80%81%E5%A4%B4%E6%96%87%E4%BB%B6%E9%98%B2%E5%8D%AB%2F</url>
    <content type="text"><![CDATA[Auto auto：变量的自动类型推断。 可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型。（声明时要初始化） 自动推断发生在编译期间，所以使用auto不会造成程序效降低。 头文件防卫式声明 语法： 123456#ifndef _文件名_H#define _文件名_H内容#endif 为什么要用到头文件防卫式声明？ 目的：为了防止头文件中多重、重复定义内容。 情景假设： 假设一个工程里面有两个个头文件.h文件。里面都有自己的内容 123//head1.hint number1 = 8； 123//head2.hint number2 = 5; 1234567891011//main.cpp#include&lt;iostream&gt;#include"head1.h"#include"head2.h"using namespace std;int main()&#123; cout &lt;&lt; number1 &lt;&lt; endl; cout &lt;&lt; number2 &lt;&lt; endl;&#125; 编译运行情况： 假设在head2.h也include了head1.h，且在main.cpp里面也分别include了head1.h和head2.h再进行编译就会出现： 错误原因：出现了number1重复定义的错误，为啥呢？因为在执行main.cpp文件编译的时候已经对head1.h里面的内容进行了编译定义，但到了head2.h的文件的时候又include了head1.h意味着又重复定义了一次head1.h里面的内容从而造成head1.h里的number1重复定义的错误。 如何解决？—-对头文件进行防卫式定义 即对head1.h文件编辑 1234567//head1.h#ifndef _HEAD1_H//如果head1.h没有被定义那么就执行下面的内容#define _HEAD1_H//定义head1.hint number1 = 8；#endif//结束如果 当main.cpp执行编译操作的时候head1.h是没有定义的。所以#ifndef下面的内容将被执行即先定义head1.h文件。但到了include”head2.h”的时候发现head2.h里面也有include“head1.h”但此时head1.h已经被定义了，故#ifndef不成立下面的内容就没有被执行了，从而避免了头文件重复定义的情况。 结论：所以以后定义头文件的时候都可以进行防卫式定义然后就可以随便include定义的头文件了避免这些错误了。 –(本文完)&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-(1.1)命名空间]]></title>
    <url>%2F2019%2F06%2F17%2FC%2B%2B%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-(1.1)%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[命名空间的基本概念简介基本概念 命名空间就是为了防止名字冲突引入的一种机制。系统中可以定义多个命名空间，每个命名空间都有自己的名字，不可以同名。 可以把命名空间看成一个作业域，在这个命名空间定义的函数，跟你另外一个命名空间里定义的函数，即便同名，也互不影响。 命名空间定义： 1234namespace 命名空间名&#123; void fb()&#123;&#125;//函数 ....&#125; 命名空间的定义可以不连续，甚至可以写在多个文件中，如果以为没有定义这个命名空间，那么相当于定义命名空间，如果已经定义了，那么就算打开这个命名空间并可以往里面添加新成员的声明； 情形 假设同一个工程里面有两个project.cpp和project2.cpp文件并分别给两个程序员去编写，在编写过程中张三和李四都定义了同名、返回值相同、参数也相同的void Print()函数，在编译时将会出现： 找到一个或多个多重定义的符号 void_cdecl Print(void)已在project2.obj中定义的错误 如何去解决这种问题呢？分别去改函数名或许是个好方法，但是如果这样的情况多了起来难免就太麻烦了。这里就可以用命名空间来解决具体： 123456//project1.cppnamespace ZhangSan &#123; void Print() &#123; cout &lt;&lt; "这是张三的Print函数" &lt;&lt; endl; &#125;&#125; 这样就解决了这种重名的问题。如果要调用张三的这个同名函数就可以用 命名空间名::实体名（函数名）的方法调用张三的Print函数 （其中“ : : “是作用域运算符）。 12345int main() &#123; ZhangSan::Print();//张三的 Print();//李四的&#125; 运行情况： 但是每次调用的时候都要用命名空间名::实体名（函数名）的方法岂不是也太麻烦了。 所以这里就要用上using关键字了，只要在头文件引入语句下面加入： using namespace ZhangSan就可以了 1234567891011#include&lt;iostream&gt;#include"project2.h"//张三命名空间定义所在的头文件using namespace std;using namespace ZhangSan;//使用的张三的命名空间int main() &#123; Print();//张三的&#125; 运行情况: –(本文完)&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-(2.5)链表存储结构的算法]]></title>
    <url>%2F2019%2F06%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882.5%EF%BC%89%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[链表储存结构 链表（LinkedList） 定义: 每个元素用一个指针（以存储下一个数据的地址）相互串联起来为存储方式的物理存储结构 对应线性表操作： 前插数据元素 Insert_Front() 后插数据元素 Push_back() 插入数据 Insert_Element() 删除数据 Delete_Element() 获得数据 Get() 设置数据 Set() 遍历链表 Traverse() …… 对应一些算法实现思路 插入操作： 思路：先通过移动指针获得要插入位置前一个元素的地址，然后创建一个新的元素空间让要插入的数据对其进行赋值，然后将前一个数据的next指针指向这个新空间的地址，而原来next指针指向的地址赋值给新空间的next指针 具体实现： 123456789101112131415bool InsertElement(int index, T e) &#123; LNode* p = head;//这里的p是指向头结点的指针，目的是要从第一个数据开始往下算下标 int j = 0; while (p &amp;&amp; j &lt; index-1)//定位到要插入元素位置的前一个元素（即：寻找前驱结点） &#123; p = p-&gt;next; ++j; &#125; LNode* s = new LNode();//创建一个链表数据空间 s-&gt;data = e;//把要插入的数据放入这个空间 s-&gt;next = p-&gt;next;//这个新的空间的下一个指针地址是上一个元素的下一个元素地址 p-&gt;next = s;//上一个元素的下一个指针地址变为新空间的地址 return true; &#125; 删除操作： 思路：根据要删除的位置的下标先让一个指针定位到这个位置的前一个元素。这时要先创建一个临时的指针指向将删除的元素的地址（此步目的是获得下一个元素的地址，因为删除后不能获得要删除元素next指针的地址），然后将待删除的元素的前一个元素的next指针等于这个临时指针的next指针，最后delete这个临时指针。 具体实现： 1234567891011121314bool DeleteElement(int index) &#123; LNode* p = head;//定位到头结点 int j = 0;//从第0个元素开始移动指针 while (p &amp;&amp; j &lt; index - 1) &#123;//找到要删除元素数据的前一个位置 p = p-&gt;next; ++j; &#125; LNode* q = p-&gt;next;//用一个临时指针存储要删除数据元素的位置（目的为了获取待删除数据元素的下一个数据元素的位置） p-&gt;next = q-&gt;next;//把前一个数据元素的下一个指针地址存储 delete q;//释放临时指针（即：要删除数据元素）的空间 length--; return true; &#125; 链表存储结构代码实现情况： 前插操作（完成） bool InsertFront(T e) 后插操作（完成） bool push_back(T e) 插入操作（完成） bool InsertElement(int index, T e) 删除操作（完成） bool DeleteElement(int index) 获得操作（完成） bool Get(int index,T&amp; e) 修改操作（完成） bool Set(int index, T e) 遍历操作（完成） void Traverse(void(*fb)(T&amp; t)) 代码详细123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;class LkList&#123; struct LNode &#123; T data;//数据 LNode* next;//指向下一个数据的指针 &#125;; LNode* head;//头指针 int length;public: /*构造函数*/ LkList() &#123; head = new LNode(); length = 0; if (!head)throw"No Memory";//若没有new出来就抛出异常 head-&gt;next = 0; &#125; /*获得数据操作*/ bool Get(int index,T&amp; e) &#123; LNode* p = head-&gt;next;//这里的p指向的下一个元素的头指针 int j = 1; while (p &amp;&amp; j &lt; index) &#123; p = p-&gt;next;//把p的指针往后一个元素头指针移动 ++j; &#125; if (!p || j &gt; index) return false; e = p-&gt;data;//获得数据 return true; &#125; /*插入元素操作*/ bool InsertElement(int index, T e) &#123; LNode* p = head;//这里的p是指向头结点的指针，目的是要从第一个数据开始往下算下标 int j = 0; while (p &amp;&amp; j &lt; index-1)//定位到要插入元素位置的前一个元素（即：寻找前驱结点） &#123; p = p-&gt;next; ++j; &#125; if (!p || j &gt; index) return false; LNode* s = new LNode();//创建一个链表数据空间 s-&gt;data = e;//把要插入的数据放入这个空间 s-&gt;next = p-&gt;next;//这个新的空间的下一个指针地址是上一个元素的下一个元素地址 p-&gt;next = s;//上一个元素的下一个指针地址变为新空间的地址 length++; return true; &#125; /*删除元素操作*/ bool DeleteElement(int index) &#123; LNode* p = head;//定位到头结点 int j = 0;//从第0个元素开始移动指针 while (p &amp;&amp; j &lt; index - 1) &#123;//找到要删除元素数据的前一个位置 p = p-&gt;next; ++j; &#125; if (!p || j &gt; index) return false; LNode* q = p-&gt;next;//用一个临时指针存储要删除数据元素的位置（目的为了获取待删除数据元素的下一个数据元素的位置） p-&gt;next = q-&gt;next;//把前一个数据元素的下一个指针地址存储 delete q;//释放临时指针（即：要删除数据元素）的空间 length--; return true; &#125; /*前插操作*/ bool InsertFront(T e) &#123; LNode* q = new LNode();//创建一个新数据空间 if (!q)return false; q-&gt;data = e;//对要插入的数据进行赋值到这个空间的data q-&gt;next = 0;//避免第一个数据next指针出现野指针的问题 q-&gt;next = head-&gt;next;//与头结点相连 head-&gt;next = q;//这个next指针指向第二个数据的位置 length++; return true; &#125; /*往后插入操作*/ bool push_back(T e) &#123; LNode* p = head;//从头结点开始让指针指向最后一个数据元素的地址 LNode* q = new LNode(); int j = 0; while (p-&gt;next)//如果p-&gt;next为空指针，意味着找到了最后一个数据元素的地址 &#123; p = p-&gt;next; &#125; if (!p)return false; q-&gt;data = e;//进行data赋值 q-&gt;next = 0;//因为是后插，说明后面没有数据元素地址，让这个空间的next指针赋值为0 避免野指针问题 p-&gt;next = q;//原最后一个元素数据的next指向这个新插入的空间地址 length++; return true; &#125; /*设置操作*/ bool Set(int index, T e) &#123; LNode* p = head;//从头结点开始寻找要修改的位置 int j = 0; while (p &amp;&amp; j &lt; index) &#123; p = p-&gt;next; ++j; &#125; if (!p || j &gt; index) return false; p-&gt;data = e;//数据进行修改 return true; &#125; /*遍历操作*/ void Traverse(void(*fb)(T&amp; t)) &#123; LNode* p = head-&gt;next;//从头结点开始遍历每一个元素的data while (p) &#123; fb(p-&gt;data); p = p-&gt;next; &#125; &#125;private:&#125;;template&lt;typename T&gt;void Print(T&amp;t) &#123; cout &lt;&lt; t &lt;&lt; " ";&#125;int main() &#123; LkList&lt;char&gt; List; cout &lt;&lt; "前插了一个A " &lt;&lt; endl; List.InsertFront('A'); List.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "前插了一个B " &lt;&lt; endl; List.InsertFront('B'); List.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后插了一个C " &lt;&lt; endl; List.push_back('C'); List.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "在第4个位置插入了O " &lt;&lt; endl; List.InsertElement(4, 'O'); List.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "在第4个位置插入了G " &lt;&lt; endl; List.InsertElement(4, 'G'); List.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "删除了第2位的元素 " &lt;&lt; endl; List.DeleteElement(2); List.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "把第3位的数据修改成I" &lt;&lt; endl; List.Set(3,'I'); List.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "获得第4位的数据 " &lt;&lt; endl; char ch; List.Get(4, ch); cout &lt;&lt; ch &lt;&lt; endl;&#125; –（本文完)&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-(2.4)初识链表]]></title>
    <url>%2F2019%2F06%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882.4%EF%BC%89%E5%88%9D%E8%AF%86%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表基本概念 结点包括数据域和指针域。 链表是有n个结点链结成，第一个结点的存储位置叫做头指针，最后一个结点的指针为“空”。 相较于顺序表存储结构的优点： 不用定义时规定长度。 存储的元素个数不受限制。 插入和删除元素时，不用移动其他元素。 链表的头指针和头结点 基本概念 头指针：链表中第一个结点的储存位置。 头结点：在单链表的第一个结点前附设的一个结点。 头指针 头结点 若链表有头结点，则是指向头结点的指针；若没有则是链表指向第一个结点的指针 头结点是为了操作的统一和方便而设立的，放在第一个结点之前 其数据域一般无意义（可以存储链表的长度） 头指针具有表示作用，所以常常有头指针表示链表的名字 有了头结点，在第一个结点前插入和删除第一个结点时，操作与其他结点的操作就统一了 无论链表是否为空，头指针均不为空。头指针是链表的必要元素 头结点不一定是链表的必须要素 链表存储结构 链表存储结构的特点是如何将数据域与“指标”（指针域）配对，以及指示下一条数据的内存位置。 链表存储结构中，数据存储在内存中分散的位置。各个数据由一个指针相互连接 一个数据中的指针域存放的是下一个数据的地址。 由于数据储存在不同的位置，每一个数据只能通过指针域中的指针来访问 删除：删除元素时只需将前一个数据的指针域指向要删除数据的下一个数据的地址即可，从而避免了顺序表存储结构多次的数据调换的麻烦。 添加：添加只需把要添加的位置的前一个数据的指针指向新数据，再让新数据的“指标”指向后一个数据的地址即可。 –（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.3）顺序表存储结构代码、算法实现]]></title>
    <url>%2F2019%2F06%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882.3%EF%BC%89%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81%E3%80%81%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[顺序表储存结构 顺序表(SqList) 定义： 顺序表存储结构是一个以连续空间地址存储为方式的物理结构 实现线性表相应操作： SqList（） 初始化线性表：创建一个空的线性表List SqList.InsertElement（index ， e） 在线性表List的index下标处插入元素e SqList.DeleteElement（ index， *e) 删除线性表List中的第i个元素，并返回删除元素指针e SqList.GetLength（） 获得线性表的长度 SqList.DeleteAllElement（） 清空线性表 SqList.find（e） 查找线性表中的元素e ………. 一些基础算法的实现思路 插入算法： 思路：根据想要插入的下标为准，用循环各各数值往后移动（即：相互覆盖赋值）空出指定下标进行插入赋值。从最后一个元素开始往后赋值 具体实现： 12345678910void InsertElement(int index, Datas t) &#123; length++;//因为要插入一个新的元素，故实际长度要加1 for (int i = length; i &gt; index; i--) &#123;//先把后面的元素全部往后覆盖赋值 datas[i] = datas[i - 1]; &#125; datas[index] = t;//在目标index位置插入新元素 &#125; 删除算法： 思路：根据要删除元素的下标为目标往前覆盖赋值。 具体实现： 1234567void DeleteElement(int index) &#123; for (int i = index; i &lt; length-1; i++) &#123; datas[i] = datas[i + 1]; &#125; length--;//每删除一个length（实际长度）将减少 &#125; 扩容： 思路：先判断是否是否满了，（即：用最大容量与实际长度相互比较如果相等那么就算满了），确定满容后先重新获得一个跟大的空间容量，然后把原来的线性表数组对其进行赋值。Delete原线性表数组，地址等于新扩容后的地址，完成扩容操作。 具体实现： 1234567891011121314if(length == capacity)//判断使用扩容的时机void realloc() &#123; T* p = new T[2 * capacity];//最大容量扩大两倍 for (int i = 0; i &lt; length; i++) &#123;//把原顺序表赋值到新顺序表 p[i] = datas[i]; &#125; delete[]datas;//清空原线性表里的元素 datas = p;//把新扩容后线性表的地址赋给datas p = NULL;//避免临时指针p变为野指针 capacity *= 2;//总容量扩大 &#125; 根据线性表用顺序存储结构实现的操作完成情况： 增加元素（完成） bool Push_back(T) 查找元素（完成） bool GetElement(int index,T&amp;c) 扩容（完成） bool realloc() 删除元素（完成） bool DeleteElement(int index) 插入元素(完成) bool InsertElement(int index, T t) 清空元素（完成）&lt;待完善修改&gt; bool DeleteAllElement() 代码详细：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include&lt;iostream&gt;#define MAX_SIZE 1 //定义最大容量using namespace std;template&lt;typename T&gt;class SqList&#123;private: T* datas; //线性表 int length = 0;//实际容量 int capacity;//总容量public: /*构造函数*/ SqList() &#123; capacity = MAX_SIZE;//总容量等于最大容量（进行初始化） datas = new T[capacity]; cout &lt;&lt; "初始化成功！！！" &lt;&lt; endl; &#125; /*获得总容量*/ int GetLength() &#123; return length; &#125; /*查找并取值操作*/ bool GetElement(int index, T&amp; c) &#123; if (index &lt; 0 || index &gt; length) return false; c = datas[index]; return true; &#125; /*增加元素操作*/ bool Push_back(T NewElem) &#123; if (length == capacity)//判断顺序表是否满了 &#123;//如果满了调用扩容操作 if(!realloc())//如果扩容失败那么Push_back也失败 return false; &#125; datas[length] = NewElem; length++; return true; &#125; /*设置元素操作*/ bool SetElement(int index, T t) &#123; if (index&lt;0 || index&gt;length)//判断下标是否输入正确 return false; datas[index] = t; return true; &#125; /*插入元素操作*/ bool InsertElement(int index, T t) &#123; if (index&lt;0 || index&gt;length)//判断下标是否输入正确 return false; length++;//因为要插入一个新的元素，故实际长度要加1 if (length == capacity)//判断顺序表是否满了 &#123;//如果满了调用扩容操作 if (!realloc())//如果扩容失败那么Push_back也失败 return false; &#125; for (int i = length; i &gt; index; i--) &#123;//先把后面的元素全部后退 datas[i] = datas[i - 1]; &#125; datas[index] = t;//在目标index位置插入新元素 return true; &#125; /*删除元素操作*/ bool DeleteElement(int index) &#123; if (index&lt;0 || index&gt;length)//判断下标是否输入正确 return false; for (int i = index; i &lt; length-1; i++) &#123; datas[i] = datas[i + 1]; &#125; length--;//每删除一个length（实际长度）将减少 return true;//删除动作完成后返回true &#125; /*清空元素操作*/ bool DeleteAllElement() &#123; int len = length; for (int i = 0; i &lt; len; i++) &#123; DeleteElement(0); &#125; return true; &#125; /*查找元素操作*/ int find(T e, int pos = 0) &#123; for (int i = pos; i &lt; length; i++) &#123; if(datas[i] == e) return i; &#125; return -1; &#125;private: /*扩容操作*/ bool realloc() &#123; T* p = new T[2 * capacity];//最大容量扩大两倍 cout &lt;&lt; "扩容成功！！！" &lt;&lt; endl; if (!p)return false; for (int i = 0; i &lt; length; i++) &#123;//把原顺序表赋值到新顺序表 p[i] = datas[i]; &#125; delete[]datas;//清空原线性表里的元素 datas = p;//把新扩容后线性表的地址赋给datas p = NULL;//避免临时指针p变为野指针 capacity *= 2;//总容量扩大 return true;//更换扩容操作完成后宣布扩容操作成功 &#125;&#125;;//打印顺序表操作template&lt;typename T&gt;//模版void Print(SqList&lt;T&gt;&amp; L) &#123; T e; for (int i = 0; i &lt; L.GetLength(); i++) &#123; L.GetElement(i, e); cout &lt;&lt; e &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; int main() &#123; SqList&lt;char&gt; List; char ch; if (!List.GetElement(1, ch)) cout &lt;&lt; "未找到" &lt;&lt; endl; cout &lt;&lt; "加入A" &lt;&lt; endl; List.Push_back('A'); Print(List); cout &lt;&lt; "加入B" &lt;&lt; endl; List.Push_back('B'); Print(List); cout &lt;&lt; "修改下标为1的B为G" &lt;&lt; endl; List.SetElement(1, 'G'); Print(List); cout &lt;&lt; "加入C" &lt;&lt; endl; List.Push_back('C'); Print(List); cout &lt;&lt; "加入D" &lt;&lt; endl; List.Push_back('D'); Print(List); cout &lt;&lt; "在下标为2的位置插入O" &lt;&lt; endl; List.InsertElement(2, 'O'); Print(List); cout &lt;&lt; "删除下标为1的G" &lt;&lt; endl; List.DeleteElement(1); Print(List); cout &lt;&lt; "寻找M的下标为： " &lt;&lt; List.find('M') &lt;&lt; endl; cout &lt;&lt; "清空了所有元素" &lt;&lt; endl; List.DeleteAllElement(); cout &lt;&lt; "加入F" &lt;&lt; endl; List.Push_back('F'); Print(List); cout &lt;&lt; "寻找A的下标为： " &lt;&lt; List.find('A') &lt;&lt; endl; cout &lt;&lt; "在下标9位置插入G" &lt;&lt; endl; List.InsertElement(9, 'G'); Print(List);&#125; –(本文完)&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大学学习个人计划及路线规划]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E5%8F%8A%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! U2FsdGVkX1+lrme0nILrHduB9W80jTbvRP09nbZjyYAXOfj+1u9aBf4gWVDR2S55ZR7t9A2OIlXVXvdhvHZyjLebYY3w4la8SKr3dJeBWH3v2//AeW4sdMo7jevOk2xi0Mi0HVVVY/5/A27hXEw6zxhUsmsIftT5cOxI9/QZmpqKaNwC45Z7Z+jVKGY44tH+PB4pA9wCPKNcTMSMeLqMHvRJgCtkQbenoDLJowbEkCfkZcknJn2z9YM0XCP4rJdlxj/C5VwAfqaXEg0RaFrwhzBGosH/D4WgaIzlZPE1oq3wU3ftUe/HbSH3jY9rJFGxCs9CQgWGl1MDG7nkvqxLWzu/mW6cTUA8C8M0XtAs3PSWHKsdtwT3IBmUhlspBmrDdnI5VhJh2j+toXAWYl75gVaAD8CEKuYI8fd9op/OPgkqdA+VubkF00uOFG6cU2QvnQP56RZE1q1Lp3wPhyJelYWBlpgphMNbvk6Mln1eJvml153EhGE59ylb8v3ul48PfVNd53jOabjELmumRGTa/Sgn7XaLnY/8250NlncQjCLzFl0xSbB8CSDi7Z2P/4mrnC8Pmox24DVnNXTSqAbyRR5wqEQA4zz08rYqYrCL3uXSyv4J6u7JKNjhobg+9E6DnLJgh8+Fk9XGdSXF2JCIxscM62bbCZJhRprbcliTYM5AS147a61FZUu7O4nducFUbeALQVS55llZTy16e7FQlpeYSjk1MOPQbRQVhysi5SjkPcYCuBWarivTJQZaOg+W3D3I5vt9dvxD7Os8duedxkKfzivMPt8Qe+MbFT/0U93pOMfRSrGh2gs2rKLMp/3YVPiqvFcuppkb53eyC4IOMM5TLcbY/vFRJp4unwVd5fmpCwd8KDuVvMcyBdas3DIwcDwQR828y8sQ2K30dbBlANpXSdPQWbUeDmW0b333hVXzHN2WdKsBgdaJg1GVBh9UUWboEPvA5VRVLSRp2OiHxH/cw9AxlGrk7wOUN0VA/AvLrZI7MUXaio7Q7rI2JN9x4HrrLbFo7G1dTjzmvn93p1Qn+u9kQlQxcE7u5eGlvDLlZCWk8pbUMgcWCjtbklCxVPccfkZiqAAWEpH9/UxyprKQT8wu4eEZbFmozg4VB4D9q5nhTNRRY4k4vEbaKd+47GuNnCRHLI3QN2dieS7e5xTXILtJolXftiHd48SUXVlgLV/O1l2qd5XIbxT/aFVl6nTB2fvJXOo8pfUg6MhyEC0HUD3boGvunQNmeqc3NkPMhFhJFcO1gXE1HWf4NxDmz8TselkmQ4JiswPwd3R98g==]]></content>
      <categories>
        <category>个人随感</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
        <tag>目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.2）顺序表存储结构]]></title>
    <url>%2F2019%2F06%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882.2%EF%BC%89%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[顺序表结构 顺序存储结构的线性表–顺序表 定义：指的是用一段地址连续的存储单元依次存储线性表的数据元素（数组） 顺序表的构成 需要定义线性表的最大存储空间 #define int Max_SIZE = 255; 线性表里需要有统一类型的元素集合 12345678910111213141516#define int MAX_SIZE = 255;//最大存储长度 /*定义线性表*/typedef int ElemType;//给int起一个别名 ElementTypetypedef struct&#123; int num;char* name;&#125;ElementType;/*定义顺序表结构*/typedef struct &#123; ElementType Datas[MAX_SIZE]; int length;//当前长度&#125;SeqList; –(本文完)&lt;待完善&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[石膏球（练习）]]></title>
    <url>%2F2019%2F06%2F14%2F%E7%9F%B3%E8%86%8F%E7%90%83%EF%BC%88%E7%BB%83%E4%B9%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>绘画</category>
        <category>练习</category>
      </categories>
      <tags>
        <tag>绘画练习</tag>
        <tag>素描</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习心得体会]]></title>
    <url>%2F2019%2F06%2F14%2FJava%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[​ 先简单说一下我对于编程这一门课程个人感受吧，编程说难也难，但说它简单也不过分。难，难在程序编写过程的中的思考方式。简单，就简单在一旦你掌握了基本语句和方法的基础下，有着一个活跃的思维思考能力，程序编程基本都是水到渠成的事。接下来我就简单说下我个人对于Java学习过程中一些心得和学习方法供大家参考一下吧。 心得：​ 首先我在大一是有接触过C++的，刚拿到课本也是一头雾水，看不明白。但在深入学习后，我认为掌握一门程序语言重要的不是知道它具体的语法和规则，而是运用这些语法和规则时的思维。为什么编程的思维很重要呢？这是一个很现实的问题，如今知识更新快，社会发展非常快，意味着编程语言的变化也是很无常的，或许你刚掌握了java语言，市场上就有了更好的编程语言。这就意味着你要继续学习新的语言和知识，如果此时你有一个活跃的编程思维，去接触新的语言学会它会非常容易。 说了这么多思维很重要，那编程思维到底是怎样的？举个小例子：假设你要编程一个超市商品结账的程序，先不要想怎么去编写它。先去思考一下，假如你在超市工作并给一个顾客买的两个东西结账。结账时你要做的事情：你要先识别他买的两个东西单价分别是多少钱，买了多少个，总金额多少，付钱结账最后打印一个小票给这个顾客。简化下来就是：1.识别物品，2.计算金额3.打印信息。好的！接下来用编程来搞定它，1.识别物品从你一大堆的商品信息中找到这个商品的信息。怎么编这个功能？用循环被一个个找。找到同名的商品并得到它的金额信息就可以了。2.计算金额 用循环累加，3.打印出信息 完成本次结账，程序结束。从上面可以看出编这个程序思考方向：明确你程序要干的事情是什么（目的是结账），干这个事情有什么动作（1.识别食品找到对应的价格2.计算总金额3.打印信息），完成这些动作要用什么方法（1.可以用循环来找或其他方法2.每一项金额累加3.打印上面步骤得到的数据信息）。你能在看见一个动作就能想到一个方法去解决它。这就要靠活跃的思维，怎么样用你所学到的编程规则与语句对应想出编写针对它解决它的方法，这就是一个编程的思维。 学习方法：​ 根据上文所述的思维的方式我说下我自己的学习方法供大家参考。 根据自己的想法用自己的话去总结每一章学习的知识：这里要注意！自己每次学习完一章内容尽量地去总结且一定要根据自己的话和自己的思考去总结不能网上复制粘贴一下概念知识。这样做有两个好处：①加固加深你所学的知识，毕竟是根据自己思考后总结出来的、②培养独立的学习思考能力（说白了就是把你学到的知识用自己的理解写一个类似于教材的总结）。 建立编程错误库：其实很多人在编程的时候都会遇到红标报错，这是很正常的事情我们本来就是在试错中才能积累经验。你每一次出错，如果你有时间可以编写一个文档计入每一次遇到的新的报错 并且记录下错因是什么 怎么去解决，这样遇到同样的错误就会有条件反射：“哦！我以前犯过NullPointException的错误，这个错误是空指针错误，原因是有一个对象没有给它空间，应该调用它的构造方法去解决它。”慢慢的就会有独立去解决这些错误的能力了。当然如果你没有多余的时间，也可以让自己的脑子去记下来QWQ。 找个好（ji）朋友进行讨论和思维碰撞：单干是很寂寞的。可以找一个好朋友、舍友进行思维碰撞和讨论。这也很重要！为什么，因为每一个对同一个问题的思考方式、方向都不可能完全相同的。通过思维的交汇，朋友间能相互提高且提高的跟快。再者可以有效的避免一些舍友之间的矛盾。 兴趣主导目标引领：有一个学习目标是很重要的，当然这得取决你不会去排斥它，就如编程。你主动爱它虽然它不会爱你_(:з」∠)_。但你排斥它，它也一定会排斥你这也是必然的。所以学好一门课首先是要培养出对它的兴趣，然后java语言与其他编程语言一样，学习它时候是要用大量的课余时间去练习它。练习也是要有目的的，你可以就按每次作业的要求去学习它，在完成作业后，你也可以自己想一点小玩意供自己去练习。例如：你看见你去钱用的很乱，你就会想编一个记账的小程序，然后就有一个目标出现了。你就会根据你的小目标去主动学习主动搜索你所需要的知识。学习一门课程，只要你站在主动的一方，一切问题就非常好解决了。 从初学就养成良好的编码习惯：这里有些人可能有点疑问，码是我编的，我想咋编就咋编我看得懂就ok这样的思想是很错误的。首先这样做DEbug会非常辛苦，现在是小程序可能体会不出来，当你编写几百行几万行以上的代码就会痛苦的不得了。（个人亲试过：你体验过自己编了700多行代码的程序，de一个bug蹦出一堆bug的快感吗？）。这里我非常推荐一点要写注释！特别是自己想的方法。这样做有两个好处：①这样你编写这个方法的时候思路会比较明确，知道每一步要怎么去做。 ②.对于以后工作写文档会有用处，未来的代码是要给别人看的。 然后我提一点其他的好习惯吧。㈠定义变量的时候命名让它有意义，且在定义的时候一个变量占一行，有关联的变量尽量相近定义。㈡善用回车换行，这里举一个简单的例子吧。每个方法尽量用两个回车来分开。这样做，一是方便注释，二是方便分辨每一个方法体，且美观。这里要注意回车换行适度就行，不宜太多。其他方法可以搜索网上资料。这里就不一一叙述了。养成良好的编程习惯一是方便你自己，二来也对未来工作有非常大的帮助。 尽量先靠自己去想怎么做：不要一遇到不会就百度、参考其他同学的代码。切记！有人会说，参考后我会自己去理解，之后也不是会变成我自己的知识吗？这样说吧：这样做好比你在海上航行，你知道答案了就像你知道目的地的准确位置了，接下来你只需把船开过去即可，但正常情况下，你应该要靠自己的能力去找目的地而不是知道它在哪的前提下去航海。未来工作也是这样。一个是逆向思考，另一个是正向思考。两者是不一样的。所以我们一定要先独立思考。直到真的完全不会了再去参考学习。每次都参考别人的东西去学习，会导致一个依赖感长期的逆向思考，到了真的要自己动手的时候发现一点都不会。这也解释了一些同学看得懂代码，自己动手却什么都不会的原因。 ​ 最后我先明确我的这些理解和见解只供大家去参考。我的一些理解和心得可能没有你们的好，学习方法或许你的也会更棒。所以不要太局限于我的见解QAQ。 –（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>个人随感</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>心得体会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.1）线性表的抽象数据类型]]></title>
    <url>%2F2019%2F06%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882.1%EF%BC%89%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[线性表 定义： 零个或多个数据元素的有限序列。 特点: 它是一个序列 数据元素之间是有有序的。 数据元素之间是一对一的关系。 有限性 两个数据元素的有限序列称为空表。 常见线性表的操作： 删除 插入 创建 初始化 清空 查找 线性表的抽象数据类型 ADT 线性表(List) Data 线性表数据元素是一个集合{a_1 , a_2 , a_3 , …. , a_n},数据元素的类型DataType（int , char ,…)。 除了第一个（a_1）元素外，每个元素有且只有一个直接的前驱元素。 例如 : a_2的前驱元素是a_1。 除了最后一个（a_n）元素外，每一个元素有且只有一个直接的后继元素。 例如: a_3是a_2的后继元素。 Operation InitList（*List） 初始化线性表：创建一个空的线性表List InsertElement（*List ， index ， e） 在线性表List的index下标处插入元素e DeleteElement（*List ， index， *e) 删除线性表List中的第i个元素，并返回删除元素指针e GetLength（*List） 获得线性表的长度 IsEmpty（*List） 判断线性表是否为空表 ClearList（*List） 清空线性表 ExsitElement（*List ， e） 查找线性表中的元素e endADT 个人理解：​ 在实际上，线性表可以理解为一群人在排队，排队的都是人（数据元素类型相同），然后他们是排成一条线的。首先排队的人肯定是有限的（即：有限性）其次他们每一个人是相互连成一条线的，即一个人跟着一个人有顺序（即：一对一、有序的）。 ​ 再者，这队排队的人，除了第一个人前面没人，最后一个人后面没人外。其中每一个人都是前后都有人的。例如第二个人的前面是第一个人（即：第一个人为第二个人的前驱元素），而第三个人是第二个人的后面（即：第三个人为第二个人的后继元素）。 ​ 这队排队的人是在等待上车的。他们之间可能会有人在中途想上厕所从而离开了队伍（即：删除），又或者有人在后面加入进去了（即：增加），这时检票员也会一一核对信息对照人员表查找每一个人是否到齐了（即：查找），这时上厕所的人回来了因为这队人是有顺序的，所以这位回来的也可以插入原来的位置（即：插入）。 –（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2）第二章预习]]></title>
    <url>%2F2019%2F06%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882%EF%BC%89%E7%AC%AC%E4%BA%8C%E7%AB%A0%E9%A2%84%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[问题： 线性表的顺序存储的优点和缺点有哪些？ 线性表的删除和插入算法的思路？ 数组长度和线性表长度的区别？ 顺序存储结构的三大属性？ –（本文未完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-(1.2)抽象数据类型]]></title>
    <url>%2F2019%2F06%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%881.2%EF%BC%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[抽象数据类型数据类型 定义： 计算机中，内存空间是最有限的，不同的类型的数据分配的内存空间大小不同。 例如：在C++ 中 整型占4个字节，双精度浮点数占8个字节等等 数据类型就是指一组性质相同的值和集合及定义在此集合上的一些操作的总称 例如在C/C++语言中的数据类型中是按取值不同分类的数据类型 原子型（不可再分）：不可再分的数据类型。例如：int(整型)、double（双精度浮点型）等等 结构型（可再分）：若干个数据类型（包括原子型和结构型）组成的一个组合。例如：数组，类，结构体（C/C++）等。 抽象数据类型（Abstruct Data Type[ADT]) 定义：是对已有的数据类型进行抽象 抽象数据类型是指一个数据模型及定义在该模型上的一组操作 模板： ADT 抽象数据类型名 Data 数据元素之间的逻辑关系的定义 Operation 操作1 初始条件 操作结果描述 操作2 … 操作n … endADT 个人理解：通过套用上面的模板 解释int（整型数据类型） int（整型） 是以线性结构存储一个int（整型）数据类型占4个字节 Operation 操作1：加法 需要两个数 结果为两个数的和 操作2：减法 需要两个数 结果为两个数的差 操作3：乘法 … 操作4：除法 … 个人总结： 用自己的话简述下列术语： 数据：类似一个或几个人的全部基本信息（姓名、性别、爱好等）。 数据元素：人基本类型里面的单一个姓名、性别等。 数据对象：单一个人的基本信息。 数据结构：数据通过一定的结构、关系（计算方法【算法】）存储起来就是数据结构 例如：上面所说的数据 –多个人的基本信息 一般是用列表格的形式存储的，即所用的是线性逻辑结构存储的。 存储结构（物理结构）：是对逻辑结构在计算机上的表示。即对上面的数据结构在计算机进行实习，如果是顺序存储结构，那么这些个人基本信息可能是用数组储存起来的。 数据类型：例如 整型、浮点型就是一个数据类型，数据类型是一组相同值和其每个值之间特有的关系上的操作的总称。例如整型，它每一个数据元素都是一个整数，他们可以进行加减乘除等操作。 抽象数据类型：类似于数据类型，但是把一些东西抽象化成数据类型。例如游戏角色，它的数据元素（对比就是整型里面的整数）有很多，例如武器、玩家属性等、这个数据类型可以执行的动作有移动攻击等。 数据结构和抽象数据类型的概念与程序设计语言中的数据类型概念的区别 抽象数据类型是对软件设计过程中问题模型抽象出来的逻辑结构和在逻辑结构上的运算。 数据结构是计算机处理元素的组织形式的相互关系。 程序设计语言中的数据类型是已经实现了的数据结构。 即：一个还没有被实现（抽象数据类型）一个是已经实现的了（程序设计语言中的数据类型） 而数据结构是指： 数据的相互之间存在一种或多种特点关系的数据元素的集合。 --（本文完）&lt;待完善&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java模拟考心得体会]]></title>
    <url>%2F2019%2F06%2F12%2FJava%E6%A8%A1%E6%8B%9F%E8%80%83%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[今天进行了Java期末考试的模拟考，颇有心得与感触，以本文进行叙述：遇到的问题比较多：例如 &gt;&gt; 与 &gt;&gt;&gt;运算符 这里的意思是这样的 &gt;&gt;有符号的右移这是对二进制的数来说的 int i=8，那么 i &gt;&gt; 2就是二进制往右移两位，即：（0）1000【8】 往右移两位就是 （0）0010【2】，而&gt;&gt;&gt;就是不考虑符号位。 jpane的默认布局是流式布局 （我居然写BorderLayout） 其次是swing包里面的 按钮监听器不太熟 警示： 千万不要在程序设计或填空 题目里面用Shift + F 格式化 切记切记！！ 其他知识点： 按钮监听器重写方法：public void actionPerformed(ActionEvent event) 对于子类可以从父类继承的成员变量，只要子类中声明的成员变量和父类中的成员变量同名时，子类就隐藏了继承的成员变量，子类自己声明定义的方法操作与父类同名的成员变量是指子类重新声明定义的这个成员变量。 –（本文完）]]></content>
      <categories>
        <category>个人随感</category>
      </categories>
      <tags>
        <tag>心得体会</tag>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（1.1）数据结构的基本概念]]></title>
    <url>%2F2019%2F06%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%881.1%EF%BC%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[数据结构的基本概念五个基本概念：数据 定义：描述客观事物的符号，是计算机中可以操作的对象。 个人理解：类似于整型，或者一个文件都是可以看出数据。实际情况：例如我输入的账号密码就算是为数据 数据元素 定义：组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。 数据元素是数据结构的聚焦点 个人理解：把数据比喻成一个文件夹，那么数据元素就应该是里面的一个不可分的文件（高达模型上面的一个零件？）。 数据项 定义： 一个数据元素可以由若干个数据项组成。 个人理解 ： 数据元素比作对象，那么数据项就类似于对象的属性（成员变量）。例如：上面输入信息时，用户名和密码分别就算是数据项 数据对象 定义： 性质相同的数据元素的集合，是数据的子集。 个人理解：这个应该是介于数据和数据项中间的东西 数据结构（data structure） 定义：数据结构是相互之间存在一种或多种特定关系的数据元素的集合。 数据元素 + 特定关系 = 数据结构 总结：用实际情形来描述，你在一个网站上进行注册，要求填写个人形象，其中里面的姓名、密码就是 数据项 ，每一个数据项组成的就是一个 数据元素 ，数据元素一多起来就统称为：数据 逻辑结构 集合结构 图形结构（图） 树形结构（皇帝与丞民） 线性结构 物理结构 定义：又叫存储结构，是指数据的逻辑结构在计算机中的存储形式。 顺序存储结构 ：类似于数组 ，把数据元素存储在地址连续的储存单元里。 链式存储结构 ：把数据元素存放在任意的存储单元里 类似于数组，但可以不连续，每一个数值直接有一个类似于绳子或链条的东西相互绑定。 类似指针 –（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[石膏立方体（练习）]]></title>
    <url>%2F2019%2F06%2F11%2F%E7%9F%B3%E8%86%8F%E7%AB%8B%E6%96%B9%E4%BD%93%EF%BC%88%E7%BB%83%E4%B9%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>绘画</category>
        <category>练习</category>
      </categories>
      <tags>
        <tag>绘画练习</tag>
        <tag>素描</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[置顶]欢迎来到ShuHaoHwang的博客！！]]></title>
    <url>%2F2019%2F06%2F11%2F%5B%E7%BD%AE%E9%A1%B6%5D%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%9C%AC%E5%8D%9A%E4%B8%BB%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%81%EF%BC%81%2F</url>
    <content type="text"><![CDATA[本博客将先会以个人的学习总结为主，之后将更新一些技术性的文章，欢迎与博主进行探讨、思维碰撞。在吉珠的小伙伴还可以来直接找博主哦！ 欢迎留言，博主在有空之余将一一进行查看并回复。]]></content>
  </entry>
</search>
