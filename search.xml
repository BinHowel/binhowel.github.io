<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaWeb学习总结(6.1)MyBatis配置与简单实例]]></title>
    <url>%2F2020%2F01%2F31%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-6-1-MyBatis%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[MyBatis简介MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录 简单点说就是提供一个DAO层框架，便于数据库与实体对象之间的转换 IDEA+Maven + MyBatis配置 具体配置过程1.安装相关的一些Maven依赖插件(MyBatis + Mysql)创建好Maven项目后，先导入MyBatis的一些Maven依赖，进行安装插件 12345678910111213 /*MyBatis依赖*/ &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt;/*MYSQL数据库*/ &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; 2.MyBatis上配置mysql的相关属性下载好依赖后，先在项目自带的resources文件下，创建一个xml文件，用来配置MyBatis 创建好文件后 打开进行配置，配置如下 简化版： 12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/user_learn"/&gt; &lt;property name="username" value="shuhao"/&gt; &lt;property name="password" value="991124"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="mapper/UserMapper.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 完全版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 加载属性文件 --&gt; &lt;properties resource="config.properties"&gt; &lt;!--properties中还可以配置一些属性名和属性值 --&gt; &lt;!-- &lt;property name="jdbc.driver" value=""/&gt; --&gt; &lt;/properties&gt; &lt;!-- 全局配置参数，需要时再设置 --&gt; &lt;!-- &lt;settings&gt; &lt;/settings&gt; --&gt; &lt;typeAliases&gt; &lt;!-- 别名定义 --&gt; &lt;!-- 针对单个别名定义 type：类型的路径 alias：别名，类名不能写错 别名可以随便起，但最好规范--&gt; &lt;typeAlias type="cn.edu.cqu.domains.User" alias="user" /&gt; &lt;!-- 批量别名定义 指定包名，mybatis自动扫描包中的po类，自动定义别名，别名就是类名（首字母大写或小写都可以） --&gt; &lt;package name="cn.edu.cqu.domains" /&gt; &lt;/typeAliases&gt; &lt;!-- 和spring整合后 environments配置将废除 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理，事务控制由mybatis --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池，由mybatis管理 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;!--通过resource方法一次加载一个映射文件 --&gt; &lt;!--注意这里的路径和xml文件 --&gt; &lt;mapper resource="mappers/user.xml" /&gt; &lt;!-- 批量加载mapper 指定mapper接口的包名，mybatis自动扫描包下边所有mapper接口进行加载 --&gt; &lt;!-- 遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，且在一个目录 --&gt; &lt;!-- 中上边规范的前提是：使用的是mapper代理方法 &lt;package name="...." /&gt;--&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3.根据实体对象进行配置反射映射实体类模型 12345678910111213141516171819202122232425262728293031package Javabean;/** * @author ShuHao * @version 1.0 * @date 2020/1/31 */public class User &#123; String name; String id; String password; public User() &#123; &#125; public User(String name, String id, String password) &#123; this.name = name; this.id = id; this.password = password; &#125; public String getName() public void setName(String name) public String getId() public void setId(String id) public String getPassword() public void setPassword(String password)&#125; 在resources目录下，创建一个mapper文件。里面放置对应实体类的，反射映射配置，文件类型为.XML，在里面写相关的mysql命令语句 12345678&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="Javabean.User"&gt; &lt;select id="findOneById" parameterType="int" resultType="Javabean.User"&gt; select * from user where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 完整版 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="test"&gt; &lt;!-- 在映射文件中配置很多sql语句 --&gt; &lt;!-- 将sql语句封装到mappedStatement对象中，所以将id称为statement的id --&gt; &lt;!-- parameterType：指定输入参数的类型，这里指定int型 #&#123;&#125;表示一个占位符号 --&gt; &lt;!-- #&#123;id&#125;：其中的id表示接收输入的参数，参数名称就是id，如果输入 --&gt; &lt;!-- 参数是简单类型，#&#123;&#125;中的参数名可以任意，可以value或其它名称 --&gt; &lt;!-- resultType：指定sql输出结果的所映射的java对象类型，select指定resultType表示将单条记录映射成的java对象。 --&gt; &lt;!-- 表名要对，但是不区分大小写，resultType要写类名，同样不区分大小写 --&gt; &lt;select id="findUserById" parameterType="int" resultType="user"&gt; SELECT * FROM user WHERE id = #&#123;value&#125; &lt;/select&gt;&lt;/mapper&gt; 4.进行测试创建一个主类，还有main函数 具体使用mybatis步骤 通过该类获取类加载对象，对mybatis的配置文件进行加载，转换成输入流 用该加载后的inputstream 对象创建SqlSessionFactory对象 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in【inputstream 对象】) 随后通过构造好的factory 获取sqlsession对象。 SqlSession session = factory.openSession(); 对该session对象进行数据库链接操作 1234567891011121314151617181920212223package Mybatis;import Javabean.User;import org.apache.ibatis.session.*;import java.io.InputStream;/** * @author ShuHao * @version 1.0 * @date 2020/1/31 */public class HelloMybatis &#123; public static void main(String[] args)&#123; InputStream in = HelloMybatis.class.getClassLoader().getResourceAsStream("MyBatis.xml"); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); SqlSession session = factory.openSession(); User user = session.selectOne("Javabean.User.findOneById",1); System.out.println(user.getName()); session.close(); &#125;&#125; 注意 操作SqlSession对象的时候，调用相关模板映射内写的一些方法进行数据库操作 其中以上述为例selectOne方法内的两个参数，第一个为对象映射内的select标签内的方法id，第二个为对应的参数 本例测试为：根据id进行查找用户，当通过id = 1进行查找时，selectOne方法会返回对应的user对象 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(5.2)使用Maven安装项目插件与Jar包、如何配置MavenWeb+Tomcat]]></title>
    <url>%2F2020%2F01%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-5-2-%E4%BD%BF%E7%94%A8Maven%E5%AE%89%E8%A3%85%E9%A1%B9%E7%9B%AE%E6%8F%92%E4%BB%B6%E4%B8%8EJar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[通过Maven安装插件Maven项目下，直接通过修改项目自带的pom.xml进行下载安装插件。例如安装maven-compiler-plugin插件，直接把内容复制进pom.xml内的&lt;build&gt;&lt;plugins&gt;两个标签内然后保存 配置完毕后，在IDEA的右边点击Maven，然后点选Run Maven build即可 部署MavenWeb的一些问题解决集合创建MavenWeb项目 Idea创建maven web项目+Tomcat部署 主看！ Tomcat插件的配置使用（不推荐使用这样的方式，非常容易出错） 配置好Maven下载的插件后，去除Pom.xml内的&lt;pluginManagement&gt;标签，即可在Maven工程内显示你在Pom.xml内的插件，然后点选Tomcat7内的，Tomcat7:run进行启动即可 Maven常用插件1.maven-compiler-plugin 设置maven编译的jdk版本，maven3默认用jdk1.5，maven2默认用jdk1.3 1234567891011&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.6.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;!-- 源代码使用的JDK版本 --&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;!-- 需要生成的目标class文件的编译版本 --&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt;&lt;!-- 字符集编码 --&gt; &lt;skipTests&gt;true&lt;/skipTests&gt;&lt;!-- 跳过测试 --&gt; &lt;/configuration&gt; &lt;/plugin&gt; 2. tomcat7-maven-plugintomcat7插件，可以在远程进行部署项目，在没有安装Tomcat的情形下进行使用Tomcat 12345678910&lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;!--配置项目的路径和tomcat的端口，以及服务器编码解决乱码问题--&gt; &lt;configuration&gt; &lt;path&gt;/&lt;/path&gt; &lt;port&gt;9090&lt;/port&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;/configuration&gt;&lt;/plugin&gt; 3.maven-source-plugin打包源码 注意：在多项目构建中，将source-plugin置于顶层或parent的pom中并不会发挥作用，必须置于具体项目的pom中。 123456789101112&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 4.maven-resource-plugin说明：该插件处理项目的资源文件拷贝到输出目录。可以分别处理main resources 和 test resources。 12345678&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; 5.maven-dependency-plugin自动拷贝jar包到target目录 1234567891011121314151617181920212223&lt;!-- 依赖插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-dependencies&lt;/id&gt; &lt;phase&gt;compile&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-dependencies&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;!-- $&#123;project.build.directory&#125;为Maven内置变量，缺省为target --&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/lib&lt;/outputDirectory&gt; &lt;!-- 表示是否不包含间接依赖的包 --&gt; &lt;excludeTransitive&gt;false&lt;/excludeTransitive&gt; &lt;!-- 表示复制的jar文件去掉版本信息 --&gt; &lt;stripVersion&gt;true&lt;/stripVersion&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; 6.maven-assembly-plugin该插件允许用户整合项目的输出,包括依赖,模块,网站文档和其他文档到一个单独的文档，即可用定制化打包。 创建的文档格式包括:zip, tar, tar.gz(tgz), gar.bz2(tbgz2), jar, dir,war 等等。四种预定义的描述器可用：bin, jar-with-dependencies, src, project. 12345678910111213141516171819&lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;configuration&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;!-- this is used for inheritance merges --&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;!-- bind to the packaging phase --&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(5.1)Maven、Maven配置、配置Maven阿里云中央仓库]]></title>
    <url>%2F2020%2F01%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-5-1-Maven%E3%80%81Maven%E9%85%8D%E7%BD%AE%E3%80%81%E9%85%8D%E7%BD%AEMaven%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Maven简介Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。 说白了： 在实际开发中，一般需要引入外部的jar包进行开发，例如MySQL的jar包、C3P0的一些jar包，而Maven则会根据程序员自己的需要自动的在网络上去下载相关的所有jar包，而不用程序员手动的去网上下载。综上Maven在实际开发中将非常方便。 Maven的配置(IDEA)Maven通常在Eclipse 和IDEA都有自带。所有可以通过这些编译器配置自带的Maven，这里以IDEA为例(Eclipse 配置也差不多相同) 首先打开IDEA的设置，搜索Maven 配置IDEA自带的Maven(这里选择的是Maven3)，设置自带Maven的settings.xml位置路径到 用户设置路径区域 配置本地存储仓库，默认的C盘空间小，改到空间大的盘。具体步骤为打开用户设置的settings.xml，也就是Maven所在目录下的settings.xml]]></content>
      <categories>
        <category>代码学习</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(4.3)小型AJAX工具、简单实例、JSON]]></title>
    <url>%2F2020%2F01%2F29%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-4-3-%E5%B0%8F%E5%9E%8BAJAX%E5%B7%A5%E5%85%B7%E3%80%81%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[AJAX简单小型工具先理清AJAX普遍的核心寻求 有一个目标url 给服务器的数据 获取服务器的结果 123456789101112131415161718192021222324&lt;script type="text/javascript"&gt; //使用get方式发送ajax请求 function ajaxGet(url,param,callsuccess,callfail)&#123; var obj = new XMLHttpRequest(); obj.onreadystatechange = function()&#123; var isLast = (obj.redyState==4); var isSuccess = (obj.status==200||obj.status==304); if(isLast)&#123; //加载成功后 if(isSuccess)&#123;//如果状态正常则执行callsuccess回调函数 var rs = obj.responseText; if(callsuccess)callsuccess(rs); &#125;else&#123;//如果状态异常则执行callfail回调函数 if(callfail)callfail(obj.status); &#125; &#125; &#125; obj.open("get",url+"?"+param); obj.send(null);//get只能null &#125;&lt;/script&gt; 整体思路： 工具函数内首先输入url作为目标路径 param则代表本次的参数 callsuccess、callfail分别为加载成功或失败执行对应的回调函数 三者分别对应：目标在哪里、传什么值、该做什么 12345678910111213141516171819202122232425&lt;script type="text/javascript"&gt; //使用post方式发送ajax请求 function ajaxGet(url,param,callsuccess,callfail)&#123; var obj = new XMLHttpRequest(); obj.onreadystatechange = function()&#123; var isLast = (obj.redyState==4); var isSuccess = (obj.status==200||obj.status==304); if(isLast)&#123; //加载成功后 if(isSuccess)&#123;//如果状态正常则执行callsuccess回调函数 var rs = obj.responseText; if(callsuccess)callsuccess(rs); &#125;else&#123;//如果状态异常则执行callfail回调函数 if(callfail)callfail(obj.status); &#125; &#125; &#125; obj.open("post",url); obj.setRequestHeader('Content-type','application/x-www-form-urlencoded') obj.send(param);//get只能null &#125;&lt;/script&gt; 简单演示 以上篇检测用户名1是否存在为例 123456789 ajaxGet("./HaveName","un=shuhao",function (data)&#123; if(data == "true")&#123; alert("用户名已经存在"); &#125;else&#123; alert("用户名可以使用！") &#125;&#125;,function (st) &#123; alert("Error = "+ st);&#125;) 实验结果： 全部演示代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript"&gt; //使用get方式发送ajax请求 function ajaxGet(url,param,callsuccess,callfail)&#123; var obj = new XMLHttpRequest(); obj.onreadystatechange = function()&#123; var isLast = (obj.readyState==4); var isSuccess = (obj.status==200||obj.status==304); if(isLast)&#123; alert("加载成功") //加载成功后 if(isSuccess)&#123;//如果状态正常则执行callsuccess回调函数 var rs = obj.responseText; if(callsuccess)callsuccess(rs); &#125;else&#123;//如果状态异常则执行callfail回调函数 if(callfail)callfail(obj.status); &#125; &#125; &#125; obj.open("get",url+"?"+param); obj.send(null); &#125; //使用post方式发送ajax请求 function ajaxpost(url,param,callsuccess,callfail)&#123; var obj = new XMLHttpRequest(); obj.onreadystatechange = function()&#123; var isLast = (obj.redyState==4); var isSuccess = (obj.status==200||obj.status==304); if(isLast)&#123; //加载成功后 if(isSuccess)&#123;//如果状态正常则执行callsuccess回调函数 var rs = obj.responseText; if(callsuccess)callsuccess(rs); &#125;else&#123;//如果状态异常则执行callfail回调函数 if(callfail)callfail(obj.status); &#125; &#125; &#125; obj.open("post",url); obj.setRequestHeader('Content-type','application/x-www-form-urlencoded') obj.send(param); &#125; ajaxGet("./HaveName","un=shuhao",function (data)&#123; if(data == "true")&#123; alert("用户名已经存在"); &#125;else&#123; alert("用户名可以使用！") &#125; &#125;,function (st) &#123; alert("Error = "+ st); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; AJAX简单实例(计算两数之和) 思路： 通过一个html页面的表单获取两个数字 创建一个servlet 获取两个值进行相加，随后打印让表单页面进行读取获取 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Add&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="text" id="a" name="a"/&gt;+&lt;input type="text" id="b" name="b"/&gt;&lt;button onclick = "add();"&gt; = &lt;/button&gt; &lt;span id="rs"&gt;&lt;/span&gt;&lt;script type="text/javascript"&gt; //使用get方式发送ajax请求 function ajaxGet(url,param,callsuccess,callfail)&#123; var obj = new XMLHttpRequest(); obj.onreadystatechange = function()&#123; var isLast = (obj.readyState==4); var isSuccess = (obj.status==200||obj.status==304); if(isLast)&#123; //加载成功后 if(isSuccess)&#123;//如果状态正常则执行callsuccess回调函数 var rs = obj.responseText; if(callsuccess)callsuccess(rs); &#125;else&#123;//如果状态异常则执行callfail回调函数 if(callfail)callfail(obj.status); &#125; &#125; &#125; obj.open("get",url+"?"+param); obj.send(null); &#125; //使用post方式发送ajax请求 function ajaxpost(url,param,callsuccess,callfail)&#123; var obj = new XMLHttpRequest(); obj.onreadystatechange = function()&#123; var isLast = (obj.readyState==4); var isSuccess = (obj.status==200||obj.status==304); if(isLast)&#123; //加载成功后 if(isSuccess)&#123;//如果状态正常则执行callsuccess回调函数 var rs = obj.responseText; if(callsuccess)callsuccess(rs); &#125;else&#123;//如果状态异常则执行callfail回调函数 if(callfail)callfail(obj.status); &#125; &#125; &#125; obj.open("post",url); obj.setRequestHeader('Content-type','application/x-www-form-urlencoded') obj.send(param); &#125; function add() &#123; var a = document.getElementById('a').value; var b = document.getElementById('b').value; var r = "a="+a+"&amp;b="+b; console.log(a+"+"+b+"="); ajaxGet("./Add",r,function (data)&#123; if(a!=null &amp;&amp; b!=null)document.getElementById('rs').innerHTML = data; &#125;,function (st) &#123; alert("Error = "+ st); &#125;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526/*servlet*/package AJAXLearn;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class Add extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("utf-8"); response.setCharacterEncoding("utf-8"); String a = request.getParameter("a"); String b = request.getParameter("b"); System.out.println("已经取到值 a= "+ a +" b= " + b); response.getWriter().print((Double.parseDouble(a)+Double.parseDouble(b))); &#125;&#125; 实验结果： 补充：JSON格式JSON规则：12345对象 用 大括号 &#123;&#125;数组 用 中括号 []赋值 用 冒号 ：分隔 用 逗号 ,注意：字符串用双引号，属性名用双引号(严格模式要求) 示例 123456&#123; "name":"Mr.House", "age":20, "科目":["数学",“英语”,“体育”] “student”: true&#125; JSON的本质是字符串 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(4.2)AJAX]]></title>
    <url>%2F2020%2F01%2F26%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-4-2-AJAX%2F</url>
    <content type="text"><![CDATA[AJAX AJAX: “ Asnchronous JavaScript and XMI” 中文意思:异步Javascript和yML. 指一种创建交互式网页应用的网页开发技术。 AJAX并非缩写词,而是由Jesse James Gaiiett创造的名词。 不是指一种单一的技术,而是有机地利用了一系列相关的技术: web标准( Standards-Based Presentation )XHTML+CSs的表示, 使用DOM ( Document Object Model )进行动态显示及交互, 使用XML和XSLT进行数据交换及相关操作, 使用XMHttpReauest进行异步数据查询、检索. 简单理解为: JavaScript + XMttpReauest + CSS +服务器端的集合. 优点 传统的web应用允许用户向web服务器发送一个请求。服务器接收并处理然后返回一个新的网页(同步)。 这个做法浪费了许多带宽,因为在前后两个页面中的大部分HTML代码往往是相同的。 AJAX应用可以仅向服务器发送并取回必需的数据,并在客户端采用Javascript处理来自服务器的响应 因为在服务器和浏览器之间交换的数据大量减少(大约只有原来的5%)结果我们就能看到响应更快的应用。同时很多的处理工作可以在发出请求的客户端机器上完成,所以Web服务器的处理时间也减少了。 Ajax在本质上是一个浏览器端的技术 Ajax技术之主要目的在于局部交换客户端及服务器间之数据 能够不用重新载入整个版面来更新资料,也就是所谓的Refresh without Reload(轻刷新) 与服务器之间的沟通,完全是透过Javascript来实行 本身传送的资料量很小,反应更快,让网络程序更像一个桌面应用程序 AJAX就是运用Javascript在后台悄悄帮你去跟服务器要资料,最后再由 Javascript或DOM来帮你呈现结果,因为所有动作都是由Javascript代劳,所以省去了网页重载的麻烦,使用者也感受不到等待的痛苦 AJAX常用API及简单实例12345678910&lt;script type="text/javascript"&gt; //异步对象，可以发送异步请求，可以接受服务器响应 var obj = new XMLHttpRequest(); //访问数据的位置 obj.open("post","Hello.html"); //访问时发送的数据或请求（参数会传递至服务器） obj.send(null);&lt;/script&gt; 常用api1234obj.readystate: 准备状态0.1.2.3.4obj.status :服务器响应的状态码(404/403/500/200/304) obj.responseText:服务器给我们的响应文本obj.onreadystatechange事件: readystate发生变化时触发 readyState属性readyState属性指出了XMLHttpRequest对象在发送/接收数据过程中所处的几个状态。XMLHtpRequest对象会经历5种不同的状态。 0：未初始化。对象已经创建,但还未初始化,即还没调用 open方法; 1：已打开。对象已经创建并初始化,但还未调用send方法： 2：已发送。已经调用send方法,但该对象正在等待状态码和头的返回 3：正在接收。已经接收了部分数据,但还不能使用该对象的属性和方法,因为状态和响应头不完整; 4：已加载。所有数据接收完毕 status属性 服务器发送的每一个响应也都带有首部信息。三位数的状态码是服务器发送的响应中最重要的首部信息,并且属于超文本传输协议中的一部分。 常用状态码及其含义: 404没找到页面(not found) 403禁止访问(forbidden) 500内部服务器出错(internal service error) 200一切正常(ok) 304没有被修改(not modif ied) 在XMLHLLReauest对象中,服务器发送的状态码都保存在status属性里。通过把这个值和200或 304比较,可以确保服务器是否已发送了一个成功的响应 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Register&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="application/javascript"&gt; var obj = new XMLHttpRequest(); obj.onreadystatechange = function () &#123; alert(obj.readyState); &#125; obj.open("post","HelloHtml.html"); obj.send(null);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 一些简单演示功能实例时间数据刷新v1.012345678910111213141516171819202122232425262728293031323334353637383940414243&lt;%-- Created by IntelliJ IDEA. User: ShuHao Date: 2020/1/27 Time: 18:14 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;ShowTimeAndDate&lt;/title&gt;&lt;/head&gt;&lt;body&gt;当前时间为：&lt;span id="time"&gt;&lt;/span&gt;&lt;br&gt;&lt;button type="button" onclick="getTime()"&gt;获取时间&lt;/button&gt;&lt;script type="text/javascript"&gt; function getTime() &#123; //获取异步请求对象 var obj = new XMLHttpRequest(); obj.onreadystatechange = function () &#123; var islast = (obj.readyState==4); var isSuccess = (obj.status==200||obj.status==304); if(islast &amp;&amp; isSuccess)&#123; var data = obj.responseText; var tspan = document.getElementById('time'); tspan.innerHTML = data; &#125; &#125; obj.open("get","Date.jsp") obj.send(null); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 数据源Date.jsp 用来刷新时间信息 1234567891011&lt;%@ page import="java.util.Date" %&gt;&lt;%-- Created by IntelliJ IDEA. User: ShuHao Date: 2020/1/27 Time: 18:06 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;% out.print(new Date());%&gt; v2.0(实现动态刷新页面2)1234567891011121314151617181920212223242526//在getTime()函数内添加一个计时期setTimeout("getTime()",1000);&lt;script type="text/javascript"&gt; function getTime() &#123; var obj = new XMLHttpRequest(); obj.onreadystatechange = function () &#123; var islast = (obj.readyState==4); var isSuccess = (obj.status==200||obj.status==304); if(islast &amp;&amp; isSuccess)&#123; var data = obj.responseText; var tspan = document.getElementById('time'); tspan.innerHTML = data; &#125; &#125; obj.open("get","Date.jsp") obj.send(null); setTimeout("getTime()",1000); &#125;&lt;/script&gt; 简单的用户名存在检测 实例说明 很多时候在注册的时候都要进行用户检测，看该用户名是否注册过。所以这里可以更新ajax进行提交异步请求来检测用户在注册时输入的用户是否注册过 初始页面 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Register&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; 用户名：&lt;input type="text" name="un" id="ymh"/&gt; &lt;button type="button" onclick="IsHavename()"&gt;检测用户名是否存在&lt;/button&gt;&lt;/form&gt;&lt;script type="application/javascript"&gt; function IsHavename() &#123; var obj = new XMLHttpRequest(); obj.onreadystatechange = function () &#123; var islast= (obj.status == 304 || obj.status == 200); var isSuccess = (obj.readyState == 4); if(islast&amp;&amp;isSuccess)&#123; var data = obj.responseText; alert(data); &#125; &#125; var username = document.getElementById('ymh').value; console.log(username); obj.open("get","./HaveName?un="+username); obj.setRequestHeader('Content-type','application/x-www-form-urlencoded') obj.send(null); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后台服务端 总体处理流程： 获取在展示页面获取的内容 在程序控制进行输出 用获取到的用户连接数据库进行查询是否存在 返回结果至此servlet后端服务器输出的页面 如果存在则显示true 不存在则显示false 1234567891011121314151617181920212223242526272829303132package LoginDemo;import Dao.UserDao;import User.User;import utils.JDBCUtil;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class IsHaveName extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("utf-8"); response.setCharacterEncoding("utf-8"); String username = request.getParameter("un"); System.out.println("获取成功！"); System.out.println("用户信息： 用户名： " + username); UserDao userDao = JDBCUtil.getUserDao(); response.getWriter().print(userDao.findByUserName(username)); return; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125;&#125; 小修改使用post方式进行传参12345/*修改处*/obj.open("post","./HaveName");obj.send("un=" +username);/*全部代码*/ 进行提示优化 当用户名查询存在时报已存在 不存在时报可用 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Register&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;un&quot; id=&quot;ymh&quot;/&gt; &lt;button type=&quot;button&quot; onclick=&quot;IsHavename()&quot;&gt;检测用户名是否存在&lt;/button&gt;&lt;/form&gt;&lt;script type=&quot;application/javascript&quot;&gt; function IsHavename() &#123; var obj = new XMLHttpRequest(); obj.onreadystatechange = function () &#123; var islast= (obj.status == 304 || obj.status == 200); var isSuccess = (obj.readyState == 4); if(islast&amp;&amp;isSuccess)&#123; var data = obj.responseText; if(data==&apos;true&apos;)&#123; alert(&quot;用户名已经存在请重新设置&quot;); &#125;else&#123; alert(&quot;用户名可以使用&quot;); &#125; &#125; &#125; var username = document.getElementById(&apos;ymh&apos;).value; console.log(username); obj.open(&quot;post&quot;,&quot;./HaveName&quot;); obj.setRequestHeader(&apos;Content-type&apos;,&apos;application/x-www-form-urlencoded&apos;) obj.send(&quot;un=&quot; +username); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 其他 注意在传参过程中的乱码问题 处理时要考虑IE浏览器的兼容问题 obj.setRequestHeader(&#39;Content-type&#39;,&#39;application/x-www-form-urlencoded&#39;)用来处理post请求的主体类型，使用post必填。填在open之后 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(4.1)AJAX前奏-对于同步通讯与异步通讯的理解]]></title>
    <url>%2F2020%2F01%2F26%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-4-1-AJAX%E5%89%8D%E5%A5%8F-%E5%AF%B9%E4%BA%8E%E5%90%8C%E6%AD%A5%E9%80%9A%E8%AE%AF%E4%B8%8E%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[同步通讯 浏览器向服务器提交一个请求后等待服务器响应,服务器收到请求后作出处理,浏览器收到响应数据后显示出来,这就是传统B/S的同步通讯方式,页面中的内容都是同步加载到浏览器中的。 如果我们想向服务器提交数据,就必须进行页面跳转 ,如果我们想实时获得服务端数据,就必须不停地刷新页面。 有时候可能我们只是想更新极少的数据,这也要发请求,重新加载整个页面,浪费资源,降低访问速度 异步通讯 在不刷新页面的情况下与服务器进行通讯，就被称为异步通讯 框架：如果使用一组框架构造了一个网页，可以只更新其中一个框架，而不必惊动整个页面 XMLHttpRequest：该对象是对JavaScript的一个扩展,可使网页与服务器进行通信。是创建Ajax应用的最佳选择。实际上通常把 Ajax当成XMLHttpRequest对象的代名词 总述总的来说： 同步加载（刷新）：每次刷新的是整个页面的数据 异步加载（刷新）：每次刷新的是整个页面的部分数据]]></content>
      <categories>
        <category>代码学习</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(3.2)反射与动态实例化]]></title>
    <url>%2F2020%2F01%2F24%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-3-2-%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8A%A8%E6%80%81%E5%AE%9E%E4%BE%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[反射 反射的概念主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。 JAVA反射机制是在运行状态中,对于任意一个类,都能够知道这个类的所有属性和方法;对于任意一个对象,都能够调用它的任意一个方法;这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 相关API java.lang包下 Class&lt;T&gt;:表示一个正在运行的Java应用程序中的类和接口,是 Reflection的起源 java.lang.reflect包下 Field类:代表类的成员变量(也称类的属性) Method类:代表类的方法Constructor类:代表类的构造方法 Array类:提供了动态创建数组,以及访问数组的元素的静态方法 Class&lt;T&gt; 获取方式 说明 实例 object.getClass()每个对象都有此方法 获取指定实例 对象的Class List list = new ArrayListo;Class listClass = list.getClass); Class.getSuperclass() 获取当前Class的继承类Class List list = new ArrayList);Class listClass = list.getClass() Class superClass = listClassgetSuperclass): Object.class .class直接获取 Class listClass = ArrayList.class; Class.forName(类名) 用Class的静态方法，传入类的全称即可 try{Class c =Class.forName(“java. uti.ArrayList”);} catch (ClassNotFoundException e)e.printStackTrace): Primitive.TYPE 基本数据类型的封装类获取Class的方式 Class longClass =Long.TYPE;Class integerClass = Integer.TYPE;Class voidClass = Void.TYPE Method 获得当前类以及超类的public Method: Method[] arrMethods = classType. getMethods(); 获得当前类申明的所有Method: Method[] arrMethods = classType. getDeclaredMethods(); 获得当前类以及超类指定的public Method: Method method = classType. getMethod(String name,Class&lt;?&gt;... parameterTypes); 获得当前类申明的指定的Method: Method method = classType. getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) 通过反射动态运行指定Method: Object obj = method. invoke(Object obj, Object... args) Field 获得当前类以及超类的public Field: Field[] arrFields = classType. getFields(); 获得当前类申明的所有Field: Field[] arrFields = classType. getDeclaredFields(); 获得当前类以及超类指定的public Field: Field field = classType. getField(String name); 获得当前类申明的指定的Field: Field field = classType. getDeclaredField(String name); 通过反射动态设定Field的值: fieldType.set(Object obj, Object value); 通过反射动态获取Field的值: Object obj = fieldType. get(Object obj); 反射的作用反射最主要的作用之一就是可以动态的实例化对象。这里的动态的实例化对象可以类比成动态创建数组一样 12345678//类比C++的数组int arr[5];//这样创建一个数组它就已经在编译时就规定好了这个arr数组有5个空间/*动态规划数组*/int a;cin &gt;&gt; a;int* nums = new int[a]//这种创建数组为动态创建，可以更加自己的需要在程序运行的时候进行设置数组的大小 而反射中的动态实例化也是差不多的道理 例如 我可以通过object来接一些数据，当我需要最终的对象类型是Student时，我就输入一个字符串让这个Object自动加载Student类中的内容、然后时object对象变成Student对象，而此时我又需要一个Book对象的时候可以输入一段字符串使这个object对象加载Book对象中的内容。进行设置转成Book对象。这与以往的自动类型检查机制不同，其中就是可以根据自己的需要在程序跑起来的时候进动态的实例化所需要的对象 动态实例化过程 首先创建两个类Student与Book 内含一些参数与对应的get、set方法 12345678910111213141516171819package Javabean;/** * @author ShuHao * @version 1.0 * @date 2020/1/25 */public class Student&#123; public String name; public String class_name; public Student() public Student(String name, String class_name) public String getName() public void setName(String name) public String getClass_name() public void setClass_name(String class_name) &#125; 12345678910111213141516171819package Javabean;/** * @author ShuHao * @version 1.0 * @date 2020/1/25 */public class Book &#123; public String name; public String id; public Book() public Book(String id,String name) public String getName() public void setName(String name) public String getid() public void setid(String class_name) &#125; 1234567891011121314151617181920212223242526272829303132import java.lang.reflect.Method;import java.util.Scanner;/** * @author ShuHao * @version 1.0 * @date 2020/1/25 * 用于测试反射机制 */public class FanSeTest &#123; public static void main(String[] agrs)&#123; Scanner input = new Scanner(System.in); String command = ""; try &#123; System.out.print("输入操作类"); command = input.next(); Class c = Class.forName(command); Object o = c.newInstance(); System.out.println("获取类成功！你动态实例化的类为"+ o.getClass().getName()); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 可以发现这些选择实例化对应的对象的操作都是程序已经在运行的时候发生的 动态获取实例化的其他获取方法123456789Class c = Class.forName(command);/*方法1：反射实例化(无参)*/Object o = c.newInstance();//已被淘汰过期/*方法2：反射实例化(无参)*/Object o = c.getConstructor(new class[]());/*方法3：反射实例化(带参)*/Object o = c.getConstructor(new class[]())。newInstance(new Object[]&#123;"对应类参数..."&#125;); 带参的出现，可以得到的结果就是动态实例化对象还可以更具需求自己调用想实例化的类对象的构造函数并设置对应的类内参数 动态获取类对象中的方法以上在动态获取类对象的基础上，还可以获取其对应对象类中的所有方法 12345678910111213141516171819202122232425262728293031323334import java.lang.reflect.Method;import java.util.Scanner;/** * @author ShuHao * @version 1.0 * @date 2020/1/25 * 用于测试反射机制 */public class FanSeTest &#123; public static void main(String[] agrs)&#123; Scanner input = new Scanner(System.in); String command = ""; try &#123; System.out.print("输入操作类"); command = input.next(); Class c = Class.forName(command); Object o = c.newInstance(); System.out.println("获取类成功！你动态实例化的类为"+ o.getClass().getName()); Method[] m = c.getMethods(); System.out.println("\n该类的方法有："); for(Method s:m) System.out.println(s.getName()); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 你甚至可以动态的调用对应的类方法1234567891011121314151617181920212223242526272829303132333435public class FanSeTest &#123; public static void main(String[] agrs)&#123; Scanner input = new Scanner(System.in); String command = ""; try &#123; System.out.print("输入操作类"); command = input.next(); Class c = Class.forName(command); Object o = c.getConstructor(new Class[]&#123;String.class,String.class&#125;).newInstance(new Object[]&#123;"444111","西游记"&#125;);//调用对应加载类的构造函数进行设置 System.out.println("获取类成功！你动态实例化的类为"+ o.getClass().getName()); Method isGetidMethod = c.getMethod("getid",new Class[]&#123;&#125;); Object id = isGetidMethod.invoke(o,new Object[]&#123;&#125;); Method isGetnameMethod = c.getMethod("getName",new Class[]&#123;&#125;); Object name = isGetnameMethod.invoke(o,new Object[]&#123;&#125;); System.out.println("Book类对象内的ID为 " + id + " 书名为 " + name); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125;catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 含参数的动态调用 12Method issetMethod = c.getMethod("setid",new Class[]&#123;String.class&#125;);issetMethod.invoke(o,new Object[]&#123;"123456"&#125;); 详细测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.lang.reflect.Method;import java.util.Scanner;/** * @author ShuHao * @version 1.0 * @date 2020/1/25 * 用于测试反射机制 */public class FanSeTest &#123; public static void main(String[] agrs)&#123; Scanner input = new Scanner(System.in); String command = ""; try &#123; System.out.print("输入操作类"); command = input.next(); Class c = Class.forName(command); Object o = c.getConstructor(new Class[]&#123;String.class,String.class&#125;).newInstance(new Object[]&#123;"444111","西游记"&#125;); System.out.println("获取类成功！你动态实例化的类为"+ o.getClass().getName()); Method isGetidMethod = c.getMethod("getid",new Class[]&#123;&#125;); Object id = isGetidMethod.invoke(o,new Object[]&#123;&#125;); Method isGetnameMethod = c.getMethod("getName",new Class[]&#123;&#125;); Object name = isGetnameMethod.invoke(o,new Object[]&#123;&#125;); System.out.println("Book类对象内的ID为 " + id + " 书名为 " + name); Method issetMethod = c.getMethod("setid",new Class[]&#123;String.class&#125;); issetMethod.invoke(o,new Object[]&#123;"123456"&#125;); id = isGetidMethod.invoke(o,new Object[]&#123;&#125;); name = isGetnameMethod.invoke(o,new Object[]&#123;&#125;); System.out.println("Book类对象内的ID为 " + id + " 书名为 " + name); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125;catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 动态属性访问1234567891011121314151617import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.Scanner;public class FanSeTest2 &#123; public static void main(String[] agrs) throws Exception &#123; Class c = Class.forName("Javabean.Book"); Object o = c.getConstructor(new Class[]&#123;String.class,String.class&#125;).newInstance(new Object[]&#123;"666","红楼梦"&#125;); Field field = c.getField("id"); Field field2 = c.getField("name"); String id = field.get(o).toString(); String name = field2.get(o).toString(); System.out.println("Book类对象内的ID为 " + id + " 书名为 " + name); &#125;&#125; 设置参数 12345/*接着上述代码*/field.set(o,"520"); id = field.get(o).toString(); name = field2.get(o).toString(); System.out.println("Book类对象内的ID为 " + id + " 书名为 " + name); 附加 可以使用field.setAccessible(true)进行降权操作，即允许调用私有属性 其他 动态调用方法的相关方法的参数中 Class[]：为参数类型数组 object[]：为对应参数的值或对象 小结反射最主要的使用情况 有两个程序员，一个程序员在写程序的时候，需要使用第二个程序员所写的类，但第二个程序员并没完成他所写的类。那么第一个程序员的代码能否通过编译呢？这是不能通过编译的。利用Java反射的机制，就可以让第一个程序员在没有得到第二个程序员所写的类的时候，来完成自身代码的编译。只是如果这个类还没有，获取时会获取不到，但不会导致编译错误，更不会导致程序的崩溃。 可以在远程进行操作程序，动态的创建需要的对象和调用需要的方法 —-（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础学习（1.4）JDBC连接池]]></title>
    <url>%2F2020%2F01%2F23%2FJava%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%881-4%EF%BC%89JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[传统JDBC连接存在的问题开发基于数据库的程序时,传统的模式基本是按以下步骤: 在主程序中建立数据库连接-&gt;SQL操作-&gt;断开数据库连接。 这种模式开发,存在的问题: 普通的JDBC数据库连接使用DriverManager来获取,每次向数据库建立连接的时候都要将Connection加载到内存中,再验证用户名和密码(得花费0. 05s~1s的时间)。需要数据库连接的时候,就向数据库要求一个,执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很好的重复利用,若同时有几百人甚至几千人在线,频繁的进行数据库连接操作将占用很多的系统资源,严重的甚至会造成服务器的崩溃 对于每一次数据库连接,使用完后都得断开。否则,如果程序出现异常而未能关闭,将会导致数据库系统中的内存泄漏,最终将导致重启数据库。 这种开发不能控制被创建的连接对象数,系统资源会被毫无顾及的分配出去如连接过多,也可能导致内存泄漏,服务器崩溃。 数据库的连接池技术 数据库连接池技术(connection pool)的基本思想就是为数据库连接建立一个”缓冲池。预先在缓冲池中放入一定数量的连接,当需要建立数据库连接时,只需从“缓冲池”中取出一个,使用完毕之后再放回去。 数据库连接池负责分配、管理和释放数据库连接,它允许应用程序重复使用一个现有的数据库连接,而不是重新建立一个。 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中,这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用,连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数,当应用程序向连接池请求的连接数超过最大连接数量时,这些请求将被加入到等待队列中。 演示DBCP DBCP是Apache软件基金组织下的开源连接池实现该连接池依赖该组织下的另一个开源系统: Common-pool.如需使用该连接池实现 增加如下三个jar文件: Commons-dbcp.jar:连接池的实现 , Commons-pool.jar:连接池实现的依赖库 commons-logging.jar:连接池实现的依赖库2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package Demo;import org.apache.commons.dbcp2.BasicDataSource;import java.sql.Connection;import java.sql.SQLException;/** * @author ShuHao * @version 1.0 * @date 2020/1/23 */public class DBCPDemo &#123; public static final void main(String[] args)&#123; //创建一个连接池对象 BasicDataSource ds = new BasicDataSource(); //告诉连接池如何连接数据库 ds.setDriverClassName("com.mysql.jdbc.Driver");//对应原来的class.namefor()对mysql驱动进行加载设置 /*设置连接池一些用户名密码和连接数据库的地址*/ String url = "jdbc:mysql://localhost:3306/user_learn?serverTimezone=Asia/Shanghai&amp;useSSL=false"; String name = "shuhao"; String password = "991124"; ds.setUrl(url); //设置密码 ds.setUsername(name); //设置数据库管理员用户名 ds.setPassword(password); //设置管理密码 /*设置连接池的一些基本属性*/ ds.setMaxTotal(40); //最大活动连接数 ds.setMinIdle(2); //最小空闲连接数 ds.setInitialSize(10); //初始连接数 try &#123; //向连接池申请一个连接 Connection conn = ds.getConnection(); conn.close(); //归还连接给连接池【已被重写】 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; System.out.println("DBPC以成功获取MYsql连接！！"); &#125;&#125; C3P0 C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate、Spring等。 添加如下两个jar文件 c3p0.jar mchange-commons-java.jar 两者需版本对应 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package Demo;import com.mchange.v2.c3p0.ComboPooledDataSource;import java.beans.PropertyVetoException;import java.sql.Connection;import java.sql.SQLException;/** * @author ShuHao * @version 1.0 * @date 2020/1/23 */public class C3P0Test &#123; public static void main(String[] args)&#123; //创建连接池对象 ComboPooledDataSource ds = new ComboPooledDataSource(); try &#123; //告诉连接池如何连接数据库 ds.setDriverClass("com.mysql.jdbc.Driver");//对应原来的class.namefor()对mysql驱动进行加载设置 /*设置连接池一些用户名密码和连接数据库的地址*/ String url = "jdbc:mysql://localhost:3306/user_learn?serverTimezone=Asia/Shanghai&amp;useSSL=false"; String name = "shuhao"; String password = "991124"; ds.setJdbcUrl(url); //设置密码 ds.setUser(name); //设置数据库管理员用户名 ds.setPassword(password); //设置管理密码 /*设置连接池的一些基本属性*/ ds.setMaxPoolSize(40); //最大连接数 ds.setMinPoolSize(2); //最小连接数 ds.setInitialPoolSize(10); //初始连接数 Connection conn = ds.getConnection(); //获取连接 System.out.println("成功从C3P0连接池获取连接"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 通过使用C3P0编写工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package utils;import com.mchange.v2.c3p0.ComboPooledDataSource;import java.beans.PropertyVetoException;import java.sql.Connection;import java.sql.SQLException;/** * @author ShuHao * @version 1.0 * @date 2020/1/23 */public class JDBCUtil &#123; //静态连接池 private static ComboPooledDataSource ds = null; public static Connection getConnection()&#123; try &#123; if(ds == null)&#123;//如果为空说明没有创建连接池 则重新创建 ds = new ComboPooledDataSource(); ds.setDriverClass("com.mysql.jdbc.Driver"); String url = "jdbc:mysql://localhost:3306/user_learn?serverTimezone=Asia/Shanghai&amp;useSSL=false"; String name = "shuhao"; String password = "991124"; ds.setJdbcUrl(url); ds.setUser(name); ds.setPassword(password); ds.setMaxPoolSize(40); ds.setMinPoolSize(2); ds.setInitialPoolSize(10); Connection conn = ds.getConnection(); System.out.println("成功从C3P0连接池获取连接"); &#125; //最后返回一个getConnection()对象 return ds.getConnection(); &#125; catch (PropertyVetoException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; C3P0使用配置文件进行属性配置 名称必须为c3p0-config.xml,否则无法找到 文件必须放在classpath下【类根目录 例：src、以及maven的java和resource】 123456789101112131415161718192021&lt;c3p0-config&gt; &lt;default-config&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/user_learn?serverTimezone=Asia/Shanghai&amp;amp;useSSL=false"&lt;/property&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="user"&gt;shuhao&lt;/property&gt; &lt;property name="password"&gt;991124&lt;/property&gt; &lt;/default-config&gt; &lt;named-config name = "mysql"&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/user_learn?serverTimezone=Asia/Shanghai&amp;amp;useSSL=false"&lt;/property&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="user"&gt;shuhao&lt;/property&gt; &lt;property name="password"&gt;991124&lt;/property&gt; &lt;property name="checkoutTimeout"&gt;3000&lt;/property&gt; &lt;property name="idleConnectionTestPeriod"&gt;30&lt;/property&gt; &lt;property name="initialPoolSize"&gt;10&lt;/property&gt; &lt;property name="maxPoolSize"&gt;100&lt;/property&gt; &lt;property name="maxIdleTime"&gt;30&lt;/property&gt; &lt;property name="minPoolSize"&gt;10&lt;/property&gt; &lt;property name="maxStatements"&gt;200&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 注意点: 数据源和数据库连接不同,数据源无需创建多个 ,它是产生数据库连接的工厂,因此整个应用只需要一个数据源即可。 当数据库访问结束后,程序还是像以前一样关闭数据库连接: onn.close0但上面的代码并没有关闭数据库的物理连接,它仅仅把数据库连接释放,归还给了数据库连接池 C3P0与DBCP区别 DBCP没有自动回收空闲连接的功能 C3P0有自动回收空闲连接功能 连接池技术的优点 资源重用: 由于数据库连接得以重用,避免了频繁创建、释放连接引起的大量性能开销。在减少系统消耗的基础上,也增加系统运行环境的平稳性。 更快的系统反应速度 数据库连接池在初始化过程中,往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言 ,直接利用现有可用连接,避免了数据库连接初始化和放过程的时间开销,从而减少了系统的响应时间 新的资源分配手段 对于多应用共享同一数据库的系统而言,可在应用层通过数据库连接池的配置,实现某一应用最大可用数据库连接数的限制,避免某一应用独占所有的数据库资源 统一的连接管理,避免数据库连接泄露 在较为完善的数据库连接池实现中,可根据预先的占用超时设定,强制回收被占用连接,避免了常规数据库连接操作中可能出现的资源泄露]]></content>
      <categories>
        <category>代码学习</category>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(3.1)MVC设计模式]]></title>
    <url>%2F2020%2F01%2F23%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-3-1-MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[MVC设计模式MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。 Model（模型）表示应用程序核心（比如数据库记录列表）。 View（视图）显示数据（数据库记录）。 Controller（控制器）处理输入（写入数据库记录）。 MVC 模式同时提供了对 HTML、CSS 和 JavaScript 的完全控制。 Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。 通常模型对象负责在数据库中存取数据。 View（视图）是应用程序中处理数据显示的部分。 通常视图是依据模型数据创建的。 Controller（控制器）是应用程序中处理用户交互的部分。 通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。 MVC的优点 各司其职,互不干涉 在MVC模式中,三层各司其职,所以一旦哪一层需要发生变化,只需要更改相应层的代码,而不会影响到其它层的代码 有利于开发中的分工 在MVC模式中,由于系统按层分开,从而可以更好的实现开发的分工。页面设计人员可以只考虑如何将页面设计得更加美观和易于操作;对业务熟悉的人员可以更加专心地进行业务开发;而协调工作可以交给控制层开发人员完成。 有利于组件的重组 在MVC模式中,分层后更有利于组件的重组,如控制层可独立成为一个能用的组件,视图层也可做成通用的操作界面,大大提高了系统的灵活性。 MVC缺点MVC的不足体现在以下几个方面： (1)增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。 (2)视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。 (3)视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。 (4) 目前，一般高级的界面工具或构造器不支持MVC模式。改造这些工具以适应MVC需要和建立分离的部件的代价是很高的，从而造成使用MVC的困难]]></content>
      <categories>
        <category>代码学习</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(2.3)Session]]></title>
    <url>%2F2020%2F01%2F20%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2-3-Session%2F</url>
    <content type="text"><![CDATA[HTTP通信​ JavaWeb应用程序运行是基于B/S的模式,用户通过客户端浏览器向Web服务器发送一个HTTP请求,服务器收到请求的同时一个连接就建立了,服务器根据请求做必要的处理并生成一个响应信息,然后把它回送给客户端。这一过程结束后,服务器就关闭了该连接,而不会一直与客户端保持着连接的状态。 当用户发送另一条请求时，所有的请求与响应都和上一次一样，客户和服务器之间必须重新建立连接。 即：你访问一个网站，此时会发出一个请求，然后服务器给与回应两者就断开了，你和网站的服务器不是一直有着连接，而是这种一瞬间的短连接，这也就是为什么你访问一个网站后 断网了，网站依旧可以在该页面进行浏览。 HTTP的无状态性​ Web服务器需要为大量的用户服务。对于一个服务器接受一条网络连接就意味着通过一个套接字侦听进入的请求,如果一服务器同时连接大量的用户, 这会消耗掉服务器大量的资源,包括线程和内存。 为了能够服务于大量的用户, HTTP被设计成在每一次新请求中都使用新的连接,这种特性称为HTTP的无状态性。 Session既然http是无状态的,那服务器该如何对多个用户进行区分呢? 我们常进的网站通常都是每次只需要登录一次,然后就记住了用户信息和登录状态,这是如何实现的呢?这就需要一种机制来唯一的标识用户,以便跟踪用户在站点中的行为。 这就是我们要说的会话对象session,可以利用会话对象session来记录用户的数据信息。 即：JavaWeb可以通过Session来记录每一个用户的使用情况，它是跟踪于浏览器的，假设你登入了一个网站，下次再打开时，它会保持你现在的登入状态，这就是Session的用法之一。 从一个用户打开浏览器并连接到服务器开始到用户关闭浏览器离开这个服务器结束称做一个会话。 在多次HTTP连接间维护用户与不同请求之间关联的情况称为维护一个会话(session) 当一个用户连接到服务器时可能到不同的页面,而许多 WEB程序需要用户在客户端的一系列请求之间能够互相关联,实现不同的页面之间数据的传递和共享, 而HTTP协议是无状态的,基于WEB的应用程序需要维护这样的状态,这就需要session,利用session可以保存访问者访问页面的数据信息。 特征 会话能够把用户与同一用户发出的不同请求之间关联起来。不同用户的会话应当是相互独立的。 会话一旦建立就应当一直存在,直到用户空闲时间超过了某一个时间界限,容器才应当释放该会话资源。 例如你登入一个页面，然后很久都没有去访问了，然后就要你重新登入。称为Session过期 在会话的存活期间,用户可能给服务器发送了很多请求 ,该用户的这些请求信息都可以存储在会话中。 Session使用演示Session的属性 Session对象使用以下方法管理绑定到会话的属性 设置: void setAttribute(String name, Object value); 获取: Object getAttribute(String name); 移除: void removeAttribute(String name) ; 与Map的用法相似,其实内部就是键值对。 使用演示 创建两个Servlet 一个名为setSession 用来给session内存值设置值，一个为ShowSession用来展示session内的值 在使用session时，要先使用request对象获取HttpSession的对象才能对session进行操作使用 12345678910111213141516171819202122package SessionTest;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;public class SetSession extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpSession session = request.getSession();//获取HttpSession对象 session.setAttribute("Test","HelloWord");//往1session内存值 session.setAttribute("Test2",1234); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125;&#125; 1234567891011121314151617181920212223package SessionTest;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;public class ShowSession extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpSession session = request.getSession();//获取HttpSession对象 /*打印session内的数据*/ response.getWriter().println("从session获取的内容 :" + session.getAttribute("Test")); response.getWriter().println("从session获取的内容2 :" + session.getAttribute("Test2")); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125;&#125; 注意点: session是根据浏览器不同而不同的，例如你使用IE浏览器对session进行了设置值，然后换另一个浏览器访问展示session页面也会没有接受到session里设置的值 与ServletContext对象不同的是，当session过期或者被销毁的时候其值会消失，而不是一直存在与项目本身(主要体现与不同的浏览器进行访问) 但是，如果换一个浏览器 可以发现，这里就跟以往提到的ServletContext不同了。当换一个浏览器的时候以往给session设置的值不见了，说明session是对于浏览器来说的，即，通过浏览器来辨认不同的用户 session的ID根据上述演示实例，可以发现，同一个浏览器下session是共享的，换一个浏览器session就不同了，实质上： WEB容器在创建每一个新的HTTP会话对象时,都会赋予一个新的ID号。WEB容器保证它在Web应用范围内是唯一的。 这个ID号可以通过Session对象的getld()获得。例如:String sessionld=session.getd(); 例如：修改上例的Showsession 1234567891011121314151617181920212223242526package SessionTest;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;public class ShowSession extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpSession session = request.getSession(); response.setCharacterEncoding("utf-8"); response.setContentType("text/html;charset=UTF-8"); response.getWriter().println("从session获取的内容 :" + session.getAttribute("Test")); response.getWriter().println("从session获取的内容2 :" + session.getAttribute("Test2")); response.getWriter().println("该浏览器的SessionID为 :" + session.getId());//这里我们把sessionID打印出来 &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125;&#125; 终止Session​ 这里的终止不是说完全把session进行销毁，而是创建一个新的session，session是一直都会有的。 直接调用invalidate方法,终止会话 session.invalidate(); 设置会话超时时间,单位为秒 session.setMaxinactivelnterval(600); 在web.xml文件中配置超时时间,单位分钟 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; 当我们不设置session的timeout时,它是有默认时长的,不同的Web服务器默认时长可能不同。 Tomcat的默认超时时间是30分钟,可以在conf目录下的web. xml中查看timeout —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(2.2)ServletContext对象]]></title>
    <url>%2F2020%2F01%2F20%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2-2-ServletContext%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[servletContextServletContext官方叫servlet上下文。服务器会为每一个工程创建一个对象，这个对象就是ServletContext对象。这个对象全局唯一，而且工程内部的所有servlet都共享这个对象。所以叫全局应用程序共享对象。 它代表当前正在运行的web应用程序，也就是当前的网站。它是一个单例对象，整个web项目应用就仅此一个对象，且当web项目一启动就会创建，所以后面要使用它只能通过获取的方式 里面包含了应用程序的一些基本信息，同时这个对象也可以当做容器来存取数据，想要获取该对象，需要使用request对象进行获取 使用演示 编写两个servlet 一个为Setservlet 一个为 Showservlet 对应访问路径 1234567891011121314151617181920&lt;servlet&gt; &lt;servlet-name&gt;Setservlet&lt;/servlet-name&gt; &lt;servlet-class&gt;ServletContextTest.SetServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet&gt; &lt;servlet-name&gt;Showservlet&lt;/servlet-name&gt; &lt;servlet-class&gt;ServletContextTest.ShowServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Setservlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/src/Setservlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Showservlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/src/Showservlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 其中在Setservlet 其作用为：获取ServletContext对象然后往里面进行存值 12345678910111213141516171819package ServletContextTest;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class SetServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ServletContext app = request.getServletContext(); app.setAttribute("Test","1234Hello!!(*^▽^*)"); &#125;&#125; Showservlet 的作用为 向ServletContext对象中进行取值 1234567891011121314151617181920212223242526272829303132333435363738394041package ServletContextTest;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class ShowServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("utf-8"); response.setCharacterEncoding("utf-8"); response.setContentType("text/html;charset=UTF-8"); ServletContext app = request.getServletContext();//获取ServletContext对象 String str =(String) app.getAttribute("Test");//取得ServletContext对象中的值 PrintWriter out = response.getWriter(); out.println("&lt;HTML&gt;"); out.println("&lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;"); out.println("&lt;body&gt;"); out.println("This is "); out.println(this.getClass()); out.println(",using the Get method"); out.println("&lt;br/&gt;"); out.println("获取到的内容为Test = " + str);//输出该值 out.println("&lt;/body&gt;"); out.println("&lt;/HTML&gt;"); out.flush(); out.close(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125;&#125; 注意点： ServletContext是一个单例对象。整个Web项目都共用一个，有点类似于项目的全局变量区一样 在往ServletContext对象进行存数据时，首先要使用request对象进行获取ServletContext的对象，然后使用setAttribute(&quot;xx&quot;,&quot;aaaa&quot;);方法进行存值，其存储方式类似于map容器，是一个键值对。 在进行往ServletContext对象进行取对象时，使用getAttribute(&quot;xxx&quot;)方法进行数据取出，注意！该方法的返回值是object，所以自己要根据取出值进行类型转换 特殊情况以该上述的演示为例子，如果先进行访问Showservlet 会发现其获得的值是null，原因是它没有提前进行存值，再访问Setservlet 页面进行通过setAttribute()方法进行存值后其ServletContext对象才有对应值。 其次：只要服务器、该项目还在运行此值就将一直存在，除非通过重启 例如：不同的浏览器进行访问 可以看出ServletContext对象，无论是换一个浏览器进行访问它都存在且仅有一个，它是对于服务器来说，只要服务器、该项目还在运行此值就将一直存在，除非通过重启 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(2.1)请求响应和重定向]]></title>
    <url>%2F2020%2F01%2F19%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2-1-%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[页面跳转的两种方式 请求转发 服务器内部的转发,服务器内部跳转 RequestDispatcher dispatcher = req.getRequestDispatcher(&quot;xxx.jsp&quot;); dispatcher.forward(req.resp); 类比你向张三借钱，张三没有，然后他自己去向李四借钱然后再给你，整个过程你只提出了一次请求，得到了一次回应 重定向 服务器告诉浏览器跳转到某个页面(由浏览器完成) res.sendRedirect(“index.jsp”) 就类似你去借钱，向张三借，张三说没有，让你去找李四，然后你再去向李四借钱。整个过程你向两个人提出了请求，同时也获得了两次回应 重定向用法演示 首先创建一个Servlet(命名为Recive)其访问路径为src/Re.c 然后对其进行重定向至自己创建的HelloHtml.html 123456789101112131415161718192021222324package Rd_And_Rs;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class Recive extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("Recive`s Get is OK!"); String url = req.getContextPath(); System.out.println("URL="+ url); resp.sendRedirect(url+"/HelloHtml.html"); return;//重定向后要结束当前方法 &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 注意点 resp.sendRedirect(&quot;&quot;);这个方法会使你这个Servlet被访问时重定向跳转至括号里面的内容页面，也就是说浏览器的地址栏的内容当你访问该Servlet时会发生改变，变为上述这个方法括号内的地址 resp.sendRedirect(&quot;&quot;)这个方法括号内默认是以你该Servlet文件为基准的而不是项目路径,即：例如你这个Servlet是位于 项目路径下的 src/Demo/Servlet,你要重定向至src中的其他文件就应该../Xxx 重定向后要结束该方法。即：不应该继续执行resp.sendRedirect(&quot;&quot;)后面的代码了(重要！) request对象中的getContextPath()方法可以直接获取当前的项目路径，也就是contextRoot 重定向后之前的请求信息就没了，故不能通过表单来实现多个页面的数据传送 请求转发用法演示 首先创建两个Servlet 一个名为 show 另一个为 code 两者的地址路径分别为 ../src/show.c 和 ../src/Code 其实创建一个表单 其中这个show 将获取HelloHtml.html表单中的内容然后使用请求转发把值传至code 中进行打印 123456789101112131415161718192021222324252627/*show*/package Rd_And_Rs;import Demo.HelloServlet;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class Show extends HelloServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("Show`s Get is OK!"); RequestDispatcher dispatcher = req.getRequestDispatcher("/src/Code"); req.setAttribute("id",10223); dispatcher.forward(req,resp); return; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package Demo;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class Code extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("Post is ok"); doGet(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("Get is ok"); request.setCharacterEncoding("utf-8"); response.setCharacterEncoding("utf-8"); response.setContentType("text/html;charset=UTF-8"); PrintWriter out = response.getWriter(); out.println("&lt;HTML&gt;"); out.println("&lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;"); out.println("&lt;body&gt;"); out.println("This is "); out.println(this.getClass()); out.println(",using the Get method"); out.println("&lt;br/&gt;"); out.println("你好世界！注册成功！您的id为" + request.getAttribute("id")); out.println("&lt;br/&gt;"); out.println("用户名为： " + new String(request.getParameter("un"))); out.println("&lt;br/&gt;"); out.println("密码为： " + request.getParameter("pw")); out.println("&lt;br/&gt;"); out.println("请牢记！你们用户名和密码（づ￣3￣）づ╭❤～"); out.println("&lt;/body&gt;"); out.println("&lt;/HTML&gt;"); out.flush(); out.close(); &#125;&#125; 注意点： 注意乱码问题！ 要使用请求转发 首先要获取一个RequestDispatcher对象，该对象可以通过request对象的getRequestDispatcher(&quot;xx&quot;);方法进行获取。其实使用该RequestDispatcher对象的方法 forward(req,resp);进行跳转至request对象的getRequestDispatcher(&quot;xx&quot;);方法括号中填写的页面 注意！getRequestDispatcher(&quot;xx&quot;);该方法中的参数 默认是以项目路径为准的，而不像重定向中以该Servlet 文件为准，即：你在括号中只填一个‘&#39;/&#39;它意味着是项目路径 下的 xxxx 请求转发可以实现每个页面的数据传送不像重定向。 请求转发中使用request对象的setAttribute(“xx”,aaaa);和 getAttribute(&quot;xx&quot;)方法自行设置传输数据和获取自定义的数据 请求转发中进行跳转时默认是使用post进行数据提交 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(1.4)Servlet响应、请求乱码问题]]></title>
    <url>%2F2020%2F01%2F18%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-1-4-Servlet%E5%93%8D%E5%BA%94%E3%80%81%E8%AF%B7%E6%B1%82%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[响应时的乱码当Servlet向网站进行响应时，在响应的过程中，Java源程序的中文字符串数据发生至网站站点，可能会出现乱码问题，如下面的例子 1234567891011121314151617181920212223242526272829303132package Demo;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class Code extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("Post is ok"); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("Get is ok"); response.setContentType("text/html"); PrintWriter out = response.getWriter(); out.println("&lt;HTML&gt;"); out.println("&lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;"); out.println("&lt;body&gt;"); out.println("This is "); out.println(this.getClass()); out.println(",using the Get method"); out.println("&lt;br/&gt;"); out.println("你好世界"); out.println("&lt;/body&gt;"); out.println("&lt;/HTML&gt;"); out.flush(); out.close(); &#125;&#125; 上文是通过get请求，当打开该servlet后，会打印一个html页面出来。 可以发现，响应至网站的内容含有中文的部分变为乱码 无法识别 解决方案1对于本案例，可以直接在html标签中的&lt;Head&gt;标签中添加&lt;meta charset = &#39;utf-8&#39;/&gt;来实现 1234567891011121314response.setContentType("text/html"); PrintWriter out = response.getWriter(); out.println("&lt;HTML&gt;"); out.println("&lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;meta charset = 'utf-8'/&gt;&lt;/HEAD&gt;");//进行添加&lt;meta charset = 'utf-8'/&gt; out.println("&lt;body&gt;"); out.println("This is "); out.println(this.getClass()); out.println(",using the Get method"); out.println("&lt;br/&gt;"); out.println("你好世界"); out.println("&lt;/body&gt;"); out.println("&lt;/HTML&gt;"); out.flush(); out.close(); 解决方案2 可以直接对content-type属性进行设置 12345//response.setContentType("text/html");response.setContentType("text/html;charset = utf-8");//对其识别字符集进行设置 PrintWriter out = response.getWriter(); out.println("&lt;HTML&gt;"); out.println("&lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;"); 附加：content-type Content-Type MediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。 常见的媒体格式类型如下： text/html ： HTML格式 ​ text/plain ：纯文本格式 ​ text/xml ： XML格式 ​ image/gif ：gif图片格式 ​ image/jpeg ：jpg图片格式 ​ image/png：png图片格式 以application开头的媒体格式类型： application/xhtml+xml ：XHTML格式 application/xml ： XML数据格式 application/atom+xml ：Atom XML聚合格式 application/json ： JSON数据格式 application/pdf ：pdf格式 application/msword ： Word文档格式 application/octet-stream ： 二进制流数据（如常见的文件下载） application/x-www-form-urlencoded ： &lt;form encType=&quot;&quot;&gt;中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式） 另外一种常见的媒体格式是上传文件之时使用的： ​ multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式 请求时的乱码当我们通过表单进行获取用户名或者密码的时候，通常可能会出现提交的时候用户名是中文字符，当提交至服务器进行处理的时候，这个阶段就可能会出现中文的乱码。 通过post提交来处理 12345678protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("Post is ok"); String n = request.getParameter("um"); String pw = request.getParameter("pw"); System.out.println("用户名:" + n); System.out.println("密码:" + pw);&#125; 对于post提交解决方案1通过使用 request.setCharacterEncoding(&quot;utf-8&quot;);来设置请求req对象的获取请求的字符集 12345678910protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("Post is ok"); request.setCharacterEncoding("utf-8");//设置获取的字符集 String n = request.getParameter("um"); String pw = request.getParameter("pw"); System.out.println("用户名:" + n); System.out.println("密码:" + pw); &#125; —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(1.3)Servlet实操、获取表单内容]]></title>
    <url>%2F2020%2F01%2F16%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-1-3-Servlet%E5%AE%9E%E6%93%8D%E3%80%81%E8%8E%B7%E5%8F%96%E8%A1%A8%E5%8D%95%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[HTTP请求方式 HTTP协议定义了GET和POST两种请求方法，POST方法是对请求发送的数据量没有限制 GET是使用明文在浏览器地址栏直接显示请求字符串 post是将数据隐含在HTTP协议的请求报文中发送至服务器 说白了。GET请求是在用浏览器地址栏直接访问才会发出，而post为网页来发出的隐性请求。从方式来看Post请求比Get请求更加安全。 Servlet实操Servlet的两个入口Servlet的两个入口也就是上面说的Get和Post，要实现网页网站与Servlet的交互就是通过Get和Post来做到。 Servlet的配置与编写Servlet的编写在创建好JavaWeb项目后在src包中编写一个Servlet并让其继承于HttpServlet类。 根据上述，要实现网站与Servlet的交互就要通过Get和Post来实现，所以可以通过Servlet类中的doGet和doPost的方法重写来实现上述操作 123456789101112131415161718192021package Demo;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class Test extends HttpServlet &#123; /*重写doGet和doPost方法*/ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("服务器接到了Get请求"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("服务器接到了Post请求"); &#125;&#125; Servlet的配置完成Servlet文件的编写后，如何通过项目的网页来运行它。这就要在项目的XML文件对这个Servlet进行配置 1234567891011121314151617181920&lt;!--Web.xml--&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;servlet&gt; &lt;servlet-name&gt;ShuHao&lt;/servlet-name&gt; &lt;servlet-class&gt;Demo.Test&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ShuHao&lt;/servlet-name&gt; &lt;url-pattern&gt;/src/Test&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 在&lt;web-app&gt;标签内添加&lt;servlet&gt;标签用来引用编写的servlet，其中&lt;servlet-name&gt;来标组servlet的名字 然后在&lt;servlet-class&gt;给出对应要实现的servlet所在的项目路径。 完成上诉后，还不能运行所编写的servlet，还要对项目的servlet进行路径连接，通过&lt;servlet-mapping&gt;标签来编辑配置servlet的连接。同样&lt;servlet-name&gt;标签来指明&lt;servlet&gt;标签内所添加的servlet名，而&lt;url-pattern&gt;标签则为设置servlet的链接结点地址映射。 完成后即可运行Tomcat服务器来启动该项目 上面演示的就为servlet的编写与配置的简单演示 servlet实操 通过post请求获取网站表单内容方法介绍开始之前，servlet如何来获取网站里的内容？它实质是通过doGet或者doPost中获取的requst对象来获取网站中提取的内容。 对此有下列方法来实现提取网站返回的requst对象中的内容 说明 方法名 获取单值请求参数的方法 getParamter(); 获取多值请求参数地方 getParamterValues(); 获取请求参数名字的方法 getParamterNames(); 获取session对象的方法 getSession(); 获取Web应用根路径的方法 getContextPath(); 获取Servlet路径的方法 getServletPath(); 获取request中的属性的方法 getAttribute(); 设置request中的属性的方法 setAttribute(); 获取请求转发对象的方法 getRequsetDispatcher(); 例子：获取网站中表单中内容表单页面的实现所先通过项目自带的index.jsp来实现一个简单表单 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;%-- Created by IntelliJ IDEA. User: ShuHao Date: 2020/1/15 Time: 17:05 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;ShuHao`s Test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; This is a page of index； &lt;form action="./src/DataPost.php" method="post"&gt; 用户名： &lt;input type="text" name="UserName"/&gt; &lt;br/&gt; 性别： &lt;input type="radio" name="Sex" value="NULL" checked&gt;私密&lt;/input&gt; &lt;input type="radio" name="Sex" value="Man" &gt;男&lt;/input&gt; &lt;input type="radio" name="Sex" value="Woman"&gt;女&lt;/input&gt; &lt;br/&gt; 爱好： &lt;input type="checkbox" name="Hobby" value="Reading"&gt;看书&lt;/input&gt; &lt;input type="checkbox" name="Hobby" value="Shopping"&gt;购物&lt;/input&gt; &lt;input type="checkbox" name="Hobby" value="Sport"&gt;运动&lt;/input&gt; &lt;br/&gt; 城市： &lt;select name="City"&gt; &lt;option value="BeiJing"&gt;北京&lt;/option&gt; &lt;option value="ShangHai"&gt;上海&lt;/option&gt; &lt;option value="GuangDong"&gt;广东&lt;/option&gt; &lt;option value="Etc"&gt;其他&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; 个人描述: &lt;br/&gt; &lt;textarea name="introduction" id="" cols="30" rows="10"&gt;&lt;/textarea&gt; &lt;br/&gt; &lt;input type="submit"value="提交！_(:з」∠)_"/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 这里要注意。表单&lt;form&gt;标签内的action要填写对应servlet对应的链接结点地址映射，提交方法为post请求 servlet的编写页面点击提交后，程序只会看对应表单内的name属性和value属性 123456789101112131415161718192021222324252627282930313233343536373839package Demo;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class MyServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; /*防止乱码，在使用response对象和request对象的时候就提前设置好字符编码*/ resp.setCharacterEncoding("UTF-8"); req.setCharacterEncoding("UTF-8"); String name = req.getParameter("UserName"); System.out.println("用户名：" + name); System.out.println("性别:" + req.getParameter("Sex")); String[]hobby = req.getParameterValues("Hobby"); System.out.print("爱好："); for (String str:hobby)System.out.print(str+","); System.out.println(); System.out.println("城市:" + req.getParameter("City")); System.out.println("个人介绍:\n" + req.getParameter("introduction")); resp.getWriter().print("&lt;html&gt;&lt;body&gt;&lt;h1&gt;Data is Posted&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("服务器接到了Post请求"); doGet(req,resp); &#125;&#125; 对应的servlet地址映射为“/src/DataPost.php” 测试 点击提交后 其他对应多个servlet进行配置对应多个servlet进行配置的时候，要通过多个&lt;servlet&gt;标签 例如：我要对一开始编写的名为Test的servlet和实操例子中的名为MyServlet的servlet进行配置，则要分开进行对其逐一配置 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;servlet&gt; &lt;servlet-name&gt;ShuHao&lt;/servlet-name&gt; &lt;servlet-class&gt;Demo.MyServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet&gt; &lt;servlet-name&gt;Test&lt;/servlet-name&gt; &lt;servlet-class&gt;Demo.Test&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ShuHao&lt;/servlet-name&gt; &lt;url-pattern&gt;/src/DataPost.php&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Test&lt;/servlet-name&gt; &lt;url-pattern&gt;/src/Test&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 对于项目web.xml项目中 &lt;url-pattern&gt;标签中的内容&lt;url-pattern&gt;标签内的地址映射可以写除中文和其他字符的所有内容，把地址写为后缀.php都可以。 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(1.2)Tomcat配置编辑器及Servlet介绍]]></title>
    <url>%2F2020%2F01%2F15%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-1-2-Tomcat%E9%85%8D%E7%BD%AE%E7%BC%96%E8%BE%91%E5%99%A8%E5%8F%8AServlet%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[IDEA添加Tomcat自用：https://blog.csdn.net/wsjzzcbq/article/details/89463304 Servlet简介 Servlet是用Java语言编写的程序，它运行在Web服务器上，用以处理来自客户端的请求； 它一般会把处理的结果以HTML形式进行返回，在客户端形成动态网页 优点 Servlet运行在Web服务器中，可以扩展服务器的功能 Servlet可以和其他资源交互(例如：用文件IO流读取文件)，从而返回给客户端相应的内容，这样就形成了动态网页； 使用Java编写，所以能够跨平台 Java的所有优点都可以在Servlet中体现； Servlet很安全，因为访问Servlet的唯一途径是通过服务器 只有符合Servlet规范的Servlet容器(例如：Tomcat)都可以运行Servlet Servlet容器 Servlet和我们以往见过的普通Java类一样，在需要的时候被实例化，在不需要的时候被销毁，而Servlet的实例化和销毁工作由 Servlet容器 来完成 Servlet在Servlet容器内运行，Servlet容器 负责调度Servlet，并控制着Servlet的生命周期 Tomcat 即是Web服务器软件，同时也是符合规范的Servlet容器 Servlet生命周期 Servlet常用核心API 接口名 说明 包 Servlet 这是每个Servlet都必须实现的接口，它定义了一系列必须由Servlet实现的方法 Java.servlet ServletRequest 此接口用于将客户端的请求信息传送给Servlet Java.servlet ServletResponse 此接口用于对客户端做出响应 Java.servlet HttpServletRequest 该接口扩展ServletRequest接口，定义了一系列于描述HTTP请求的方法 Java.servlet.http HttpServletResponse 该接口扩展ServletResponse接口，提供服务器对客服端的响应对象 Java.servlet.http IDEA Servlet 快速上手 创建一个JavaWeb动态Web项目 在项目src文件中创建包和类 编写类文件 注解@WebServlet(&quot;XXXX&quot;)括号内为地址文件 例如 @WebServlet(&quot;/hello.html&quot;)在Tomcat服务器启动后 可以使用 localhost:8080/hello.html 来执行该类中的代码 需要继承HttpServlet类再实现其内部的方法 1234567891011121314151617package Demo;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet("/hello.html")public class HelloServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("代码被执行"); resp.getWriter().print("&lt;script&gt;alert('He1231231231231231266666666666666ld')&lt;/script&gt;"); &#125;&#125; 实验结果： —(本文完)]]></content>
      <categories>
        <category>代码学习</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构解题错题和知识积累]]></title>
    <url>%2F2020%2F01%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E9%A2%98%E9%94%99%E9%A2%98%E5%92%8C%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[数据结构基础知识 计算机算法指的是解决某一问题的有限运算序列 常用的时间复杂度所耗费的时间从小到大依次是： O(1 )&lt; O(logn) &lt; O(n) &lt; O(n*logn) &lt; O(n2) &lt; O(n3) &lt; O(2n) &lt; O(n!) &lt; O(nn) 若一个算法的时间复杂度用T(n)表示着这个n代表的是该_问题的规模_ 算法的5个重要特征有 有穷性：一个算法一定要保证在有限步之后结束。 确定性：算法的每一步骤必须有确切的定义 输入：一个算法必须有输入，可以是0个也可以是多个 输出：一个算法必须有输出，可以是一个或多个，没有输出的算法是没有意义的 可行性：算法原则上能够精确地运行，而且做有限次运算后即可完成 算法的计算量大小称算法的 时间复杂度 数据结构通常是研究数据的 存储结构和逻辑结构 及它们之间的相互联系 抽象数据类型与计算机内部表示和实现无关 数据的逻辑结构与数据元素本身的内容和形式无关 数据的最小单位是 数据项 在数据结构中，从逻辑上可以分为 线性结构和非线性结构 线性表基础知识： 数据结构上相互之间存在_一种或多种特定关系_的数据元素的集合 在单链表中设置头节点的作用是_简化插入和删除操作_ 数据的逻辑结构是数据间关系的描述 线性表是典型的线性结构 顺序表将线性表中数据元素之间的相邻关系映射为数据物理位置上的相邻关系 带头节点的双向循环链表为空表的条件是 _head == head-&gt;next_ 顺序存储结构是通过_结点物理上的相邻_表示元素之间的关系 链式存储结构上通过_指针_表示元素之间的关系 线性表习题1.在顺序表(长度为127)中插入一个元素平均（63.5）个元素。 解决：在长度为n的顺序表中插入一个元素平均移动2/n个元素 2.单链表中，增加一个头结点的目的是为了(方便运算) 解决：头结点的目的是为了(方便运算) ​ 栈，队列，数组栈 函数调用时，系统要用栈保存必要的消息 栈和队列都是线性表，只是在插入和删除时受到了限制(true) 消除递归不一定需要使用栈(true) 队列 循环队列可以解决普通队列中假溢出的问题(循环队列防止假溢出) 循环队列中的一些常用判断条件 队列为满的条件：(rear + 1) % MaxSize == front 队列为空的条件：front == rear 队列中元素的个数：(rear - front + MaxSize) % MaxSize 入队：rear = (rear+1) % MaxSize 出队：front = (front+1) % MaxSize 用链接方式存储的队列，在进行插入运算时 头、尾指针可能都要修改 用循环链表表示的队列长度为n，若只设头指针，则出队和入队的时间复杂度分别是O(1)和O(n);若只设尾指针，则出队和入队的时间复杂度分别是O(1)和O(1) ​ 串 KMP算法的特点是在模式匹配时指示主串的指针不会变小。 串是一种特殊的线性表，特殊在数据元素是一个字符 设有两个串S1和S2，求S2在S1首次出现的位置的运算称作模型匹配 字符串的子串数目为 n(n+1)/2 + 1（这里的加一是把空串也加上了） 栈，队列，数组的习题1.一个栈的输入序列为123….n,若输出序列的第一个元素是n,输出第i(1 &lt;= i &lt;=n)个元素是(n-i+1) 解决：使用代入法 当n等于 4的时候 输出第一个元素就为4 第二个为 3 通过代入获得 错因：以为第一个取出后整体长度变短了一位 2.已知字符串S为“abaabaabacacaabaabcc”. 模式串t为“abaabc”, 采用KMP算法进行匹配，第一次出现“失配”(s[i] != t[i])时，i = j = 5,则下次开始匹配时，i和j的值分别是（i = 5; j = 2） 解决： 3.设S为一个长度为n的字符串,其中的字符各不相同，则S中的互异的非平凡子串(非空且不同于S本身)的个数为( n(n+1)/2 - 1 ) 解决：比如S字串为”abcdefg”,长度为7.则S中的包含的互不相同的字串有如下一些：1.长度为6的个数为2：”abcdef”和”bcdefg”2.长度为5的个数为3：”abcde”,”bcdef”,”cdefg”.6.长度为1的个数为7：”a”,”b”,”c”,”d”,”e”,”f”,”g”个数总和就是2+3+4+5+6+7 = (1+2+3+..+7) - 1 = 7x(7+1)/2 - 1.其中：1+2+3+…+n = (1+n) + (2+(n-1)) + (3+(n-2)) + …（首尾两项相加的和都是n+1,共 n/2个）= n(n+1)/2 再减去S本身 得n(n+1)/2 - 1 4.组成串的数据元素只能是(字符、【字符型】、【char】) 解决：组成串的数据元素只能是(字符、【字符型】、【char】) 5.字符串“ababaaaab”的nextVal数组值序列为(-1 0 -1 0 -1 3 1 0） 解决： 12345678910先给字符串进行标号1 2 3 4 5 6 7 8 9 a b a b a a a a b 0 0 1 2 3 1 1 1 2 //求最大前缀后缀-1 0 0 1 2 3 1 1 1 //消除最后一位，前面补-1 右移动对齐 0 1 1 2 3 4 2 2 2 //然后加1 得到next数组 (对应版本的next数组需要减 1 )0 1 0 1 0 4 2 2 1 //然后next数组与最大前缀后缀进行比较，如果相等填next数组对应的值，如果不相等 则填此时next数组值对应一开始标号序号的next值得到的最终结果 0 1 0 1 0 4 2 2 1 //全部减一得到 -1 0 -1 0 -1 3 1 1 0 //为最终答案 树与二叉树二叉树 树的后根遍历序列等同于该树对应二叉树的中序遍历 后根遍历就是后序遍历、中根，前根一样 将森林转换成二叉树后，有以下的性质 森林叶结点 n0 的个数是其对应二叉树中 左指针为空的结点个数 森林中 度为1的结点 n1 的个数是其对应二叉树中，右指针为空的结点个数 采用孩子兄弟链表作存储结构，树的前序遍历和其相应的二叉树的前序遍历的结果是一样的 给定一颗树，可以找到唯一的一颗二叉树与之对应 哈夫曼树 哈夫曼树中，所有的字符串结点都是和其他字符串结点或者权值结点构成子树，因此不可能存在度为1的结点 即：哈夫曼树中一定没有度为1的结点 树中两个权值最小的结点一定是兄弟结点。 树中任一非叶结点的权值一定不小于下一任一结点的权值 若从二叉树的任一个结点出发，到根的路径上所经过的结点序列按其关键字有序，则该二叉树一定是哈夫曼树（X） 一棵哈夫曼树的带权路径长度等于其中所有分支结点的权值之和 (X) 在哈夫曼树中，任何一个结点的度都是( 0 或 2 ) 堆 从堆中删除一个元素的时间复杂度为(O(logn)) 二叉树对应的一些公式 哈夫曼树的总结点数与叶节点数的关系 由于哈夫曼树中没有度为1得结点. 只有度为0和度为2得结点. 则一棵有n个叶子结点得哈夫曼树共有2n-1个结点 在含有n个结点的树中，边数只能是 n-1 条 完全二叉树中，结点个数为n，结点的编号从1开始，则编号最大的分支结点的编号为 n/2 一颗树高为K的完全二叉树至少有 2k-1 个结点 一棵高为k的完全二叉树，当第k层只有最左边一个结点时具有最少的结点。根据二叉树的性质，第1层到第k-1层共有结点2k-1 - 1个，因此它至少有2k-1 - 1 + 1 = 2k-1个结点。 有 n 个结点，并且高度为 n 的二叉树的数目为 2n-1 叶子结点和二度结点数目关系：n0=n2+1 二叉树中的度只算出度，往下的出度为多少其度数就为多少 如果这是一个完全二叉树，那么一度结点的个数是有限的，要么为0要么为1。所以可以最后得到结点总数目和叶子结点的关系： 当n1=0时，n=2n0-1所以n0=(n+1)/2。这里的n为奇数。 当n1=1时，n=2n0所以n0=n/2。这里的n为偶数。 一个具有n个节点的完全二叉树,其叶子节点的个数n0为: (n+1) / 2 向下取整。(重要！！！) 二叉树中的一些习题1 将森林转换为对应的二叉树，若在二叉树中，结点u是结点v的父结点的父结点，则在原来的森林中，u和v可能具有的关系是( )Ⅰ．父子关系Ⅱ．兄弟关系Ⅲ．u的父结点与v的父结点是兄弟关系（X） 解析：森林与二又树的转换规则为“左孩子右兄弟”。在最后生成的二叉树中，父子关系在对应森林关系中可能是兄弟关系或原本就是父子关系。情形Ⅰ：若结点v是结点u的第二个孩子结点，在转换时，结点v就变成结点u第一个孩子的右孩子，符合要求。情形Ⅱ：结点u和v是兄弟结点的关系，但两者之中还有一个兄弟结点k，则转换后，结点v就变为结点k的右孩子，而结点k则是结点u的右孩子，符合要求。情形Ⅲ：结点v的父结点是原先的父结点或兄弟结点。若结点u的父结点与v的父结点是兄弟关系，则转换之后，不可能出现结点u是结点v的父结点的父结点。 2.若用一维数组表示一个深度为5、结点个数为10的二叉树，数组的长度至少为(16) 相关知识：二叉树存储在一个一维数组时，是以层次遍历来存储进一位数组的 3.已知一棵完全二叉树的第6层（设根是第1层）有8个叶结点，则该完全二叉树的结点个数最多是（111） 解析：即第六层有32个节点，其中有8个是叶子节点，说明其余24个是有子节点的，又由于是完全二叉树，所以那24个节点每个节点有2个子节点，共计48个节点，也就是第七层的节点有48个，所以前六层的63加第七层的48就是111个节点了 4.若一棵二叉树的前序遍历序列为a，e，b，d，c，后序遍历序列为b，c，d，e，a，则根结点的孩子结点（A.只有e）A．只有eB．有e、bC．有e、cD．无法确定 解析：根据题中给出的二叉树的前序遍历a、e、b、d、c和后序遍历b、c、d、e、a可以确定的是a为二叉树的根结点。那么根据前序遍历的访问次序为根结点、左子树、右子树，可以确定e为左子树或右子树的根结点，即根结点的孩子结点。假设e为左孩子结点，那么根据后序遍历的结果可知，b、c、d一定在左子树上，不可能为a的孩子结点。若e为右子树的根结点，根据前序遍历结果可知，此二又树没有左子树。 5.设F是一个森林,B是由F变换得到的二叉树.F中有n个非终端结点,则B中右指针域为空的结点为（C.n+1 ）A.n-1 B.n C.n+1 D.n+2 解析：F有n个非终端节点,所以转换为二叉树后所有的空的右指针域(right)就是n个.根节点没有兄弟,所以该右指针域也为空.(注:这里根节点也是一个有指针域.上文中根节点属于非终端节点,那里它所指向的右指针域不是它本身而是它的最右边的儿子.)所以综上,二叉树中右指针域为空的节点有(n+1)个. 6.将森林F转换为对应的二叉树T，F中叶结点的个数等于 （C. T中左孩子指针为空的结点个数）A. T中叶结点的个数 B. T中度为1的结点个数 C. T中左孩子指针为空的结点个数 D. T中右孩子指针为空的结点个数 解析：在二叉树中，节点的左指针指向其孩子，节点的右指针指向其兄弟。所以在一颗二叉树中，如果某个节点的左指针为NULL，就说明这个节点在原来的森林中没有孩子，是叶子结点，如果某个节点的右指针为NULL，就说明这个节点在原来的森林中没有兄弟。 所以森林中的叶子节点=二叉树中左指针为NULL的个数 7.一棵124个叶结点的完全二叉树，最多有(B. 248)个结点。A. 249 B. 248 C. 250 D. 247 解决：根据公式：一个具有n个节点的完全二叉树,其叶子节点的个数n0为: (n+1) / 2 向下取整，且题目中要求是最多几个结点，那么就极端假设，有N个结点，代入公式最大值有124.5个叶结点，向下取整得到的124个叶结点，所以用124.5反代公式得到的结果最多有248个结点 图基础知识 图的深度遍历是一个递归过程 用邻接表存储图所用的空间大小(与图的顶点数和边数都有关) 判断一个有向图是否有环（回路）除了拓扑排序方法，还可以用( 深度优先遍历 ) 若用邻接矩阵存储有向图，矩阵中主对角线以下的元素均为零，则关于该图拓扑序列的结论是 存在，可能不唯一 在有向图G的的拓扑序列中，若顶点Vi在顶点Vj之前，则下列情形不可能出现的是 G中有一条从Vi到Vj的路径 回路 不是 简单路径 在有向图的邻接表存储结构中，顶点v在链表中出现的次数是 顶点v的入度 当各边上的权值 均相等 时，BFS算法可用来解决单源最短路径问题 无向连通图中，边数不一定大于顶点个数减1 无向连通图中，所有顶点的度数之和为偶数 无向连通图中，至少有一个顶点的度为1 ( X ) 迪杰克斯拉 最短路径算法从源点到其余顶点的最短路径的路径长度按 递增 次序依次产生，当弧上的权值为 负数 时，该算法不能正确产生最短路径 若一个有向图具有拓扑排序序列，那么它的邻接矩阵必定为 一般矩阵 用邻接表存储图所用的空间大小 与图的顶点数和边数都有关 n 个结点的无向图。若不允许结点到自身的边，也不允许结点到自身的边，也不允许结点到结点的多重编，且边的总数为 n(n-1)/2,则该无向图一定是连通图 Floyed 求每对不同顶点对的算法中运行弧上的权为负，但不能有权和为负的回路 连通图上各边权值均不相同，则该图的最小生成树是唯一的 时间复杂度 对有 n 个顶点，e 条边且使用邻接表存储的有向图进行广度优先遍历，其算法时间复杂度是( O(n+e) ) 若将 n 个顶点 e 条弧的有向图采用邻接表存储，则拓扑排序算法的时间复杂度( O(n+e) ) 生成树 图的BFS生成树的树高 h1 比DFS生成树的树高 h2 (小或者相等) 图的一些公式 设无向图的顶点个数为n，则该图最多有 n (n-1) / 2 条边。 一个有n个结点的图，最少有 1 个连通分量，最多有 n 个连通分量。 在一个无向图中，所有顶点的度数之和等于所有边数的 2 倍； 要连通具有 n 个顶点的有向图，至少需要 n 条边 （掉坑数：1） 一个 n 个顶点的连通无向图，其边的个数至少为 n-1 在有n 个顶点的有向图中，每个顶点的度最大可达 2*(n-1) n 个结点的完全有向图含有边的数目 n*(n-1) 握手定理：各顶点度数之和 = 边数的两倍 在有 n 个顶点的有向图中，若要使任意两点间可以互相到达，则至少需要 n 条弧 若用 n 表示图中顶点数目，则有 n*(n-1)/2 条边的无向图称为完全图 无向图G 中有n个顶点 e条边，则其对应的邻接表中的表头结点 个数为 n ； 边表结点的个数为 2e 图的一些习题1.G是一个非连通无向图，共有28条边，则该图至少有 9 个顶点 解析：假设至少有N个顶点。由于是非连通图，并且要满足28条边，所以N=边为28的完全图（顶点最少）的顶点数+1（与完全图不连通）。 完全图边数=28，解n(n-1)/2=28，得n=8，因此N=8+1=9. 2.下列关于无向连通图特性的叙述中，正确的是(A )Ⅰ．所有顶点的度之和为偶数Ⅱ．边数大于顶点个数减1Ⅲ．至少有一个顶点的度为1 A．只有ⅠB．只有ⅡC．Ⅰ和ⅡD．Ⅰ和Ⅲ 解析：考查无向连通图的特性。Ⅰ．每条边都连接了两个结点，则在计算顶点的度之时，这条边都被计算了两次，故所有顶点的度之和为边数的两倍，显然必为偶数。Ⅱ．边数大于顶点个数减1，如果定点数为3，则边数为2，边数=定点个数减1；Ⅲ．在顶点数n≥3的完全有向图中，没有度为1的节点，如下图所示： 注意：对顶点数n≥3的无向完全图，不存在度为1的顶点，并且边数与顶点数的差要大于等于0。 3.若无向图G(V，E)中含7个顶点，为保证图G在任何情况下都是连通的，则需要的边数最少是(C )A．6B．15C．16D．20 解析：要保证元向图G在任何情况下都是连通的，即任意变动图G中的边，G始终保持连通，首先需要G的任意6个结点构成完全连通子图G1，需15条边，然后再添一条边将第7结点与G1连接起来，共需16条边。 排序与查找Hash表 为提高散列（Hash）表的查找效率，可以采取的正确措施是 设计冲突少的散列函数 哈希查找中 不存在特别好与坏的哈希函数，要视情况而定 用哈希方法处理 冲突 时可能出现堆积现象，其中 平均查找长度 会手堆积现象的直接影响 随着装载因子a的增大，用闭散列法解决冲突，其平均搜索长度比用开散列法解决冲突时的平均搜索长度增长得慢 （X） 开放地址法：Hi=(H(key)+di) mod m, 其中H(key)为哈希函数，m为哈希表长，di为增量序列，增量序列有以下取法： di=1,2,3,4….,m-1 称为线性探测再散列 di=1^2 ，- 1^2,2^2，- 2^2，…..,k^2,-k^2(k&lt;=m/2),称为二次探测再散列 di=伪随机数序列，称为随机探测再散列； 采用线性探测法处理散列时的冲突，当从哈希表删除一个记录时，不应将这个记录的所在位置置空，因为这会影响以后的查找 排序 在排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一趟排序。其中 每一趟排序结束时都至少能够确定一个元素最终位置的方法是 简单选择排序、快速排序、堆排序 归并排序既适合内排序也适合外排序 若不考虑基数排序，则在排序过程中，主要进行的两种基本排序操作是关键字的 比较 和记录的 移动 为实现快速排序算法，待排序序列宜采用的存储方式是 顺序存储 n 个待排序的记录关键字，则在堆排序中需要 1 个辅助记录单元 查找 当采用分块查找时，数据的组织方式为 数据分成若干块，每块内数据不必有序，但块间必须有序，没块内最大(或最小)的数据组成索引块 时间复杂度 设被排序的结点序列共有N个结点，在该序列中的结点已十分接近排序的情况下，用直接插入法的时间复杂度为O(N),用 归并法 的时间复杂度为O(N*logN) 用快速排序法的时间复杂度为O(N^2) 公式 假定有K个关键字互为同义词，若用线性探测法吧这K个关键字存入散列表中，至少要进行k*(K+1)/2次探测 习题1.分别采用堆排序、快速排序、冒泡排序和归并排序，对初态为有序的表，则最省时间的是 冒泡排序，最费时间的是 快速排序 扩展解析:简单排序的算法（直接插入，冒泡，简单选择排序）简单且稳定，适合与待排记录较小的情况，当当待排序的关键码序列已经基本有序时，用直接插入排序最快。就平均时间的性能而言，快速排序最佳，即排序速度最快，所以在随机情况下，快速排序是最佳选择。一般情况下，快速排序效率最好。既要节省空间，又要有较快的排序速度，堆排序是最佳选择，其不足之处是建堆时需要消耗较多时间。若希望排序是稳定的，且有较快的排序速度，则可选用2路归并排序，其缺点需要较大的辅助空间分配 2.采用线性探测法处理散列时的冲突，当从哈希表删除一个记录时，不应将这个记录的所在位置置空，因为这会影响以后的查找(正确) 解析：考虑置空位置a后面存有数b，当查询b的时候，可能由于查询到a位置为空，就不往下查了，导致查询结果错误]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(1-1)Tomcat安装与使用介绍]]></title>
    <url>%2F2020%2F01%2F14%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-1-1-Tomcat%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Tomcat介绍​ Tomcat 服务器是一个免费的开放源代码的Web 应用服务器是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应HTML（标准通用标记语言下的一个应用）页面的访问请求。 ​ 说白了就是可以帮助你搭建服务器，从而上传自己的网站站点。当你访问开启Tomcat服务器电脑或者服务器的IP地址时即可访问该电脑或服务器里面的内容。 Tomcat的安装 安装步骤 进入官网下载安装包 压解安装包 配置环境变量(重要！因为Tomcat是依靠于系统环境变量中的JAVA_HOME变量) 打开安装包里面的bin文件目录下的startup.bat 打开浏览器 输入地址 localhost:8080验证安装是否成功 安装包的下载 Tomcat官方站点 http://tomcat.apache.org 获取Tomcat安装包 tar.gz文件是Linux操作系统下的安装版本 exe文件是window系统下的安装版本 zip文件是Windows系统下的压缩版本(推荐！压解即可运行) 环境变量的配置 JAVA_HOME 中必须配置，内容为jdk安装目录 Path 中需要把jdk文档中的bin目录添入 启动Tomcat服务器打开Tomcat文件目录下的bin文件里面的startup.bat，当出现Server startup in xxxx ms时 即为启动Tomcat服务器成功 打开浏览器输入本机IP地址验证是否启动成功在浏览器中输入 localhost:8080 或者 127.0.0.1:8080 若打开的内容为下图所示即为 Tomcat 服务器安装且启动成功 Tomcat的其他问题 为啥一定要是8080端口？ 这个为Tomcat默认的端口设置，倘若端口被占用或者想修改为其他端口可以在Tomcat目录下的conf 中的server.xml文件中修改 123456789101112131415161718&lt;!--server.xml--&gt; &lt;!-- A "Connector" represents an endpoint by which requests are received and responses are returned. Documentation at : Java HTTP Connector: /docs/config/http.html (blocking &amp; non-blocking) Java AJP Connector: /docs/config/ajp.html APR (HTTP/AJP) Connector: /docs/apr.html Define a non-SSL HTTP/1.1 Connector on port 8080 --&gt; &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; &lt;!-- A "Connector" using the shared thread pool--&gt; &lt;!-- &lt;Connector executor="tomcatThreadPool" port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; --&gt; 在上面的port 后的 8080 修改为其他端口即可 注意！：修改后应该重启Tomcat服务器才会生效 Tomcat中发布自己的站点在Tomcat文件中有一个webapps文件 里面即可放置自己的站点文件 来通过 服务器开启IP地址来访问对应的站点 或者文件 这里我们在webapps创建一个myweb文件夹 里面放置了一个图片和一个测试的网站 然后在Tomcat开启的IP地址后加/myweb/xxx..来访问对应的内容 虚拟目录映射虚拟目录映射就是把 你实际的目录例如上面的127.0.0.1:8080/myweb/xxx..中的myweb/xxx等实际目录信息替换成别的字符串，来起到便捷或者安全的作用 。 例如：把 myweb/xxx替换成 hello 即 使用地址 127.0.0.1:8080/hello也可访问到127.0.0.1:8080/myweb/xxx..所访问的内容 如何设置 打开tomcat目录中的conf文件下的server.xml 在该文件下的 &lt;Host&gt; ...&lt;/Host&gt;中添加 &lt;Context path =&quot;/XXXX(虚拟目录名称)&quot; docBase = &quot;myweb/xxx.(实际目录的名称)&quot;/&gt; 123456789101112131415161718 &lt;!--server.xml--&gt;&lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; &lt;!-- SingleSignOn valve, share authentication between web applications Documentation at: /docs/config/valve.html --&gt; &lt;!-- &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt; --&gt; &lt;!-- Access log processes all example. Documentation at: /docs/config/valve.html Note: The pattern used is equivalent to using pattern="common" --&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log." suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;/Host&gt; 在Host区域内添加相应内容 123456789101112131415161718 &lt;!--server.xml--&gt; &lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; &lt;Context path ="hello" docBase = "myweb"/&gt; &lt;!-- SingleSignOn valve, share authentication between web applications Documentation at: /docs/config/valve.html --&gt; &lt;!-- &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt; --&gt; &lt;!-- Access log processes all example. Documentation at: /docs/config/valve.html Note: The pattern used is equivalent to using pattern="common" --&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log." suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;/Host&gt; Tomcat目录中的文件结构 bin 文件 存放启动和关闭 Tomcat 的脚本文件 conf 文件 存放Tomcat服务器的各种配置文件 lib 文件 存放Tomcat服务器的支撑jar包 logs 文件 存放Tomcat 的日志文件 temp 文件 存放 Tomcat 运行时产生的临时文件(缓存文件) webpps 文件 web应用的所在目录，即供外界访问的web资源的存放目录 work 文件 Tomcat 的工作目录 其他补充：当你访问服务器文件(例如上面的 myweb 文件夹) 下的其他应用文件(exe、MP3 、MP4….)时 会 启用下载 —-（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序(1.1) view容器]]></title>
    <url>%2F2020%2F01%2F12%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-1-1-view%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[View组件的一些属性view 属性 类型 默认值 必填 说明 最低版本 hover-class string none 否 指定按下去的样式类。当 hover-class=&quot;none&quot; 时，没有点击态效果 1.0.0 hover-stop-propagation boolean false 否 指定是否阻止本节点的祖先节点出现点击态 1.5.0 hover-start-time number 50 否 按住后多久出现点击态，单位毫秒 1.0.0 hover-stay-time number 400 否 手指松开后点击态保留时间，单位毫秒 1.0.0 hover-class 解释：当按下后会把原本的样式改成hover-class后边所带的样式 12345678910&lt;!--index.wxml--&gt;&lt;view &gt; &lt;block wx:for="&#123;&#123;Mission&#125;&#125;" wx:key ="*this"&gt; &lt;view class="m_group" bindtap="test" hover-class="p_group"&gt; &lt;view class="m_name"&gt;&#123;&#123;item.name&#125;&#125;&lt;/view&gt; &lt;view class="m_desc"&gt;&#123;&#123;item.desc&#125;&#125;&lt;/view&gt; &lt;view class="m_date"&gt;&#123;&#123;item.date&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/block&gt;&lt;/view&gt; 1234567891011121314151617181920212223242526/**index.wxss**//*初始样式*/m_group&#123; height: 80px; width:100%; border-bottom:1px solid black; margin-bottom: 15px; background:url("https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1575569560956&amp;di=5adf4bd524cb8d7eab23c194fa11f5ca&amp;imgtype=0&amp;src=http%3A%2F%2Fa.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F838ba61ea8d3fd1fc9c7b6853a4e251f94ca5f46.jpg");&#125;/*按下后的样式*/p_group&#123; height: 70px; width:90%; margin-bottom: 10px;&#125;m_name&#123; font-family: STKaiti; font-size: 25px; border-bottom: 1px;&#125;m_date&#123; float: right;&#125; hover-stop-propagation 当出现容器组件相互包含的时候，当点击一个子容器的时候样式的改变会导致其外面的父容器的样式也被改变，通过使用hover-stop-propagation的设置可以设置成只有点击出的容器发生样式改变而不影响其父容器 123456789101112&lt;!--index.wxml--&gt;&lt;view class="section"&gt; &lt;view&gt;view组件&lt;/view&gt; &lt;view class="view-parent-container" hover-class="hover-parent-container"&gt; &lt;view class="view-container" hover-class="hover-container" hover-stop-propagation="true" hover-start-time="500" hover-stay-time="300"&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 123456789101112131415161718192021@import '../../common/weui.wxss';@import '../../common/common.wxss';/** view **/.view-parent-container &#123; width: 300rpx; height: 300rpx; background: yellowgreen;&#125;.hover-parent-container &#123; background: #fff;&#125;.view-container &#123; width: 200rpx; height: 200rpx; background: chocolate; /* transition: all .5s; */&#125;.hover-container &#123; background: rgba(0,0,0,0.7)&#125; 可以发现hover-stop-propagation的设置与否可以关系到子组件与父组件的相互影响，当没有设置的时候子组件的样式改变会影响到父组件 scroll-view 属性 类型 默认值 必填 说明 scroll-x boolean false 否 允许横向滚动 scroll-y boolean false 否 允许纵向滚动 upper-threshold number/string 50 否 距顶部/左边多远时，触发 scrolltoupper 事件 lower-threshold number/string 50 否 距底部/右边多远时，触发 scrolltolower 事件 scroll-top number/string 否 设置竖向滚动条位置 scroll-left number/string 否 设置横向滚动条位置 scroll-into-view string 否 值应为某子元素id（id不能以数字开头）。设置哪个方向可滚动，则在哪个方向滚动到该元素 scroll-with-animation boolean false 否 在设置滚动条位置时使用动画过渡 enable-back-to-top boolean false 否 iOS点击顶部状态栏、安卓双击标题栏时，滚动条返回顶部，只支持竖向 enable-flex boolean false 否 启用 flexbox 布局。开启后，当前节点声明了 display: flex 就会成为 flex container，并作用于其孩子节点。 scroll-anchoring boolean false 否 开启 scroll anchoring 特性，即控制滚动位置不随内容变化而抖动，仅在 iOS 下生效，安卓下可参考 CSS overflow-anchor 属性。 bindscrolltoupper eventhandle 否 滚动到顶部/左边时触发 bindscrolltolower eventhandle 否 滚动到底部/右边时触发 bindscroll eventhandle 否 滚动时触发，event.detail = {scrollLeft, scrollTop, scrollHeight, scrollWidth, deltaX, deltaY} 1234567891011121314151617181920212223242526272829303132333435var order = ['red', 'yellow', 'blue', 'green', 'red'];Page(&#123; data: &#123; toView: 'red', scrollTop: 0 &#125;, /** * scroll-view api */ upper: function (e) &#123; console.log(e) &#125;, lower: function (e) &#123; console.log(e) &#125;, scroll: function (e) &#123; console.log(e) &#125;, tap: function (e) &#123; for (var i = 0; i &lt; order.length; ++i) &#123; if (order[i] === this.data.toView) &#123; this.setData(&#123; toView: order[i + 1] &#125;) break &#125; &#125; &#125;, tapMove: function (e) &#123; this.setData(&#123; scrollTop: this.data.scrollTop + 20 &#125;) &#125;&#125;) 1234567891011121314151617181920212223242526272829303132333435&lt;!--scorllview.wxml--&gt;&lt;view&gt;scroll-view组件&lt;/view&gt;&lt;view class="section"&gt; &lt;view class="section__title"&gt;竖向滚动&lt;/view&gt; &lt;scroll-view style="height: 200px;" scroll-y bindscrolltoupper="upper" bindscrolltolower="lower" bindscroll="scroll" scroll-into-view="&#123;&#123;toView&#125;&#125;" scroll-top="&#123;&#123;scrollTop&#125;&#125;" enable-back-to-top="true" scroll-with-animation="true"&gt; &lt;view id="green" class="scroll-view-item bc_green"&gt;&lt;/view&gt; &lt;view id="red" class="scroll-view-item bc_red"&gt;&lt;/view&gt; &lt;view id="yellow" class="scroll-view-item bc_yellow"&gt;&lt;/view&gt; &lt;view id="blue" class="scroll-view-item bc_blue"&gt;&lt;/view&gt; &lt;/scroll-view&gt; &lt;view class="btn-area"&gt; &lt;button size="mini" bindtap="tap"&gt;click me to scroll into view &lt;/button&gt; &lt;button size="mini" bindtap="tapMove"&gt;click me to scroll&lt;/button&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class="section"&gt; &lt;view class="section__title"&gt;横向滚动&lt;/view&gt; &lt;scroll-view class="scroll-view_H" scroll-x &gt; &lt;view id="green" class="scroll-view-item_H bc_green"&gt;&lt;/view&gt; &lt;view id="red" class="scroll-view-item_H bc_red"&gt;&lt;/view&gt; &lt;view id="yellow" class="scroll-view-item_H bc_yellow"&gt;&lt;/view&gt; &lt;view id="blue" class="scroll-view-item_H bc_blue"&gt;&lt;/view&gt; &lt;/scroll-view&gt;&lt;/view&gt; 可以看出这里设置了一个上下滚动的view scroll容器，然后滚动的时候会调用回调函数scroll【详见js文件】，到顶和到头的时候会调用upper和lower 1234567891011121314151617181920212223242526272829303132333435@import '../../common/weui.wxss';@import '../../common/common.wxss';/** scroll-view **/.scroll-view-item &#123; width: 600rpx; margin: 0 auto; height: 200px;&#125;.scroll-view-item.bc_green,.scroll-view-item_H.bc_green &#123; background: green;&#125;.scroll-view-item.bc_red,.scroll-view-item_H.bc_red &#123; background: red;&#125;.scroll-view-item.bc_yellow,.scroll-view-item_H.bc_yellow &#123; background: yellow;&#125;.scroll-view-item.bc_blue,.scroll-view-item_H.bc_blue &#123; background: blue;&#125;.scroll-view_H &#123; height: 200px; margin: 0 auto; white-space: nowrap;&#125;.scroll-view-item_H&#123; display: inline-block; width: 100%; height: 200px;&#125;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础学习（1.3）DAO设计模式]]></title>
    <url>%2F2019%2F11%2F21%2FJava%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%881-3%EF%BC%89DAO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[DAO设计模式DAO设计模式是数据层的操作，可以简化代码，增加程序移植性和易用性。 在程序编写过程中都是使用实体对象，如User，Hero等，当我们想储存这些对象时，就需要把属性一项一项的拆解出来，混合着JDBC代码进行数据存储。想要从数据库中读取时还要一项一项的读取出来再组合成一个实体对象，难编写，难维护。 而使用DAO设计模式可以很好地解决这些问题。 DAO设计模式包含： DAO接口 DAO实现类 DAO工厂类 实体模型 数据库链接类 小结：在实际开发中，我们是要对对象进行操作的。然后可以使用设计一个DAO数据持久层，专门把数据库的一条条数据进行转换成对象，或者专门把对象转换一条条字符串数据存入数据库。这样在实际开发中就不必大段大段的写转换代码，直接从DAO成获取已经成型的对象，或者通过DAO层直接把对象分割成字符串数据存入数据库。 通过IO流实例演示DAO层DAO设计模式中就是单独分一个层实现对象与数据的相互转换 按照要求有： 实现DAO接口123456789101112131415161718192021222324252627282930313233343536373839package demo.dao;import java.util.List;import demo.model.User;public interface UserDAO&#123; /* *保存 *作用：接收User对象并把它拆解为数据字符串存储起来 */ public int save(User u); /* *更新 *作用：通过传入的对象对数据进行更新 */ public int update(User u); /* *删除 *作用：根据id删除指定数据 */ public int delete(int id); /*根据对象进行删除数据*/ public delete(User u); /* *根据ID进行查找 *作用：通过输入的ID对数据库内容进行查询并返回一个对象 */ User findById(int id); /*查找获取所有内容返回一个list集合*/ List&lt;User&gt; findAll(); &#125; DAO实现类(核心)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168package demo.IOforDAO;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.ArrayList;import java.util.List;import demo.dao.UserDAO;import demo.model.User;public class UserDaoImpl implements UserDAO&#123; File file = new File("src/user.data"); /*简单实现一个工厂来获取IO流BufferedReader对象*/ private BufferedReader createReader() throws FileNotFoundException&#123; FileReader in = new FileReader(file); return new BufferedReader(in); &#125; /* *简单实现一个工厂来获取IO流BufferedWriter对象 *参数 append：true：返回一个不覆盖写入数据的对象 * false：返回一个覆盖写入数据的对象 */ private BufferedWriter createWriter(boolean append)throws FileNotFoundException&#123; FileWriter out = new FileWriter(file,append); return new BufferedWriter(out); &#125; /*一个专门关闭IO流的方法*/ private void close(BufferedWriter out, BufferedReader in)&#123; try &#123; if(out != null)out.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; if(in != null)in.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /*重写Save方法*/ @Override public int save(User u)&#123; BufferedWriter out = null; try&#123; out = createWriter(true);//获取一个不能覆盖写入的Writer对象 out.write(u.getId()+"");//整型通过加一个空字符串转换成字符串类型 out.write(","); out.write(u.getName()); out.write(","); out.write(u.getPassword()); out.newLine();//结尾换行，方便下次数据的添加 out.flush();//刷新缓冲流，把字符串数据保存进文件中 out.close();//写入完毕关闭流 &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; close(out.null)//finally块中调用close方法防止因为异常不能正常关闭io流 &#125; return 0; &#125; /*重写delete方法*/ @Override public int delete (int id)&#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); BufferedReader in = null; BufferedWriter out = null; try&#123; in = createReader(); out = createWriter(); for(String str;(str = in.readline())!=null;)&#123; String[]arr = str.split(","); if(!arr[0].equals(id +""))&#123;//如果id与传入的参数的id不相同就加入list，从而排除id相同的项 list.add(str); &#125; &#125; in.close(); for(String str:list)&#123; out.write(str); out.newline(); &#125; out.flush(); out.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; close(out,in); &#125; &#125; @Override public int delete(User u) &#123; delete(u.getId()); return 0; &#125; /*重写更新方法*/ @Override public int update(User u) &#123; delete(u); save(u); return 1; &#125; @Override public User findById(int id) &#123; BufferedReader in = null; try &#123; in = createReader(); for(String str; (str = in.readLine())!=null;) &#123; String[]arr = str.split(","); if(arr[0].equals(id+"")) return new User(id, arr[1], arr[2]); &#125; in.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; close(null, in); &#125; return null; &#125; @Override public List&lt;User&gt; findAll() &#123; List&lt;User&gt; uList = new ArrayList&lt;User&gt;(); BufferedReader in = null; try &#123; in = createReader(); for(String str; (str = in.readLine()) != null;) &#123; String[]temp = str.split(","); uList.add(new User(Integer.parseInt(temp[0]),temp[1],temp[2])); &#125; in.close(); return uList; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; close(null, in); &#125; return null; &#125; &#125; 小结：delete方法的一些实现思路 该方法中同时使用了读与写 先读取内容后进行分割后进行判断，如果第一项的id与输入的id相匹配那么说明该项应该被删除，则不计入list中。 上诉过程结束后，获得了id不含待删除id的list字符串数据 最后将字符串list集合再一个个写入文件，完成删除操作 实体模型1234567891011121314151617181920212223242526272829303132333435package demo.model;public class User &#123; private int id; private String name; private String password; public User() &#123; &#125; public User(int i,String n,String pw) &#123; id = i; name = n; password = pw; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 使用Mysql实现DAO层DAO实现类(核心)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146package demo.MySQLForDAO;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.ArrayList;import java.util.List;import demo.dao.UserDAO;import demo.model.User;import utils.JDBCUtils;public class DAOImpl implements UserDAO&#123; /* *保存 */ @Override public int save(User u) &#123; Connection conn = JDBCUtils.getConnection(); PreparedStatement pst = null; try &#123; pst = conn.prepareStatement("insert into user values (0,?,?)"); pst.setString(1, u.getName()); pst.setString(2, u.getPassword()); return pst.executeUpdate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(conn, pst, null); &#125; return 0; &#125; /* *更新 */ @Override public int update(User u) &#123; Connection conn = JDBCUtils.getConnection(); PreparedStatement pst = null; try &#123; pst = conn.prepareStatement("update user set name = ?,Password = ? where id = ?"); pst.setString(1, u.getName()); pst.setString(2, u.getPassword()); pst.setInt(3, u.getId()); return pst.executeUpdate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(conn, pst, null); &#125; return 0; &#125;/**删除根据ID进行删除*/ @Override public int delete(int id) &#123; Connection conn = JDBCUtils.getConnection(); PreparedStatement pst = null; try &#123; pst = conn.prepareStatement("delete from user where id = ?"); pst.setInt(1, id); return pst.executeUpdate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(conn, pst, null); &#125; return 0; &#125; /*删除*/ @Override public int delete(User u) &#123; Connection conn = JDBCUtils.getConnection(); PreparedStatement pst = null; try &#123; pst = conn.prepareStatement("delete from user where id = ?"); pst.setInt(1, u.getId()); return pst.executeUpdate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(conn, pst, null); &#125; return 0; &#125; /* *根据ID查找 */ @Override public User findById(int id) &#123; Connection conn = JDBCUtils.getConnection(); PreparedStatement pst = null; ResultSet rs = null; try &#123; pst = conn.prepareStatement("select * from user where id = ?"); pst.setInt(1, id); rs = pst.executeQuery(); while(rs.next()) &#123; return new User(rs.getInt("id"),rs.getString("name"),rs.getString("password")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; /* *查找所有数据，返回一个对象集合 */ @Override public List&lt;User&gt; findAll() &#123; List&lt;User&gt; uList = new ArrayList&lt;User&gt;(); Connection conn = JDBCUtils.getConnection(); PreparedStatement pst = null; ResultSet rs = null; try &#123; pst = conn.prepareStatement("select * from user"); rs = pst.executeQuery(); while(rs.next()) &#123; User user = new User(rs.getInt(1),rs.getString(2),rs.getString(3)); uList.add(user); &#125; return uList; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(conn, pst, rs); &#125; return null; &#125;&#125; 错误小结 在数据库中，使用executeQuery()获得的结果集，每一列的下标不像数组一样是从0开始的，即第一项的下标就为1，而不是0。 DAO工厂的实现12345678910package utils;import demo.IOforDAO.UserDaoImpl;public class DAOUtils &#123; public static UserDaoImpl getUDAOImpl() &#123; return new UserDaoImpl(); &#125;&#125; 实现DAO工厂后，可以直接获取一个DAO对象，除了使代码简化还能大大提高程序的可维护性 ，例如修改DAO实现类的时候，只需在工厂类中作出修改，而不用在主程序中大篇幅的修改代码 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础学习（1.2）JDBC执行MySQL动态语句]]></title>
    <url>%2F2019%2F11%2F19%2FJava%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%881-2%EF%BC%89JDBC%E6%89%A7%E8%A1%8CMySQL%E5%8A%A8%E6%80%81%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[JDBC中的预编译语句PrePareStatement PrePareStatement是预编译语句，继承自Statement，但比Statement功能强大的多，它可以在SQL语句中用问号(?)来代替变量，接下来可以提供多组值，最后执行。 1234567891011Connection conn = JDBCUtils.getConnection();conn.setAutoCommit(false);//设置不自动commit/**用问号表示名字和年龄等参数*/PrepareStatement pst = conn.prepareStatement("insert into stu values(?,?)");pst.setString(2,"zhangsan");pst.setInt(1,0);pst.addBatch();pst.setString(2,"lisi");pst.setInt(1,0);pst.addBatch();pst.executeBatch();//批量执行 预编译语句的优点 一、代码的可读性和可维护性。 虽然PrepareStatement来代替Statement会多出几行代码，但整体上代码的可读性和可维护性都是比直接使用Statement的代码高的。 二、性能较高 它包含的SQL语句是预编译的，所以当多次执行一条SQL语句时效率及性能会高 三、可以防止SQL注入攻击 对JDBC来说，SQL的注入攻击只对Statement有效，对PrepareStatement是无效的，这是因为PrepareStatement不允许在插入是改变查询的逻辑结构。 总结：综上而言 使用PrepareStatement就对了 预编译语句的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Test&#123; public static void main(String[] args)&#123; Connection conn = JDBCUtils.getConnection(); PrepareStatement pst = null; ResultSet rs = null; try&#123; //预编译语句 String sql = "insert into stu values(0,?,?)" ; pst = conn.prepareStatement(sql); /* *设置预编译语句的参数 * 第一个参数为：第几个问号 * 第二个参数为：该位置的值 */ pst.setString(1,"LiSi"); pst.setInt(2,18); pst.executeUpdate(); /* *当出现要进行多次数据库操作的时候,通常会这样写。(不太适合的写法) * *但下列写法效率是不高的，因为这样通过循环来执行SQL语句，每一次循环都要重新编译 *SQL语句，这难免会大量的消耗资源。 */ for(int i = 0; i &lt; 10; i++)&#123; pst.setString(1,"LiSi"); pst.setInt(2,18+i); pst.executeUpdate(); &#125; /* *通过预编译语句PrepareStatement中的Batch进行批量处理 */ for(int i = 0; i &lt; 10; i++)&#123; pst.setString(1,"LiSi"); pst.setInt(2,18+i); pst.addBatch();//每一次循环加入一个批次中 &#125; pst.executeBatch();//统一执行Batch内的语句，即批次执行 &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; JDBCUtils.close(conn,pst,null); &#125; &#125;&#125; SQL命令语句预编译在上诉演示中可以发现，PrepareStatement的对象不像Statement一样，前者需要先把SQL语句获取才能获取到对象，而不像Statement可以先创建出对象再执行SQL命令。 12345678910/**使用Statement*/Statement st = conn.createStatement();st.executeUpdate("....SQL命令")；/**使用预编译语句PrepareStatement*/ pst = conn.prepareStatement(sql); PrepareStatement允许执行动态的SQL(含参)语句PrepareStatement最大的特点就是可以执行动态的SQL语句，防止了以往的SQL注入攻击，因为Statement执行SQL语句时是直接一个静态的字符串语句拿去编译，不法分子就会根据这个原理，修改字符串里面语句的逻辑结构进而访问数据库。而PrepareStatement却不一样，它是不允许在插入是改变查询的逻辑结构。 1234567891011121314/**使用Statement时*/st.executeUpdate("select password from users where password = ‘123456’")；//此时当执行这句命令时对命令字符串进行修改后加一个字符串 ”or 1 = 1“结果语句就变成了//select password from users where password = ‘123456’or 1 = 1" 很明显，无论密码是否正确，系统也会辨别是正确的。/**使用PrepareStatement*/pst = conn.prepareStatement("select password from users where ？ = ‘123456’");pst.setString(1,password)；pst.executeUpdate();//可以发现当password要真正输入正确时才能返回密码正确，因为语句一开始就确定好了，你输入的password并不会合并到SQL命令中。而不像Statement你输入的内容还会合并到其命令中影响SQL命令语句 PrepareStatement的批量提交在执行循环多次修改更新数据库的时候，如果使用PrepareStatement会比Statement快的多，因为前者拥有Batch的功能，多次执行SQL命令时，就不像Statement一样每执行一次SQL语句，就要重新编译一次SQL语句命令，PrepareStatement可以通过Batch把多次的命令一次编译完成且批量一次提交，从而提高了效率。 123456789101112131415 /* *使用PrepareStatement多次提交的SQL语句只需编译一次执行 *///预编译语句String sql = "insert into stu values(0,?,?)" ; pst = conn.prepareStatement(sql);for(int i = 0; i &lt; 10; i++)&#123; pst.setString(1,"LiSi"); pst.setInt(2,18+i); pst.addBatch();//每一次循环加入一个批次中 &#125; pst.executeBatch();//统一执行Batch内的语句，即批次执行 JDBC实现数据库分页查询实现结果 分页查询 假如你的数据库表单中一共有12条信息。那么现要求把12条信息以每页显示5条信息进行分页，也就是一共能被分为3页，其中最后一样的数据只有两条。 综上，可以看出对数据库进行分页后，当要查看第2页内容时，就只显示6~11条信息，第一页就显示1~5条信息，就为分页进行查询。 在分页查询中最重要的就是两个值。第一个就是页数，第二个就是一页含有多少条数据 12345678910111213141516171819202122232425262728293031323334import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import utils.JDBCUtils;public class Test5 &#123; public static void main(String[] args) &#123; int page；//代表页数，即当前查询的为第几页 int rows = 5; //代表每页记录数，即一页能有几条信息 int began = (page-1)*rows;//对应每页开始的位置，第一页就从第一条信息开始，第二页就从第六条信息开始 Connection conn = JDBCUtils.getConnection(); /* *sql语句中的limit x,y; * x代表第x条命令开始 * y代表一共查y条信息 * limit x,y合起来就是 第x条开始后的y条信息 */ String sql = "select * from stu limit ?,?";//sql命令语句 PreparedStatement pst = connpreparedStatement(sql); pst.setInt(1, began); pst.setInt(2, rows); ResultSet rs = pst.executeQuery(); while(rs.next()) &#123; System.out.println(rs.getInt(1) + " " + rs.getString(2)); &#125; &#125;&#125; 实验结果 知识点小结 SQL条件命令：limit x,y limit 参数，第一个参数：从哪儿开始查 ； 第二个参数：查几条 例子： 12345//从开头0号位置开始查，一共查取5条信息select * from stu limit 0,5;//从第二题信息位置开始查，一共查取2条信息select * from stu limit 2,2; —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础学习(1.1)使用JDBC对数据库连接]]></title>
    <url>%2F2019%2F11%2F18%2FJava%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%881-1%EF%BC%89%E4%BD%BF%E7%94%A8JDBC%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[Java JDBC API 核心 Driver：代表驱动程序(一般由数据库厂商负责提供) DriverManager类： 是JDBC的管理层，作用于用户和驱动之间，负责注册和加载JDBC驱动 Connection接口： 代表与数据库的连接，当用户与数据库交互的时候，首先必须建立与数据库的链接，只有在获得链接之后，才能进一步对数据库进行操作，该接口是用户与数据库之间的桥梁。 Statement对象： 用于执行静态SQL语句并返回执行结果。Statement可以通过Connection对象的createStatement()方法创建。Statement对象只能执行静态sql语句。不能可以执行动态的sql（sql串中有参数），执行动态sql使用PreparedStatement对象，用法和Statement类似。 ResultSet对象： ResultSet对象是结果集对象。当程序执行一句用于查询功能的sql语句(select)后，JDBC会把数据库的查询结果封装成一个ResultSet对象返回给程序。ResultSet对象具有指向其当前数据行的游标指针，用户可以移动该指针读取ResultSet中的不同记录。另外ResultSet对象还封装了一些关于集表的列名、数据类型等信息，这些信息一般可以通过ResultSetMetaData对象来读取。 具体实现步骤 在对应的数据库官方下载对应的jar包驱动 对项目进行加入驱动 连接数据库前，先对数据库驱动进行加载注册 用DriverManager类获取数据库的链接 返回值为Connection 获得数据库链接后可以通过Statement获取Connection对象里面数据库的表单信息 Statement对象可以通过内置方法对数据库里面的表单进行增删 在对表单进行查询遍历的时候Statement对象会返回一个ResultSet对象，通过操作ResultSet对象即可获得表单内的具体数值 连接数据库前对驱动进行加载注册以MySQL数据库为例 12//new com.mysql.jdbc.Driver();Class.forName("com.mysql.jdbc.Driver"); 两种写法，使用forName为正规写法。 获取数据库链接123456789101112131415161718192021222324import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class Test&#123; public static void main(String[] args) &#123; String url = "jdbc:mysql://localhost:3306/user_learn?serverTimezone=Asia/Shanghai";//链接MYSQL数据库的url String user ="shuhao";//数据库管理员ID String pass = "991124";//管理员密码 /* *使用DriverManager获取数据库链接 */ try&#123; Connection conn = DriverManager.getConnection(url,user,pass); &#125;catch (SQLException e) &#123; e.printStackTrace(); System.out.println("MySQL连接失败"); &#125; &#125; &#125; 使用Statement获取Connection对象数据库链接里面的表单，并进行操作123456789101112131415import java.sql.Statement;Statement st = conn.createStatement();//直接使用Connection内置方法获取/**使用Statement对象对数据库进行操作*/st.execute("CREATE TABLE user_learn.Stu (ID int(0) NOT NULL AUTO_INCREMENT,name varchar(50) NULL,age int(0) NULL,PRIMARY KEY (ID));")//往数据库里面创建一个表单 st.executeUpdate("insert into stu values(0,'zhang',18)");//往表单里面添加东西，执行的为静态MySQL数据库命令.....//其他操作 st.close();//操作完毕后记得关闭Statement Statement类中的一些方法解释 Statement内执行SQL语句的方法 作用 补充 execute 用于执行返回多个结果集、多个更新计数或二者组合的语句 允许执行查询语句、更新语句、DDL语句。返回值为true时，表示执行的是查询语句，可以通过getResultSet方法获取结果；返回值为false时，执行的是更新语句或DDL语句，getUpdateCount方法获取更新的记录数量 executeQuery 用于产生单个结果集的语句 执行给定的 SQL 语句，该语句返回单个 ResultSet 对象 一般进行遍历操作时会使用 executeUpdate 用于执行 INSERT、UPDATE 或 DELETE 语句以及 SQL DDL（数据定义语言）语句 执行给定 SQL 语句，该语句可能为 INSERT、UPDATE 或 DELETE 语句，或者不返回任何内容的 SQL 语句（如 SQL DDL( 语句） 一般使用删除、增加时会使用 操作ResultSet对数据库内容进行遍历1234567891011import java.sql.ResultSet;ResultSet rs = st.executeQuery("select * from stu");/**ResultSet里面的getString()方法中参数如果是整型，那么会获取对应的列的内容，也可以直接填数据项名的字符串*/while(rs.next()) &#123; System.out.println(rs.getString(1) + " " + rs.getString(2)); //System.out.println(rs.getString("id") + " " + rs.getString("name"));也可填写数据项名的字符串&#125; ResultSet内含有一个游标指针，一开始会指向第一行的上一行。可以通过ResultSet中的next()方法进行下移 测试代码总汇123456789101112131415161718192021222324252627282930313233343536373839404142import java.sql.Connection;import java.sql.DriverManager;public class Test&#123; public static void main(String[] args) &#123; String url = "jdbc:mysql://localhost:3306/user_learn?serverTimezone=Asia/Shanghai";//链接MYSQL数据库的url String user ="shuhao";//数据库管理员ID String pass = "991124";//管理员密码 try&#123; Connection conn = DriverManager.getConnection(url,user,pass); Statement st = conn.createStatement();//直接使用Connection内置方法获取 st.execute("CREATE TABLE user_learn.Stu (ID int(0) NOT NULL AUTO_INCREMENT,name varchar(50) NULL,age int(0) NULL,PRIMARY KEY (ID));"); for(int i = 1; i &lt;= 10 ; i++) &#123; st.executeUpdate("insert into stu values(0,'zhang"+ i +"',18)"); &#125; ResultSet rs = st.executeQuery("select * from stu"); while(rs.next()) &#123; System.out.println(rs.getString(1) + " " + rs.getString(2)); &#125; &#125;catch (SQLException e) &#123; e.printStackTrace(); System.out.println("MySQL连接失败"); &#125;final&#123; rs.close(); st.close(); conn.close(); &#125; &#125; &#125; 实验结果： 总结： 在操作完数据库的一些操作后记得要关闭相关的接口，应该在final块里面进行，防止在关闭语句前出错的时候没能继续执行剩下的关闭语句。 关闭顺序应该创建的逆序。关闭顺序为：ResultSet -&gt;Statement-&gt;Connection 使用工厂模式编写一个JDBC的工具包类JDBCUtils工具类创建一个JDBCUtils工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package utils;/** * JDBC工具类 * 用来实现JDBC的一些操作 * MYSQL中的一些数据连接、关闭、获得Connection等 * @author ShuHao * @date 2019.11.18 */import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class JDBCUtils &#123; private static String url = "jdbc:mysql://localhost:3306/user_learn?serverTimezone=Asia/Shanghai&amp;useSSL=false"; private static String name = "shuhao"; private static String password = "991124"; /* *这里使用一个static静态代码块来对驱动的加载注册，因为在使用时该加载注册步骤前后只需进行一次即可。 */ static &#123; try &#123; Class.forName("com.mysql.jdbc.Driver");//对数据库进行连接时要先对驱动进行加载注册 //new com.mysql.jdbc.Driver() &#125; catch (ClassNotFoundException e) &#123; System.err.println("MySql数据库驱动加载失败！"); e.printStackTrace(); &#125; &#125; /* *工厂模式 */ public static Connection getConnection() &#123; try &#123; Connection conn = DriverManager.getConnection(url,name,password);//使用DriverManager获取数据库的连接 System.out.println("MySql数据库连接成功！"); return conn; &#125; catch (SQLException e) &#123; System.err.println("连接失败！"); e.printStackTrace(); &#125; return null; &#125; /** * 实现MySql后一些退场关闭工作 * @param conn 创建数据库的连接 * @param st 待关闭的表单 * @param rs 欲关闭的结果集 */ public static void close(Connection conn,Statement st,ResultSet rs) &#123; try &#123; if(rs != null)rs.close(); &#125; catch (SQLException e2) &#123; e2.printStackTrace(); &#125; try &#123; if(st != null)st.close(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; try &#123; if(conn != null)conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在外部使用该工具类获取数据链接，与关闭对应接口，可以发现使用一个工具类后代码行数大大减少 12345678910111213import java.sql.Connection;import utils.JDBCUtils;public class Test3 &#123; public static void main(String[] args) &#123; Connection connection = JDBCUtils.getConnection();//通过工具类获得链接减少了大段的代码 System.out.println("操作成功！！"); JDBCUtils.close(connection, null, null);//使用工具类中的关闭 &#125;&#125; 一些知识点静态代码块 功能：随着类的加载而执行，而且只执行一次 123static&#123; ....语句内容&#125; 在上诉的工具类中使用了一个静态块来对驱动的加载注册，因为加载注册在程序运行到结束只需运行一次，那么放在静态块里面，程序开始时只有第一次调用时会运行静态块里面的内容，以后再调用时则不会运行。 工厂模式 介绍：在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 应用实例：您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 结合上面的工具类解释：根据上面所说你要一辆车，直接从工厂里取即可，而不用原地一个个零件重新造一个，而上面的工具类也是一样的，别的类中需要一个数据库的连接connection对象，只需调用工具类中的getConnection()方法即可从而获得一个connection对象。而具体这个对象怎么来的只需在作为工厂的工具类内部实现即可。 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库学习总结-（知识总汇）]]></title>
    <url>%2F2019%2F11%2F17%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[数据库命令基本命令 显示数据库总表：show databases; 创建用户数据库：create database name（库名） 进入数据库：use name(库名) 显示库内集合表单：show tables; 创建集合表单：create table name(表单名)（dataType(数据类型), data_name(数据名)…..） 创建表单后 查看集合表单内容：desc name(表单名) 增删改查命令 往集合表单添加信息： insert into name(表单名)(dataname1,dataname2,dataname3….) values(data1,data2,data3…) insert into name(表单名) values(data1,data2,data3…)//效果同上，默认以创建表单时数据单元的顺序 insert into name(表单名) (dataname1，dataname2….)values(data1,data2 …..)//dataname之间可以替换，但后面的data值要更具前面的顺序进行填写 查看表单详情内容： select * from name(表单名);//遍历全表 select dataname1,dataname2…. from name(表单名)//选择性显示表单内容 select * from name(表单名) where something(条件)//按照要求条件进行遍历 修改表单内数据项的内容 update name(表单名) set dataname1 = value,dataname2 = value….//把整个表单内容进行修改 update name(表单名) set dataname1 = value,dataname2 = value…. where something(条件） 删除表单内数据项的内容 delete from name(表单名) //删除表单内所有内容！！ delete from name(表单名) where something(条件)//根据条件进行删除 数据库数据类型12345678910int:整型double：浮点型，例如double(6,2)表示最多6位，其中必须有2位小数，即此时最大值为9999.99char：固定长度字符串类型，char(10)中&apos;abc&apos;也占10位，空出来的7位将以空字符代替varchar：可变长度字符串类型；varchar(10)中&apos;abc&apos;占3位，10代表最大支持长度text：大文本类型，详情见下表。blob：字节类型，可以存储任意数据。data：日期类型，格式为：yyyy-MM-dd；time：时间类型，格式为：hh:mm:sstimestamp:时间戳类型 yyyy-MM-dd hh:mm:ss 会自己根据系统时间进行赋值、datatime：日期时间类型 yyyy-MM-dd hh:mm:ss 大文本类型 数据类型 大小 大小 TINYTEXT 256bytes TEXT 65,535bytes ~64kb MEDIUMTEXT 16,777,215bytes ~16MB LONGTEXT 4,294,967,295bytes ~4GB 常用约束1234567主键约束：primary key唯一约束：unique[key]非空约束：not null外键约束：foreign key默认约束：default自动增长：auto_increment 主键约束：对某一项数据进行设置为主键后该行数据变为唯一且非空（类似公民的身份证号） 唯一约束：数据唯一，不能出现重复 非空约束：数据不能为空 外键约束：向外表进行调用，例如一个表一中的id有1~20，在表二的id2要引用表一的id项，则可以对id2设置外键约束目标为表一的id，则此时id2中只能填写id内含有的内容。 默认约束：设置数据项默认值 自动增长：会根据该项最大的数值创建新数据单元时会自动加一 条件查询1234567=、(!= &lt;&gt;)、&lt;、&lt;=、&gt;、&gt;=BETWEEN .... ANDIN(set)IS NULLANDORNOT (1)查询性别是男并且薪资小于1000的记录 1SELECT * FROM users Where sex = &apos;M&apos; AND sal &lt; 1000; (2)查询性别是女性 或者 薪资大于2500的记录 1SELECT * FROM users Where sex = &apos;F&apos; OR sal &gt; 2500; (3)查询薪资为1250,1500,1600的记录 1SELECT * FROM users Where IN(1250,1500,1600); (4)查询薪资在1000到2000间 1SELECT * FROM users Where sal &gt;= 1000 AND sal &lt;=2000 或 1SELECT * FROM users Where sal BETWEEN 1000 AND 2000; 模糊查询（关键字查询）在SQL中可以使用like关键字实现模糊查询 即：通过给定搜索条件，一个字或者几个字符进行查找内容，该查询支持两种通配符： _可以匹配任意一个字符 %可以匹配任意0~n个字母，例如‘徐%’可以匹配所有以徐开头的内容 (1)查询姓名由5个字母构成的用户记录 1SELECT * FROM users Where name like '_____' (2)查询姓名由A字母开头的用户 1SELECT * FROM users Where name like 'A____' (3)查询姓名中含有‘李’的用户 1SELECT * FROM users Where name like '李%' 排序1SELECT * FROM name(表单名) order by dataname1(数据项) desc(没加desc那么就为升序，加了为降序)； (1)通过年龄进行排序 (2)当排序时出现了相同项，可以再根据其他项对两个相同的项进行排序 1SELECT * FROM name(表单名) order by dataname1(数据项)，dataname2; 1SELECT * FROM name(表单名) order by dataname1(数据项) desc，dataname2; 数据项1以降序排序，数据项2为升序排序 聚合函数12345sum：求和max：求最大值min：求最小值avg：求平均值count：求个数 1select 函数名(数据项) from name(表单名) (1)查询年龄总和 1select sum(age) from user (2)查询年龄最大为多少(最小同理) 1select max(age) from user (3)求年龄大于18的用户有多少个 1select count(age) from user where age &gt;= 18 —（本文完）]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（7.3）哈希表中的冲突通常的解决方案]]></title>
    <url>%2F2019%2F11%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%887-3%EF%BC%89%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%86%B2%E7%AA%81%E9%80%9A%E5%B8%B8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[冲突的解决方案冲突就是多个关键字映射到同一个哈希表地址上去了，出现冲突情况有下列几种解决方法。 开放地址法 再哈希法 封闭地址法 开放地址法一个Key具有多个候选哈希地址。 开放地址：如果这个地址冲突，尝试其他地址，即不“封闭”在一个地址上 实现： 线性探测再散列 二次探测再散列 伪随机探测再散列 线性探测再散列 原地址H0发生了冲突 则第i次冲突的探测地址 Hi = (Ho+ i)%m 例如 一个关键字映射地址为3 另一个关键字通过哈希函数也映射为3 那么第二个关键字则会检索4号地址空不空，如果空那么就存储进去，反之继续往检索 线性探索法容易产生堆积： 冲突的关键字只好向后寻找可用的空单元 结果又占据了其他关键字的位置 使得冲突更加严重、查找次数增加 因为如果当前地址产生了冲突，尝试下一个地址，这样容易造成“连续的一大串”地址冲突，使得查找次数增加 改进：使用二次探测再散列 如果当前地址冲突，“下一个”的地址不是紧挨着，而是离远一些，而且冲突次数越多，离得越远 二次探测再散列 原地址H0发生了冲突 i 为冲突的次数 m 为哈希表大小 Hi = (Ho+ i2) % m 再哈希法若原地址H0 = Hash0(key)冲突，则下一个地址换另外一个哈希函数进行 即：Hi = Hashi(key)。 封闭地址法即便映射在哈希表上的地址发生了冲突也想办法在该地址内进行存储。常用的有： 链表法 链表法 映射到同一个地址到数据存放在链表中 附加：判断冲突可能性判断（载荷因子） 载荷因子 = 填入表中的元素个数/散列表的长度 载荷因子小，说明哈希表表内空位较多 载荷因子大，说明哈希表内空位少 综上：载荷因子大说明冲突的可能性大，反正可能性小]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（7.2）哈希表与哈希函数]]></title>
    <url>%2F2019%2F11%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%887-2%EF%BC%89%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[哈希表当我们对一个数组进行操作时，如果要进行查找某个元素，一般时用循环一个个元素与要查找的关键字进行比较。这样往往要消耗大量的时间，而哈希表则解决了这个问题：哈希表时通过对要查找的关键字进行操作从而得到数组内该元素相对应位置的一种数据结构。 通俗地讲，哈希表要储存数据时，一般会先对数据通过_哈希函数_进行处理，得到一个下标，并把该数据存储在对应下标的位置，当要查找该数据的时候，则对关键字通过哈希函数进行处理就可以直接得到对应下标，通过下标直接操作该数据，相比普通数组进行查找时省去了大量无意义的比较操作。 哈希表的特点及抽象数据结构 根据关键字（键）key存取数据元素的数据结构。 哈希函数将关键字映射到存储位置的索引 查找，插入，删除的时间复杂度时O(1)。比BST数等其他效率高（最坏的情况O（n）） 哈希表的冲突（Collision）上面说到，关键字说通过一个哈希函数进行处理后得到对应的存储地址，在对大量数据进行处理时，通过哈希函数难免会出现生成的下标为同一个的情况，此时就发生了哈希表的冲突 散列函数时一个压缩映像函数关键字集合比哈希表地址集合大得多。因此有可能经过哈希函数的计算，把不同的关键字映射到同一个哈希地址上，这些关键字互为同义词 总结：综上如果要设计一个_好的哈希表首先要解决以下两个问题_ 对于给定一个关键字集合选择一个计算简单且地址发布比较均匀的哈希函数，避免或尽量减少冲突 研究解决冲突的方案 哈希表的抽象数据结构 ADT HashTable bool get() void put() void remove() 根据“键（key）”存取“值（Value）” 哈希函数特点： 哈希函数计算出来的地址应该能均匀分布在整个地址空间中 如果关键字总是更容易映射到某个或某些地址上，称作堆积 哈希函数的一些实现方式及各方法的优缺点直接定址法 哈希函数取关键字的某个线性函数 Hash(key) = a * key + b 一一映射，不会出现冲突 缺点：要求哈希地址空间的大小与关键字集合的大小相同 余数法(最常见，最简单) 设哈希表中允许地址数为m Hash(key) = key % p 其中p要满足 p &lt;= m,尽量接近m 最好取质数 最好不要接近2的幂 范例 有一个关键字key = 962148 哈希表大小m = 25 取质数p = 23 哈希函数：Hash(key) = key % p 则哈希地址为： Hash(962148) = 962148% 23 = 12 数值抽取发(数字分析法) 将关键字的某几位数字取出作为地址 例如 关键字为6位，哈希表地址为3位 可取出关键字的第1、2、5位，组成哈希地址 136782 -》138 缺点：数值抽取法仅适用于事先明确知道表中关键字每一位数值的分布情况，它完全依赖于关键字集合。如果换一个关键字集合，选择哪几位要重新决定 比如：如果关键字是电话号码、学号、则前几位就不太适合，因为规律性太强 平方取中法 将关键字的前几位取出，做平方 再取出平方结果的中间几位作为地址 例如 325483 =》325^2 = 105625 =》056 此方法在词典处理中使用十分广泛 折叠法 将关键字拆成位数相等的多段，将这几段叠加起来，相加结果作为哈希地址 移动折叠法：各段最后一位对齐相加 比如关键字：123 456 789 12 哈希地址要求为3位数 边界折叠法：各部分沿各方部分的边界来回折叠，然后对齐相加，将相加的结构当做哈希地址 比如：关键字 = 123 456 789 12 旋转法 将关键字中的数字旋转位置 比如：关键字 = 12345678 把个位数移到最左：81234567 此法通常和其他方法结合使用 伪随机数法 利用伪随机数算法生成哈希地址 Hash(key) = random(key) 总结： 应该根据实际情况选择：效率要求，关键字长度，哈希表长度，关键字分布等 有些时候可以多种方法结合使用 比如：余数法+伪随机数法 Hash(key) = random(key) % 12 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.15）二叉查找树的插入与删除（附加）]]></title>
    <url>%2F2019%2F10%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-15%EF%BC%89%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%EF%BC%88%E9%99%84%E5%8A%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[二叉查找树的插入操作递归实现 思路： 整体还是围绕二叉查找树的性质进行定位要插入的位置，当移动到空位置时则会返回一个插入值构建的新结点供其父结点相接，因为使用递归如果要插入的位置为两个结点之间，则会先把后一个结点的左右孩子先接入这个新的结点后再把这个新结点接入其前面的结点 12345678910BiNode* InsertBST(BiNode root,T e)&#123; if(!root)return new BiNode(e); if(e &lt; root-&gt;data) root-&gt;L_Node = InsertBST(root-&gt;L_Node,e); else if(e &gt; root-&gt;data) root-&gt;R_Node = InsertBST(root-&gt;R_Node,e); return root;&#125; 循环迭代实现 思路：通过循环进行遍历，来寻找插入的位置。若插入的结点在二叉树中已经存在则之间返回nullptr终止插入操作，否则进行把新的结点进行插入二叉树中 123456789101112131415161718192021BiNode* InsertBST(BiNode root,T e)&#123; BiNode* p = root; BiNode* parent = nullptr; while(p &amp;&amp; p-&gt;data!= e)&#123; parent = p; if(e &lt; p-&gt;data) p = p-&gt;L_Node; else p = p-&gt;R_Node; &#125; if(p)return nullptr; if(!parent)return new BiNode(e); else if(e &lt; parent-&gt;data)&#123; parent-&gt;L_Node = new BiNode(e); return parent-&gt;L_Node; &#125;else&#123; parent-&gt;R_Node = new BiNode(e); return parent-&gt;R_Node; &#125;&#125; 二叉查找树的删除操作 思路：二叉查找树的删除 当找到要删的结点后通常有5种情况， 第一种情况：该结点为叶子结点，那么直接删除即可， 第二种情况：该结点只存右子树，那么直接删除该结点后，要让其前一个结点重新连接到这个被删除结点的右子树。 第三种情况：只存在左子树，处理方法同第二种情况。 第四种情况：左右子树都不存在，此时要寻找待删除结点的右子树最左端的结点(该结点比待删除结点大且最接近)，替换掉待删除结点的数据，然后重新在待删除结点的右结点调用删除操作，把最左端的结点删除即可。 第五种情况：没有找到待删除结点，直接返回空 123456789101112131415161718192021222324252627282930313233343536BiNode* deleteBST(BiNode root , T e)&#123; if(!root) return nullptr; if(root-&gt;data &gt; e) deleteBST(root-&gt;L_Node,e); else if(root-&gt;data &lt; e) deleteBST(root-&gt;R_Node,e); else&#123; //若为叶子结点，直接删除该结点 if(!root-&gt;L_Node &amp;&amp; !root-&gt;R_Node)&#123; delete (root); return nullptr; &#125;else if(!root-&gt;R_Node)&#123; BiNode* ret = root-&gt;L_Node; delete(root); return ret; &#125; else if (!root-&gt;L_Node) &#123; BiNode* ret = root-&gt;R_Node; delete(root); return ret; &#125; else&#123; //若所删除的结点存在左右孩子,则选取其右子树中最小的进行替换该节点，然后往右子树递归上诉操作 BiNode* temp = root-&gt;R_Node; while(temp-&gt;L_Node)&#123; temp = temp-&gt;L_Node; &#125; root-&gt;data = temp-&gt;data; root-&gt;R_Node = deleteBST(root-&gt;R_Node , temp-&gt;data); &#125; &#125; return root; &#125; 代码解析： 有如下二叉树查找树，假设此时要删除 89号的结点 第一步：找到该结点发现该结点存在左右子树，接下来寻找该节点右子树下最左端的结点进行替换。 第二步：替换后，原来89号结点的右子树重复上诉操作被替换的结点111 总体实验结果123456789101112131415161718192021222324252627int main(void) &#123; BiNode&lt;int&gt;* b1 = new BiNode&lt;int&gt;(56); b1-&gt;L_Node = new BiNode&lt;int&gt;(34); b1-&gt;R_Node = new BiNode&lt;int&gt;(89); BiNode&lt;int&gt;* b2 = b1-&gt;L_Node; b2-&gt;R_Node = new BiNode&lt;int&gt;(55); b2-&gt;L_Node = new BiNode&lt;int&gt;(12); b2 = b1-&gt;R_Node; b2-&gt;R_Node = new BiNode&lt;int&gt;(100); b1-&gt;Fot(b1); cout&lt;&lt; "插入了40" &lt;&lt; endl; b1-&gt;Fot(b1-&gt;InsertBST(b1, 40)); cout &lt;&lt; endl; b1-&gt;Fot(b1); cout &lt;&lt; endl &lt;&lt; "删除56" &lt;&lt; endl; b1-&gt;deleteBST(b1, 56); b1-&gt;Fot(b1); cout &lt;&lt;endl&lt;&lt; "删除100"&lt;&lt;endl; b1-&gt;deleteBST(b1, 100); b1-&gt;Fot(b1);&#125; 实验结果：]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（7.1）查找]]></title>
    <url>%2F2019%2F10%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%887-1%EF%BC%89%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[查找的概念在数据集合中寻找满足某种条件的数据元素，也就是根据给定的某个值，在查找表中确定一个关键字等于给定值的记录或数据元素。 关键字 数据元素中某个数据项或单独关键字 关键字可以相同，即不一定唯一标识这个元素 平均查找长度查找就是不断将数据元素的关键字与待查找关键字进行比较，查找算法在查找成功时平均比较的次数称作平均查找长度 查找的类型 线性查找表 ·数据集合是一个线性表(数组或链表) 二叉查找树 数据集合是一个二叉树 哈希(散列)表 根据哈希函数(关键字映射到存储地址)存储和查找。类似根据下标到地址 线性查找主要用于线性的数据结构中进行查找 实现思路讲线性表中的每个元素和关键字进行比较，直到找到满足条件(eg:相等)的元素，则查找成功，给出该对象在表中的位置。 若没有找到关键字相等的元素则查找失败。 直接线性查找 实现思路：通过遍历每一个元素进行匹配要查找的元素，如果找到则返回其下标，未找到则返回 -1 12345678910111213141516171819202122232425template&lt;typename T,typename TKey,typename TFunc&gt;int SqSearch(const vector&lt;T&gt;&amp; array,TKey key,TFunc Func)&#123; for(int i = 0; i &lt; array.size(); i++) if(Func(TKey key,array[i]))return i; return -1; &#125;/*用模板函数使查找条件自由变换*/template&lt;typename TKey,typename T&gt;bool IsEqual(TKey key,T Num)&#123; return key == Num;&#125;int main(void)&#123; vector&lt;int&gt; arr&#123;12,34,678,90,56,89,100,55&#125;; cout &lt;&lt; "数字2的位置为 " &lt;&lt; SqSearch(arr, 2, IsEqual&lt;int, int&gt;) &lt;&lt; endl; cout &lt;&lt; "数字56的位置为 " &lt;&lt; SqSearch(arr, 56, IsEqual&lt;int, int&gt;) &lt;&lt; endl;&#125;/*结果输出：数字2的位置为 -1数字56的位置为 4*/ 二分查找(折半查找)注意!!!：此查找算法要在数组已排好序（从小到大）的情况下才适应 思路：首先待查找值的数组已经是从小到大排序完毕。存在一个mid变量下标，一开始便定位在该数组的中间元素，然后通过要查找的值与该中值比较，如果比中间值大，那么则只需在中值后的元素进行查找，小了则反之。重复多次直到中值与该待查找的值相等了就查找成功，否则失败 123456789101112131415161718192021222324252627282930313233template&lt;typename T,typename TKey,typename TFunc&gt;int BinarySearch(const vector&lt;T&gt; array,TKey Key,TFunc Func)&#123; int min = 0; int max = array.size() - 1; while(min &lt;= max)&#123; auto mid = (max+min)/2; auto ret = Func(Key,array[mid]); if(ret == 0)return mid; else if(ret &lt; 0)&#123; max = mid - 1; &#125;else&#123; mid = mid + 1; &#125; &#125; return - 1;&#125;template&lt;typename T,typename TKey&gt;int IsEqual(TKey key,T Num)&#123; return key - Num;&#125;int main(void)&#123; vector&lt;int&gt; arr&#123;12,34,55,56,89,90,100,678&#125;; cout &lt;&lt; "数字2的位置为 " &lt;&lt; BinarySearch(arr, 2, IsEqual&lt;int, int&gt;) &lt;&lt; endl; cout &lt;&lt; "数字56的位置为 " &lt;&lt; BinarySearch(arr, 56, IsEqual&lt;int, int&gt;) &lt;&lt;endl;&#125;/*输出结果：数字2的位置为 -1数字56的位置为 3*/ 二叉查找树什么是二叉查找树？ 一棵空树，或者是具有下列性质的二叉树 （1）若左子树不空，则左子树上所有节点的值均小于它的[节点的值； （2）若右子树不空，则右子树上所有节点的值均大于它的根节点的值； （3）左、右子树也分别为二叉排序树； （4）没有键值相等的节点。 递归查找算法 思路：类似二叉树的先序遍历，通过对根结点的data进行比较 因为查找二叉树的左子树是一定小于其结点的，右子树则一定大于结点。所以可以通过比较结点的data值。来进行递归操作，如果待查找值比结点的数值大那么往右子树找，同理：小了就往左子树找 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253template&lt;typename T&gt;struct BiNode&#123; T data; BiNode* R_Node = nullptr; BiNode* L_Node = nullptr; BiNode(T num)&#123; data = num; &#125; BiNode* BiSearchTree(BiNode* tree,T Key)&#123; if(!tree)return nullptr; if(tree-&gt;data == Key)return tree; if(tree-&gt;data &gt; Key)&#123; return BiSearchTree(tree-&gt;L_Node,Key); &#125;else&#123; return BiSearchTree(tree-&gt;R_Node,Key); &#125; &#125;&#125;;int main(void)&#123; BiNode&lt;int&gt; b1(56); BiNode&lt;int&gt; b2(55); BiNode&lt;int&gt; b3(34); BiNode&lt;int&gt; b4(12); BiNode&lt;int&gt; b5(89); BiNode&lt;int&gt; b6(100); b1.L_Node = &amp;b2; b1.R_Node = &amp;b5; b2.R_Node = &amp;b3; b2.L_Node = &amp;b4; b5.R_Node = &amp;b6; cout &lt;&lt; endl; if (b1.BiSearchTree(&amp;b1, 1))cout &lt;&lt; "找到了" &lt;&lt; endl; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125; if (b1.BiSearchTree(&amp;b1, 89))cout &lt;&lt; "找到了" &lt;&lt; endl; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125;&#125;/*输出结果：没有找到找到了*/ 使用循环迭代来实现查找二叉树的查找 思路：总体思路也是跟递归差不多，运用二叉查找树的特性，循环中如果结点不为空并且结点的data值与要查找的值不相等意味着还没有查找到值则继续对结点的data值进行比较，如果大了就移动到该结点的右子树继续查找，同理，小了就向左边移动继续查找，循环上诉操作。当循环结束后便根据最终指针移动后得到的结点情况来判断是否查找成功，如果为空那么就没有找到，反之则查找成功 12345678910111213141516171819202122232425262728293031323334353637383940414243444546BiNode* BiSearchTree2(BiNode* tree,T Key)&#123; BiNode* temp = tree; while(temp &amp;&amp; temp-&gt;data != key) if(Key &gt; temp-&gt;data) temp = temp-&gt;R_Node; else temp = temp-&gt;L_Node; if(!temp)return nullptr; return temp;&#125;int main(void)&#123; BiNode&lt;int&gt; b1(56); BiNode&lt;int&gt; b2(55); BiNode&lt;int&gt; b3(34); BiNode&lt;int&gt; b4(12); BiNode&lt;int&gt; b5(89); BiNode&lt;int&gt; b6(100); b1.L_Node = &amp;b2; b1.R_Node = &amp;b5; b2.R_Node = &amp;b3; b2.L_Node = &amp;b4; b5.R_Node = &amp;b6; cout &lt;&lt; endl; if (b1.BiSearchTree2(&amp;b1, 1))cout &lt;&lt; "找到了" &lt;&lt; endl; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125; if (b1.BiSearchTree2(&amp;b1, 89))cout &lt;&lt; "找到了" &lt;&lt; endl; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125;&#125;/*输出结果：没有找到找到了*/ —（本文未完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-(3.3)typename的使用场合及使用范例、函数指针参数化]]></title>
    <url>%2F2019%2F09%2F19%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-3-3-typename%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E5%90%88%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%8C%83%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[typename的使用场合在类模板中存在自定义类型时 相关返回值函数必须添加typename 范例： 123456789101112131415161718192021template&lt;typename T&gt;class array&#123; public: /*自定义类型：把模板参数T定义为 自定义类型名Size*/ typedef T Size; Size getsize(T i);&#125;/*类外定义的时候需要添加 typename 模板类名&lt;&gt; 来指定该模板类中的自定义类型Size*/template&lt;typename T&gt;typename array&lt;T&gt;::Size array&lt;T&gt;::getsize(T i)&#123; cout &lt;&lt; "size的值为" &lt;&lt; i; return i;&#125;int main()&#123; array&lt;int&gt; arr; arr.getsize(2);&#125; 实验结果： 在类模板中存在内部类的情况 范例: 12345678910111213141516171819202122232425template&lt;typename T&gt;class Lklist&#123; Node* head; class Node&#123; public: Node* next; T data; &#125;; public: Node* GetNodeID(int i);&#125;;template&lt;typename T&gt;typename Lklist&lt;T&gt;::Node* Lklist&lt;T&gt;::GetNodeID(int i)&#123; cout &lt;&lt; "测试函数传参的值为 " &lt;&lt; i &lt;&lt; endl; return NULL;&#125;int main()&#123; Lklist&lt;int&gt; lk; lk.GetNodeID(100);&#125; 实验结果： 总结： 上述两种情况，在类模板外定义函数时，都必须要加typename 目的是通知编译器，该名称是一个类型名称，且为类模板内定义的类型或类。 上述情况只能用typename不能替换为class 其余范例： 123456789101112131415template&lt;typename T&gt;typename T::size_type getlength(const T&amp;c)&#123; if(c.empty()) return 0; return c.size(); &#125;int main()&#123; string str = "HelloShuHao"; string::size_type size = getlength(str); cout &lt;&lt; "测试值:str的长度为：" &lt;&lt; size &lt;&lt; endl;; &#125; 实验结果： 函数指针作参数1234567891011121314typedef int(*Func)(int a,int b);int add(int i, int k)&#123; return i+k;&#125;void testfunc(int i, int k, Func f)&#123; cout &lt;&lt; "测试函数指针 两数相加的值为: " &lt;&lt; f(i,k) &lt;&lt; endl;&#125; int main()&#123; testfunc(10,15,add);&#125; 实验结果： typename使用范例改造成函数模板1234567891011121314151617typedef int(*Func)(int a,int b);int add(int i, int k)&#123; return i+k;&#125;template&lt;typename T,typename F&gt;void testfunc(T i, T k, F f)&#123; cout &lt;&lt; "测试函数指针 两数相加的值为: " &lt;&lt; f(i,k) &lt;&lt; endl;&#125; int main()&#123; //此时F类型识别为函数指针，则使用函数指针类型 testfunc(10,15,add);//依旧通过编译没有报错&#125; 若使用类(可调用对象)123456789101112131415161718192021222324252627282930313233343536373839typedef int(*Func)(int a,int b);int add(int i, int k)&#123; return i+k;&#125;class TestClass&#123; public: TestClass()&#123; cout &lt;&lt; "这是TC的构造函数 被调用了" &lt;&lt; endl; &#125; TestClass(const TestClass&amp; t)&#123; cout &lt;&lt; "拷贝构造函数 被调用了" &lt;&lt; endl; &#125; int operator()(int a,int b)&#123; return a+b; &#125; &#125;;template&lt;typename T,typename F&gt;void testfunc(T i, T k, F f)&#123; cout &lt;&lt; "测试函数指针 两数相加的值为: " &lt;&lt; f(i,k) &lt;&lt; endl;&#125; int main()&#123; //此时F类型识别为函数指针，则使用函数指针类型 testfunc(10,15,add);//依旧通过编译没有报错 cout &lt;&lt; endl; TestClass tc;//此时调用构造函数 testfunc(100,150,tc);//传参是参数临时对象，调用拷贝构造函数&#125; 实验结果： 结果分析：可以发现，当对象被创建时调用了一次构造函数，然后传参入testfunc函数时，调用了一次拷贝构造函数，最后输出值，整个过程，T的类型推断为int整型 然后 F被推断为TestClass类型，然后该类型对象通过重载后的()返回两个整型参数的和值。 此时也可以通过直接传参消除临时对象12345int main()&#123; //TestClass tc; testfunc(100,150,TestClass());//直接使用构造函数，可以消除临时对象的产生&#125; 实验结果： 默认模板参数总体跟函数默认参数类似，从右到左，存在默认参数不能有断 范例： 12345template&lt;typename T,int a = 100&gt;class A&#123;&#125;;//没有问题template&lt;typename T = string,int a = 100&gt;class B&#123;&#125;;//没有问题template&lt;typename T = string,int a&gt;class C&#123;&#125;;//报错！a没有提供默认参数 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-(3.2)类模板]]></title>
    <url>%2F2019%2F09%2F18%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-3-2-%E7%B1%BB%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[类模板模板参数类型使类能够根据给定的实际类型，来对类内的一些参数类型进行变化 编译器不能为类模板推断模板参数类型，所以要使用类模板，必须要在模板名后用&lt;&gt;来提供实际类型 格式： template&lt;typename T&gt;class 类名 template&lt;typename T，B&gt;class 类名 template&lt;typename T，int a&gt;class 类名 注意： 类模板成员函数，可以写在类模板定义中。(即：不在类外定义类成员函数）其中这种成员函数会隐式声明为inline内联函数 类模板被实例化对象后，类内的对应的实例都会有自己版本的成员函数 在实例化类模板对象的时候，要在类模板名后加&lt;&gt;并给定实际类型 定义在类模板之外的成员函数必须以template关键字开头，后面加类模板的参数列表。其次类名后面要添加&lt;&gt;吧模板参数列表里面的所有模板参数名列出来(多个参数用 , 隔开) 范例： 123456789101112131415161718192021222324252627282930template&lt;typename T&gt;class Sqlist&#123; public: T* data;//使用模板参数 /*类内定义的函数会隐式声明为inline函数*/ /*inline*/ void func()&#123; cout &lt;&lt; "这是该类的func函数" &lt;&lt; endl; &#125; /*外部定义，在外部要加&lt;&gt;*/ T func2(T a,T b); &#125;;/*要类模板名要添加模板参数列表*/template&lt;typename T&gt; T Sqlist&lt;T&gt;::func2(T a,T b)&#123; cout &lt;&lt; "这是该类的func2函数" &lt;&lt; endl; return a+b;&#125;int main()&#123; /*在实例化类模板对象时，要用&lt;&gt;来提供实际类型*/ Sqlist&lt;int&gt; sq1; sq1.func(); Sqlist&lt;double&gt; sq2; sq2.func2(12.3,14.2);&#125; 实验结果： 非模板类型在定义模板类的时候模板参数不提供模板参数，而是给定实际参数 格式： template&lt;int a&gt;class 类名 template&lt;typename T，int a&gt;class 类名 范例： 1234567891011121314151617181920template&lt;typename T,int size = 10&gt;class Sqlist&#123; public: T data[size]; void func(); &#125;;/*要在类模板后的&lt;&gt;把所有的类模板参数列出来，即便存在默认值*/template&lt;typename T,int size&gt; void Sqlist&lt;T,size&gt;::func()&#123; cout &lt;&lt; "这是该类的func函数 其中size: " &lt;&lt; size &lt;&lt; endl;&#125;int main()&#123; /*存在默认参数可以不给size的值*/ Sqlist&lt;int&gt; sq1; sq1.func(); Sqlist&lt;double,100&gt; sq2; sq2.func();&#125; 实验结果： 注意： 浮点数不能作为非类型模板参数 template&lt;typename T,double a&gt; class B //报错，double和float都不能做非类型模板参数 类类型不能做非类型模板参数 class A{};template&lt;typename T,A a&gt; class B //报错：类类型不能做非类型模板参数 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（3.1）模板、函数模板]]></title>
    <url>%2F2019%2F09%2F17%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%883-1%EF%BC%89%E6%A8%A1%E6%9D%BF%E3%80%81%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[模板所谓泛型编程 是独立于任何特定类型类型的方式编写代码。使用泛型编程时，需要提供具体的程序实例。 模板是泛型编程的基础，是一种在创建类或函数时的一种公式，根据给定的类型来决定公式中具体参数的类型值。 函数模板函数模板定义与使用会更具实际类型来推断模板实际类型的函数，一般情况下会编译器会自动判别。 格式： template&lt;typename T&gt; T 函数名(参数) template&lt;class T&gt; T 函数名(参数) 范例： 12345678template&lt;typename T&gt; T add(T a,T b)&#123; return a + b;&#125;int main()&#123; cout &lt;&lt; "12 + 13 = " &lt;&lt; add(12,13) &lt;&lt; endl; cout &lt;&lt; "5.6 + 12.3 = " &lt;&lt; add(5.6,12.3) &lt;&lt; endl;&#125; 实验结果： 实际上，函数模板会更具你实际给定的对象类型来生成对应的函数。例如：如果你给定T的类型为double，则系统会生成double add(double a,double b)给定整型int则会生成对应的函数int add(int a,int b)。 非类型模板参数在模板参数列表中没有使用类型参数，而是给定实际的类型的参数 格式：template&lt;实际类型 T&gt; 范例： 1234567891011121314151617181920212223242526/*需要在&lt;&gt;给定实际类型才能调用*/template&lt;int a,int b&gt;int add1()&#123; return a+b;&#125;/*混合型*/template&lt;typename T,int a,int b&gt;T add2(T c)&#123; int temp = c; return a + b + (int)c;&#125;/*特殊：不用提供实际类型，由系统自动推断*/template&lt;unsigned L1,unsigned L2&gt;int charscomp(const char(&amp;p1)[L1],const char(&amp;p2)[L2])&#123; return strcmp(p1,p2);&#125;int main()&#123; cout &lt;&lt; "12 + 13 = " &lt;&lt; add1&lt;12,13&gt;() &lt;&lt; endl; /*不需要在&lt;&gt;中给定实际类型*/ cout &lt;&lt; endl &lt;&lt; charscomp("ShuHao","hello");&#125; 其他 如果要声明函数模板为内联函数，那么inline关键字要在template与函数返回值之间。例如: template&lt;typename T, int a&gt; inline T func(T b){return b+a} 模板函数一般放在头文件中，再多个CPP文件中include该头文件不会出现函数重定义 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-(2.11)类型转换构造函数、运算符、类成员指针]]></title>
    <url>%2F2019%2F09%2F11%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2-11-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E7%B1%BB%E6%88%90%E5%91%98%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[类型转换构造函数实质：把某个类型的变量，通过类的构造函数隐式转换变为该类类型的变量。 例如： 123456789101112class A&#123; int num; A(int i):num(i)&#123;&#125; &#125;int main()&#123; int k = 100; A a = k;//使整型k转换类型为A A a2 = 120; //把整型转换成类型A变量&#125; 类型转换运算符与类型转换构造函数的作用相反，类型转换构造函数是将某个类型转换成该类类型，而类型转换运算符则把该类类型转换成特点的类型 定义格式：operator type()||operator type() const(一般会加const后缀，防止值被修改) 例如： 123456789101112131415class A&#123; public: int num = 100; A(int i):num(i)&#123;&#125; operator int()&#123; return num; &#125; &#125;int main()&#123; A a; int k = a + 100;//结果K的值为200&#125; 显示调用类型转换运算符即：把类型转换运算符当做该类对象的成员函数进行调用 1234int main()&#123; A a; int k = a.operator int() + 100;//显示调用类型转换运算符&#125; 禁止使用隐式调用类型转换运算符对类型转换构造函数同时适用：在前面加explicit(禁止编译器为我们做隐式类型转换) 123456789101112131415class A&#123; public: int num = 100; A(int i):num(i)&#123;&#125; explicit operator int()&#123; return num; &#125; &#125;int main()&#123; A a; int k = a + 100;//报错，&#125; 类成员指针类成员函数指针 定义：指向类成员函数的指针 格式： 声明普通成员函数指针：类名：：*函数指针变量名 获取类成员函数地址：&amp;类名：：成员函数名 使用函数指针格式：(类对象名.*函数指针变量名)(参数)（若为对象指针则使用-&gt;指向运算符调用） 普通成员函数注意点：成员函数属于类，只要类存在这函数地址就存在(有无对象被创建没关系)、若要使用成员函数指针需要绑定到一个类对象上去 范例： 12345678910111213141516class A&#123; public: void Afunc(int i)&#123;cout &lt;&lt; "这是类A中的普通成员函数Afunc，参数I：" &lt;&lt; i &lt;&lt; endl; &#125;&#125;;int main()&#123; /*声明函数指针*/ void(A::*Func)(int); /*给函数指针赋予类成员函数地址值*/ Func = &amp;A::Afunc; A a; A* a2; (a.*Func)(100); //(a2-&gt;*Func)(200);&#125; 实验结果： 虚成员函数 范例： 1234567891011121314class A&#123; public: void Afunc(int i)&#123;cout &lt;&lt; "这是类A中的普通成员函数Afunc，参数I：" &lt;&lt; i &lt;&lt; endl; &#125; virtual void virtualFunc(int i)&#123;cout &lt;&lt; "这是类A中的虚成员函数virtualFunc，参数I：" &lt;&lt; i &lt;&lt; endl; &#125; &#125;;int main()&#123; /*声明函数指针*/ void(A::*virtualFunc)(int) = &amp;A::virtualFunc; A a; (a.*Func)(100);&#125; 实验结果： 静态类成员函数 格式： 声明普通成员函数指针：*函数指针名 (eg: void(*staticFunc)(int)) 获取地址：&amp;类名：：成员函数名 使用：直接 函数指针名(参数) 类成员变量格式： 定义指针: 类型 类名：：*指针名 获取地址: &amp;类名：：成员变量名 注意：此时获取的地址不是该成员变量在内存中的地址，而是对于类来说的偏移量 普通成员变量范例： 12345678910111213141516class B&#123; public: int num1; int num2;&#125;;int main()&#123; int B::*P_num = &amp;B::num1; B b; b.*P_num = 100; cout &lt;&lt; "此时类B中的成员变量num1的值为 " &lt;&lt; b.num1 &lt;&lt; endl; return 0;&#125; 实验结果： 静态成员变量范例： 12345678910111213141516class B&#123; public: int num1; static int num2;//此时只是声明了一个静态变量。要在类外定义&#125;;int B::num2 = 0;int main()&#123; int* static_P_num = &amp;B::num2; B b; *static_P_num = 100; cout &lt;&lt; "此时类B中的静态成员变量num2的值为 " &lt;&lt; b.num2 &lt;&lt; endl; return 0;&#125; 实验结果： —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（2.10）构造函数继承、多继承、虚继承]]></title>
    <url>%2F2019%2F09%2F06%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-10%EF%BC%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[构造函数继承C++在继承的时候子类在构造的时候是会调用父类的构造函数的，但实际上，父类的默认构造函数、拷贝构造、移动构造函数是不会继承给子类的，子类只会继承父类由程序员自己定义的构造函数。 1234567891011121314151617181920212223242526272829class Father&#123; public: int f_num; Father(int i):f_num(i)&#123; cout &lt;&lt; "父类的构造函数被调用" &lt;&lt; endl; &#125; virtual ~Father()&#123; cout &lt;&lt; "父类的析构函数被调用" &lt;&lt; endl; &#125; &#125;;class Child1:public Father&#123; public: int c1_num; Child1(int i):c1_num(i),Father(i)&#123; cout &lt;&lt; "子类1的构造函数被调用" &lt;&lt; endl; &#125; ~Child1()&#123; cout &lt;&lt; "子类1的析构函数被调用" &lt;&lt; endl; &#125; &#125;;int main()&#123; Child1 c(9);&#125; 实验结果： 当父类中含有多个参数的构造函数时，子类也会继承与其，但是在子类的默认构造函数中不会调用父类的这些构造函数，而是会调用无参的父类的构造函数或者带有默认参数的构造函数。 123456789101112131415161718192021222324252627282930313233343536373839class Father&#123; public: int f_num; int f_num2; Father(int i,int k):f_num(i),f_num2(k)&#123; cout &lt;&lt; "父类的构造函数被调用" &lt;&lt; endl; &#125; Father(int i = 100):f_num(i),f_num2(i)&#123; cout &lt;&lt; "父类的构造函数被调用" &lt;&lt; endl; &#125; virtual ~Father()&#123; cout &lt;&lt; "父类的析构函数被调用" &lt;&lt; endl; &#125; &#125;;class Child1:public Father&#123; public: int c1_num; Child1(int i):c1_num(i)&#123; cout &lt;&lt; "子类1的构造函数被调用" &lt;&lt; endl; &#125; ~Child1()&#123; cout &lt;&lt; "子类1的析构函数被调用" &lt;&lt; endl; &#125; &#125;;int main()&#123; Child1 c(9); cout &lt;&lt; "父类的f_num： "&lt;&lt;c.f_num &lt;&lt; "父类的f_num2：" &lt;&lt; c.f_num2 &lt;&lt; endl;&#125; 实验结果： 结果分析：可以发现子类调用了父类的Child1(int i = 100):c1_num(i),Father(i) 那如果要在子类对象再创建时调用父类的其他构造函数该怎么办呢？除了在子类的构造函数里调用的方法外还可以使用using关键字实现 1234567891011121314151617181920212223class Child1:public Father&#123; public: int c1_num; using Father::Father;//使用using关键字 Child1(int i):c1_num(i)&#123; cout &lt;&lt; "子类1的构造函数被调用" &lt;&lt; endl; &#125; ~Child1()&#123; cout &lt;&lt; "子类1的析构函数被调用" &lt;&lt; endl; &#125; &#125;;int main()&#123; Child1 c(9,2); cout &lt;&lt; "父类的f_num： "&lt;&lt;c.f_num &lt;&lt; "父类的f_num2：" &lt;&lt; c.f_num2 &lt;&lt; endl; &#125; 实验结果： 结果分析：使用using Father::Father;发现子类在没有创建2个参数的构造函数也可以用两个参数进行调用构造函数，原因是使用using Father::Father;后编译器会在子类创建隐藏的含有两个参数的构造函数，用来调用父类的其他构造函数。 小结：C++中，如果父类含有多个构造函数，多数下会全部继承，但有以下例外： 子类中的构造函数与父类的构造函数有相同的参数列表，则子类会覆盖父类的构造函数，导致无法继承父类的构造函数 默认构造函数，移动、拷贝构造函数不会被继承。 多重继承与虚继承多重继承C++允许多继承，一个子类在多继承时，会存在两个或以上个父类，也意味着，该子类会继承多个父类的成员变量、成员函数。 123456789101112131415161718192021222324252627282930313233343536373839class A&#123; public: int a; A(int i):a(i)&#123; cout &lt;&lt; "调用了A的构造函数" &lt;&lt; endl; &#125; virtual ~A()&#123; &#125; &#125;;class B&#123; public: int b; B(int i):b(i)&#123; cout &lt;&lt; "调用了B的构造函数" &lt;&lt; endl; &#125; virtual ~B()&#123; &#125; &#125;;/*C同时继承A和B*/class C:public B,public A&#123; public: int c C(int i):c(i)&#123; cout &lt;&lt; "调用了C的构造函数" &lt;&lt; endl; &#125; virtual ~C()&#123; &#125; &#125;;int main()&#123; C c(1);&#125; 实验结果： 结果分析：结果发现，在创建C类对象时，调用了A和B的构造函数。 上述的多继承父类构造函数调用顺序是根据子类的继承(派生列表)顺序来决定的，例如上面是先继承B在继承A，则先调用B的构造函数再调用A的构造函数。如果先继承A再继承B则： 多重继承引发的问题多继承引发的父类创建累赘多余对象问题当一个子类继承两个类的时候，恰好被继承的两个类又继承于同一个父类，那么该子类在创建对象的时候就会调用两次该父类的构造函数，这样的操作难免会造成程序效率低下的情况 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class father&#123; public int father_num; father()&#123; cout &lt;&lt; "调用了father类的构造函数" &lt;&lt; endl; &#125;&#125;class A1 :public father&#123; public: int a1; A1(int i):a1(i)&#123; cout &lt;&lt; "调用了A1的构造函数" &lt;&lt; endl; &#125; virtual ~A1()&#123; &#125; &#125;;class A2:public father&#123; public: int a2; A2(int i):a2(i)&#123; cout &lt;&lt; "调用了A2的构造函数" &lt;&lt; endl; &#125; virtual ~A2()&#123; &#125; &#125;;/*C同时继承A1和A2*/class C:public A2,public A1&#123; public: int c; C(int i):c(i),A1(i),A2(i)&#123; cout &lt;&lt; "调用了C的构造函数" &lt;&lt; endl; &#125; virtual ~C()&#123; &#125; &#125;;int main()&#123; C c(1);&#125; 实验结果： 结果分析：可以发现，在创建类C对象的时候，调用了两次father类的构造函数，也就意味着本来编译器创建了多余的无意义的父类对象，要解决它则可以使用虚继承。 多继承引发的二义性问题 产生二义性：不明确使用的变量或者函数属于哪一个类（例如上方代码中创建好的c进行调用father类中的father_num变量） 1234int main()&#123; C c(1); cout &lt;&lt; c.father_num &lt;&lt; endl;//报错，调用变量不明确&#125; 解决方案：使用作用域运算符（例如：cout &lt;&lt; c.A2::father_num &lt;&lt; endl;） 虚继承为了解决上诉父类创建多余对象可以使用虚继承进行继承，这样该父类就会成为虚基类。 虚基类(virtual base class)：无论这个类在继承体现中出现多少次，派生类中，都只包含唯一一个共享的虚基类的子内容 例如： 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243/*使用虚继承*/class A1 :virtual public father&#123; public: int a1; A1(int i):a1(i)&#123; cout &lt;&lt; "调用了A1的构造函数" &lt;&lt; endl; &#125; virtual ~A1()&#123; &#125; &#125;;/*使用虚继承*/class A2:virtual public father&#123; public: int a2; A2(int i):a2(i)&#123; cout &lt;&lt; "调用了A2的构造函数" &lt;&lt; endl; &#125; virtual ~A2()&#123; &#125; &#125;;/*C同时继承A1和A2*/class C:public A2,public A1&#123; public: int c; C(int i):c(i),A1(i),A2(i)&#123; cout &lt;&lt; "调用了C的构造函数" &lt;&lt; endl; &#125; virtual ~C()&#123; &#125; &#125;;int main()&#123; C c(1); cout &lt;&lt; c.father_num &lt;&lt; endl;//没有报错&#125; 实验结果： 结果分析：发现此时进行创建类C的对象的时候，father类的构造函数只被调用了一次，且能消除一部分调用父类的变量或者函数时的二义性。 需要注意！！：此时的继承调用构造函数顺序也会发生改变，这里会先构造出虚继承的父类，然后再按照派生列表进行调用其他函数的构造函数。 例如： 12345678910111213141516/*C同时继承A1和A2、B*//*其中A1,A2虚继承了虚基类*/class C:public B,public A2,public A1&#123; public: int c; C(int i):c(i),A1(i),A2(i)&#123; cout &lt;&lt; "调用了C的构造函数" &lt;&lt; endl; &#125; virtual ~C()&#123; &#125; &#125;;int main()&#123; C c(1); &#125; 实验结果： 结果分析：依旧先调用father的构造函数，而不会根据派生列表顺序先进行调用类B的构造函数。 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（2.9）移动构造函数、移动运算符]]></title>
    <url>%2F2019%2F09%2F02%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-9%EF%BC%89%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E7%A7%BB%E5%8A%A8%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[移动对象与移动构造函数 移动对象：移动对象与拷贝对象不同的是，移动对象更像把所有权进行转交，例如要把对象B赋值给A，通常上会进行拷贝操作，即进行：创建B对象(开辟新内存空间)，把A的内容逐一拷贝进B，再把对象A进行释放，这一系列的操作会产生临时的对象。在总体上来说进行了创建和拷贝这两步操作会使程序运行效率大大折扣，但移动对象就不同了，它进行的是转交内存的操作，即直接把A对象的相关数据内存地址直接转交给对象B从而跳过了创建对象和拷贝对象的两个操作。 移动构造函数C++11新出的移动构造函数对于拷贝构造函数来说，就是专门进行移动对象而设计的。 示例： 12345678910111213141516171819202122232425262728293031323334353637class student&#123; int ID; string name; public: student(int i,string n):ID(i),name(n)&#123; cout &lt;&lt; "调用了Student类的构造函数" &lt;&lt; endl; &#125; /*拷贝构造函数*/ student(const student&amp; temp):ID(temp.ID),name(temp.name)&#123; cout &lt;&lt; "调用了拷贝构造函数" &lt;&lt; endl; &#125; /*拷贝赋值运算符*/ student&amp; operator= (const student&amp; temp)&#123; if(&amp;temp == this) return *this; ID = temp.ID; name = temp.name; cout &lt;&lt; "使用了拷贝赋值运算符" &lt;&lt; endl; return *this; &#125; &#125;;static student getStudent()&#123; student a; return a;&#125;int main()&#123; student person = getStudent();&#125; 实验结果 结果分析：从运行结果来看。这个getStudent() 函数在进行的时候，在里面首先创建了对象&#39;a&#39;进而调用了构造函数，然后在return a这步中生成了临时对象a，把函数原有的对象a拷贝给了临时对象a，并把临时对象返回出去(因为函数体内的对象a生命期只在函数体内，所以在返回时会创建临时对象a进行返回)。 移动构造函数的使用从结果来看：这里是进行了拷贝操作，难免会出现对象创建、拷贝等影响效率的操作，但对于这里临时对象a再使用后便可不再重复利用的对象使用移动对象进行操作时比进行拷贝操作时的程序效率更高，因为进行移动操作对象就不必再创建新的对象，使用额外的内存空间去保存一次性使用的对象了。 代码： 1234/*移动构造函数*/student (student&amp;&amp; temp) noexcept :ID(temp.ID),name(temp.name)&#123; cout &lt;&lt; "调用了移动构造函数" &lt;&lt; endl;&#125; 实验结果： 结果分析：可以发现此时的临时对象则调用了移动构造函数来进行返回。 noexcept：通知编译器这里不会产生异常，任何移动对象有关的函数无论是声明还是定义都得加noexcept 提要：在getStudent()函数中是产生了临时对象才会调用拷贝构造函数，如果消除此处的临时对象则不会调用拷贝构造函数 移动赋值运算符相比拷贝赋值运算符，移动赋值运算符是专门对赋值是移动对象使用的 代码： 12345678910/*移动赋值运算符*/ student&amp; operator= (student&amp;&amp; temp)noexcept &#123; if (&amp;temp == this) return *this; ID = temp.ID; name = temp.name; cout &lt;&lt; "使用了移动赋值运算符" &lt;&lt; endl; return *this; &#125; 但在实际运用中，系统会默认使用拷贝赋值运算符进行拷贝赋值操作。 只有在特点情况下才会优先使用移动赋值运算符，在上面的getStudent()函数中，只有产生了临时对象才会调用移动构造函数，而没有产生临时对象则不会调用，说明移动对象与临时变量有充分的联系，即：对右值的变量会使用移动构造函数。 移动赋值运算符使用条件 在进行移动赋值的时候要确保原有的对象处于一种即便销毁也不再使用的情况下，则可以使用移动对象操作。(通俗点讲就是：要进行移动操作，原来的对象不能再使用)。 原对象为临时变量。即：原对象为右值时。(std::move()函数就派上用场了) 移动对象时要注意的点当类中包含指针的时 当类中包含指针成员的时候，在进行移动操作的时候要把原有的对象里的指针置零。 移动时要确保该指针断绝原对象的关系，以免在原对象释放的时候对该指针也进行释放，对移动后对象产生不可预料的危险 在进行移动赋值的时候，要先把自己对象中的指针先释放掉，再进行赋值，并把原对象的指针要置零。 实例： 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142class A&#123; int num1;public: A(int i = 0):num1(i)&#123;&#125;&#125;;class B&#123; A* temp;public: B():temp(new A())&#123; cout &lt;&lt; "调用了类B的构造函数 " &lt;&lt; endl; &#125; B(const B&amp; t):temp(t.temp)&#123; cout &lt;&lt; "调用了类B的拷贝构造函数" &lt;&lt; endl; &#125; /*拷贝赋值运算符*/ B&amp; operator=(const B&amp; t)&#123; if(this == &amp;t)return *this; cout &lt;&lt; "使用了类B的拷贝赋值运算符" &lt;&lt; endl; temp = t.temp; return *this; &#125; /*移动构造函数*/ B(B&amp;&amp; t)noexcept:temp(t.temp)&#123; t.temp = nullptr;//要把原来的指针进行置零 cout &lt;&lt; "调用了类B的移动构造函数" &lt;&lt; endl; &#125; B&amp; operator=(B&amp;&amp; t)noexcept&#123; delete temp;//移动赋值时先要释放自己原有的内存地址 temp = t.temp; t.temp = nullptr;//赋值后要把原对象的指针置零，防止在原对象释放时，该指针跟着释放 cout &lt;&lt; "使用了类B的移动赋值运算符" &lt;&lt; endl; &#125; &#125; —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率论与数理统计（二）]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[条件概率与乘法公式 条件概率： P(B|A) = P(AB) / P(A) P(A|B) = P(AB) / P(B) 乘法公式 P(AB) = P(A) - P(B|A) = P(B) - P(A|B) 全概率公式与贝叶斯公式 全概率公式： P(A) = \sum_{i=1}^nP(B_i)P(A|B_i) P(A) 要发生的事件的概率 P(Bi)为A发生的前提事件的概率 P(A|Bi)为Bi事件已经发生后的前提下，A事件发生的概率 贝叶斯公式：（逆概率公式） P(B_i|A) = \frac {P(B_i)P(A|B_i)}{P(A)}]]></content>
      <tags>
        <tag>学习总结</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率论与数理统计（一）]]></title>
    <url>%2F2019%2F08%2F28%2F%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[事件运算及概率 事件运算 包含事件 A 并事件 A∪B = A+B 差事件 A - B = ACB = A - AB 交事件 A∩B = AB 互斥事件 AB = ∅ 对立事件 A∪CA = S; ACA = ∅ 独立事件 P(AB) = P(A)P(B) 其他： A、B独立： A、CB CA、B CA、CB互相独立 A、B、C独立： A、B、C两两相互独立(充分不必要) P(ABC) = P(A)P(B)P(C) 公式： 德摩根率： C_{A∪B} = C_A · C_B C_{A∪B} = C_A∪C_B 加法公式 P(A∪B) = P(A) + P(B) - P(AB） P(A∪B∪C) = P(A) + P(B) + P(C) - P(AB) - P(AC) - P(BC) + P(ABC) 减法公式 P(A-B) = P(AC_B) = P(A) - P(AB) 对立事件 P(C_A) = 1 - P(A) 独立事件 P(AB) = P(A)·P(B)]]></content>
      <tags>
        <tag>学习总结</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（6.7）深度优先搜索(邻接矩阵)]]></title>
    <url>%2F2019%2F08%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%886-7%EF%BC%89%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[邻接矩阵的DFS(深度优先搜索)代码实现及思路 实现邻接矩阵DFS算法的前提 思路：要实现邻接矩阵的DFS算法，首先就要在邻接矩阵的结构中设置一个标记数组，用来对应顶点数组在遍历过程中的访问情况，即已经访问过的顶点将被标记已被访问，没有访问的将被标记未访问。 代码1： 1234567891011121314class MGraph&#123; .... vector&lt;bool&gt;Mark;//标记数组 &#125;;/*创建标记数组*/void create_mark()&#123; //避免重复创建+验证 if(Mark.size() != Vertex.size())return;//Vertex是顶点数组 Mark.resize(Vertex.size(),false);&#125; 遍历实现DFS 思路：根据标识数组来确定是否要访问，函数参数可以更加顶点数组来指定结点开始，并可以通过函数指针作为参数之一多样化的去遍历图 代码： 123456789101112void DFS(unsigned int ID,void(*visit)(const VT&amp; vertex))&#123; if(ID &lt; 0 || ID &gt; Mark.size())return; Mark[ID] = true; vistit(Vertex[ID]); for(int k = 0; k &lt; Vertex.size(); k++)&#123; if(Edges[ID][k] != definfo)&#123; if(!Mark[k]) DFS(k,visit); &#125; &#125;&#125; 代码解析 Mark/Vertex 1 false 2 false 3 false 4 false 邻接矩阵 A B C D A 0 1 1 1 B 1 0 1 0 C 1 1 0 1 D 1 0 1 0 第一步DFS(unsigned int ID,void(*visit)(const VT&amp; vertex)) Mark[0] = true； 输出了A Edge[0] [0]不输出，输出B,C,D 堆栈实现 思路：通过堆栈来模拟递归实现 代码： 12345678910111213141516171819202122232425262728293031void DFS2(unsigned int ID,void(*visit)(const VT&amp; vertex))&#123; if(ID &lt; 0 || ID &gt; Vertex.size())return; create_mark(); for(int i = 0; i &lt; Vertex.size(); i++)&#123; DFS_(i,visit); &#125;&#125;void DFS_(unsigned int ID,void(*visit)(const VT&amp; vertex))&#123; if(ID &lt; 0 || ID &gt; Vertex.size())return; stack&lt;int&gt; s; s.push(ID); Mark[ID] = true; while(!s.empty())&#123; auto v = s.top();s.pop(); visit(Vertex[v]); &#125; for(int w = 0; w &lt; Vertex.size(); w++)&#123; if(Edge[ID][w] != definfo)&#123; if(!Mark[w])&#123; s.push(w); Mark[w] = true; &#125; &#125; &#125; &#125; —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（6.6）图的遍历]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%886-6%EF%BC%89%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[图的遍历（图的遍历是图的基本运算） 定义：从已给的连通图中的某一个顶点出发，沿着一些边去访问遍历图中所有的顶点，且使每个顶点仅被访问一次 实质：找每个顶点的邻接点的过程 遍历算法 深度优先搜索(DFS) 类似树的先序遍历 广度优先搜索(BFS) 类似树的层次遍历 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（6.5）图的实现-邻接表]]></title>
    <url>%2F2019%2F08%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%886-5%EF%BC%89%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0-%E9%82%BB%E6%8E%A5%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[邻接表邻接表是一种顺序分配和链式分配相结合的存储结构，其顶点集由顺序表进行存储，其边则用邻接顶点来表示，而邻接点则用链式结构在顺序结构中的每一个顶点来承载，通俗点讲，就是把一堆链表用顺序表进行存储的结构。 邻接表的实现及思路邻接表的结构 思路：邻接表结构是由一个顶点结点数组，和各个邻接点组成的，其中顶点数组中含有顶点数据和指向邻接点的链域，而邻接点由邻接点域(对应顶点数组的顶点下标)和顶点所连接的其他顶点的邻接点地址。所以实现邻接表结构，首先就要有顶点数组和邻接点结构。 代码： 123456789101112131415161718192021222324252627template&lt;typename VT,typename Einfo&gt;class AGraph&#123; /*邻接点结构*/ struct Edge_Node&#123; unsigned int ID;//对应顶点数组下标 Einfo info;//保存权重 Edge_Node* next;//指向下一个邻接点的指针 Edge_Node(unsigned int id,Einfo info):ID(id),info(info),next(nullptr)&#123;&#125;; &#125;; /*顶点数组元素结构*/ struct VerTex_Node&#123; VT v_data;//顶点数据 Edge_Node* Edge; VerTex_Node(VT v):v_data(v),Edge(nullptr); &#125;; vector&lt;VerTex_Node&gt;Vertexs;//顶点数组 unsigned int Num_Edge; bool undirected; public: AGraph(bool undirected = true):undirected(undirected),Num_Edge(0)&#123;&#125;;&#125;; 添加顶点 思路：直接进行把顶点加入顶点数组即可 代码： 123void Add_VerTex(VT t)&#123; Vertexs.push_back(new VerTex_Node(t));&#125; 填加边 思路：这里要注意的时，邻接表中的邻接点是以链表结合数组进行实现的，所以在添加边的时候，要对边结点的链域进行处理，这里可以采用链表中的前插法，邻接点一个个插入顶点数组的链域之间。 代码： 1234567891011121314151617bool Add_Edges(int id1,int id2,Einfo info)&#123; Edge_Node* p = new Edge_Node(id2,info); if(!p)return false; p-&gt;next = Vertexs[id1].Edge; Vertexs[id1].Edge = p; if(undirected)&#123; Edge_Node* p = new Edge_Node(id1,info); if(!p)return false; p-&gt;next = Vertexs[id2].Edge; Vertexs[id2].Edge = p; &#125; return true;&#125; 修改边的权值 思路：这个操作的思路比较明确，更加要修改的边，通过循环遍历该起始点的顶点数组中的链域结构即可。 代码： 1234567891011121314151617void set_Edge(const int id1,const int id2,const Einfo&amp; info)&#123; Edge_Node* p = Vertexs[id1].Edge; while(p)&#123; if(p-&gt;ID == id2) p-&gt;info = info; p = p-&gt;next; &#125; if(undirected)&#123; Edge_Node* p = Vertexs[id2].Edge; while(p)&#123; if(p-&gt;ID == id1) p-&gt;info = info; p = p-&gt;next; &#125; &#125;&#125; 具体代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;template&lt;typename VT, typename Einfo&gt;class AGraph &#123; /*邻接表结构-边结点*/ struct Edge_Node &#123; unsigned int ID;//对应顶点集的下标 Einfo info;//权重 Edge_Node* next; Edge_Node(unsigned int id, Einfo info) :ID(id), info(info), next(nullptr) &#123;&#125;; &#125;; /*顶点结点结构*/ struct Vertex_Node &#123; VT v_data; Edge_Node* Edge = nullptr; Vertex_Node(VT v) :v_data(v) &#123;&#125;; &#125;; vector&lt;Vertex_Node&gt; VerTexs;//顶点集 unsigned int Num_Edge;//边数 bool undirected;public: AGraph(bool undirected = true) :undirected(undirected), Num_Edge(0) &#123;&#125;; VT operator[](int i) &#123; return VerTexs[i].v_data; &#125; void Add_VerTex(VT t) &#123; VerTexs.push_back(Vertex_Node(t)); &#125; bool Add_Edges(unsigned int id1, unsigned int id2, Einfo info) &#123; Edge_Node* p = new Edge_Node(id2, info); if (!p)return false; /*前插*/ p-&gt;next = VerTexs[id1].Edge; VerTexs[id1].Edge = p; Num_Edge++; if (undirected) &#123; Edge_Node* p = new Edge_Node(id1, info); if (!p)return false; p-&gt;next = VerTexs[id2].Edge; VerTexs[id2].Edge = p; &#125; return true; &#125; void set_Edge(const int id1, const int id2, const Einfo&amp; info) &#123; Edge_Node* p = VerTexs[id1].Edge; while (p) &#123; if (p-&gt;ID == id2) p-&gt;info = info; p = p-&gt;next; &#125; if (undirected) &#123; Edge_Node* p = VerTexs[id2].Edge; while (p) &#123; if (p-&gt;ID == id1) p-&gt;info = info; p = p-&gt;next; &#125; &#125; &#125; void Print_Agraph() &#123; for (auto&amp; e : VerTexs) &#123; cout &lt;&lt; e.v_data &lt;&lt; " "; Edge_Node* p = e.Edge; while (p) &#123; cout &lt;&lt; p-&gt;ID &lt;&lt; "," &lt;&lt; p-&gt;info &lt;&lt; " "; p = p-&gt;next; &#125; cout &lt;&lt; endl; &#125; &#125; void print() &#123; cout &lt;&lt; "顶点："; for (auto&amp; i : VerTexs) &#123; cout &lt;&lt; i.v_data &lt;&lt; " "; &#125; cout &lt;&lt; endl &lt;&lt; "邻接表:" &lt;&lt; endl; Print_Agraph(); &#125; int Get_n_vertex() &#123; return VerTexs.size(); &#125; int Get_n_edges() &#123; return Num_Edge; &#125;&#125;;int main() &#123; AGraph&lt;char, double&gt; G(false); G.Add_VerTex('A'); G.Add_VerTex('B'); G.Add_VerTex('C'); G.Add_VerTex('D'); G.Add_Edges(0, 1, 12.3); G.Add_Edges(0, 3, 9.5); G.Add_Edges(0, 2, 3.1); G.Add_Edges(1, 2, 13); G.Add_Edges(2, 3, 6); G.print(); cout &lt;&lt; "顶点数量为: " &lt;&lt; G.Get_n_vertex() &lt;&lt; endl; cout &lt;&lt; "边的数量为: " &lt;&lt; G.Get_n_edges() &lt;&lt; endl;&#125; 实验结果： —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-(2.8)临时对象处理和程序优化探讨]]></title>
    <url>%2F2019%2F08%2F17%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2-8-%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86%E5%92%8C%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E6%8E%A2%E8%AE%A8%2F</url>
    <content type="text"><![CDATA[临时对象探讨临时对象的产生在很多情况下都会出现，有临时对象的产生，说明就多调用一次构造函数，多调用一次析构函数，在程序内部消耗资源是比较大的，为对程序进行性能提升优化，首先就是要解决临时对象的问题。 产生临时对象的情况及解决办法：情况1：当对象被当做参数传入函数的时候 具体代码： 1234567891011121314151617181920212223242526272829303132333435class A&#123; int num1; int num2;public: A(int i = 0,int j = 0):num1(i),num2(j)&#123; cout &lt;&lt; "调用了类A的构造函数" &lt;&lt; endl; cout &lt;&lt; "num1= " &lt;&lt; num1 &lt;&lt; endl &lt;&lt; "num2= " &lt;&lt; num2 &lt;&lt; endl; &#125; /*类A的拷贝构造函数*/ A(const A&amp; A)&#123; cout &lt;&lt; "调用了类A的拷贝构造函数" &lt;&lt; endl; num1 = A.num1; num2 = A.num2; &#125; virtual ~A()&#123; cout &lt;&lt; "调用了类A的析构函数" &lt;&lt; endl; &#125; /*相加函数，但这是以对象为参数的类函数*/ int add(A t)&#123; int temp; temp = t.num1 + t.num2; return temp; &#125; &#125;;int main()&#123; A a; a.add();&#125; 实验结果： 结果分析： 根据实验打印情况，发现了A首先调用了构造函数，然后又调用了A的拷贝构造函数。可以发现这里出现了拷贝操作，也就意味着有临时对象的产生，并进行了对象拷贝。原因就出在int add(A t)函数上。先更加拷贝构造函数构造一个临时对象，再进行拷贝操作，并把这个临时对象进行析构。 因为在int add(A t)中，对象以参数的形式传入函数中，所以先对t这个临时对象先进行拷贝操作，也就是t = a(a为传入的对象),其次再进行相加操作并返回和。 如果对add函数进行修改 123456789101112int add(A t)&#123; int temp; temp = t.num1 + t.num2; t.num1 = 1000; return temp;&#125;int main()&#123; A a; a.add(); cout &lt;&lt; a.num1 &lt;&lt; endl;&#125; 也可以发现，在add函数中的修改，是没有影响外界的，即函数中的对象t是一个临时对象。 解决方案： 在add函数中的使用引用进行传参 123456789101112int add(A&amp;t)&#123; int temp; temp = t.num1 + t.num2; t.num1 = 1000; return temp; &#125;int main()&#123; A a; a.add(); cout &lt;&lt; a.num1 &lt;&lt; endl;&#125; 实验结果： 情况2：隐式类型转换调用构造函数的时候，会产生临时对象 具体代码： 12345678910111213141516171819202122232425262728class A&#123; int num1; int num2;public: A(int i = 0,int j = 0):num1(i),num2(j)&#123; cout &lt;&lt; "调用了类A的构造函数" &lt;&lt; endl; cout &lt;&lt; "num1= " &lt;&lt; num1 &lt;&lt; endl &lt;&lt; "num2= " &lt;&lt; num2 &lt;&lt; endl; &#125; /*类A的拷贝构造函数*/ A(const A&amp; A)&#123; cout &lt;&lt; "调用了类A的拷贝构造函数" &lt;&lt; endl; num1 = A.num1; num2 = A.num2; &#125; virtual ~A()&#123; cout &lt;&lt; "调用了类A的析构函数" &lt;&lt; endl; &#125; &#125;;int main()&#123; A a; a = 100;&#125; 实验结果： 结果分析： 可以发现，系统先调用普通构造函数生成了对象a，在进行 a = 100操作的时候，会再次调用一次构造函数，实质上，这里是先把100先隐式转换成类A的临时对象，在把这个对象赋值给原来的对象a，最后销毁这个临时对象。(注意！：这里是赋值给原来的a对象，而不是进行拷贝操作) 1234567/*如果使用拷贝赋值运算符*/A&amp; operator= (const A&amp;t)&#123; num1 = t.num1; num2 = t.num2; cout &lt;&lt; "使用了拷贝赋值运算符" &lt;&lt; endl; return *this;&#125; 解决方案： 让对象定义和初始化同句进行 123int main()&#123; A a = 100;&#125; 情况3：当函数返回值为对象时 具体代码： 123456789101112A add2(A&amp; t) &#123; A a; a.num1 = t.num1 + t.num2; return a;&#125;int main() &#123; A a = 100; add2(a); &#125; 实验结果： 结果分析：从图中可以发现，在执行返回值为对象的函数的时候，会调用一次拷贝构造函数，说明这里发生了拷贝，其中第一个构造函数的函数体外的对象的，第二个构造函数是函数体内的临时对象，除此之外还调用了一次拷贝构造函数，说明这里生成了临时对象，并把临时对象返回出去，（其中三个析构函数分别是临时对象的析构，函数体内对象的析构，函数体外对象的析构） 如果函数体外没有函数返回值的接收值，那么该返回值产生的临时对象会在函数体结束的时候立即被析构 如果有接收对象，那么会在程序结束时进行析构 解决方案： 对存在返回值为对象的函数进行优化 1234567891011/*优化前*/A add2(A&amp; t) &#123; A a; a.num1 = t.num1 + t.num2; return a;&#125;/*优化后*/A add2(A&amp; t) &#123; return A(t.num1+t.num2 , 0);&#125; 结果会只调用两次构造函数，不会调用拷贝构造函数 使用实例1234567891011121314151617181920class A&#123; int num1; int num2; public: A(int num1 = 0,int num2 = 0):num1(num1),num2(num2)&#123;&#125;;&#125;/*传参用引用，避免产生临时对象(情况1)*/A operator+(A&amp; t1,A&amp; t2)&#123; /*返回值为对象时，可以直接在返回值里调用其构造函数进行优化(情况3)*/ return A(t1.num1 + t2.num1 , t1.num2 + t2.num2);&#125;int main()&#123; A a1(100,100); A a2(200,200); /*直接在定义时初始化，防止临时对象产生，提高效率(情况2)*/ A a3 = a1 + a2;&#125; —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（6.4）图的实现-邻接矩阵]]></title>
    <url>%2F2019%2F08%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%886-4%EF%BC%89%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[邻接矩阵用一个二维数组存放顶点间关系（边或弧）的数据，这个二维数组称为邻接矩阵。邻接矩阵又分为有向图邻接矩阵和无向图邻接矩阵。该存储结构，是借助线性代数的邻接矩阵来表示图的结构。 具体实现和思路 邻接矩阵实现： 思路：邻接矩阵的实现是要借助二维数组来实现，在C++中可以使用vector来代替二维数组，从而实现矩阵。 代码： 1234567891011template&lt;typename VT,typename Einfo&gt;class MGraph&#123;vector&lt;VT&gt;VerTex;//顶点集vector&lt;vector&lt;Einfo&gt;&gt;Edge//邻接矩阵bool undirected;public:MGraph(bool undirected = true):undirecter(undirected)&#123;&#125;&#125;; 添加顶点/获得顶点总数： 思路：跟边集构建一样，使用vector进行存储顶点数据 代码： 12345678void Add_VerTex(VT vertex)&#123; VerTex.push_back(vertex);&#125;int Get_n_Vertex()&#123; return VerTex.size();&#125; 构建邻边矩阵： 思路：因为邻边矩阵是一个NXN的方形矩阵(N为顶点数量)，所以在构建邻边矩阵的时候，要先根据顶点总数来创建代表邻边矩阵的二维数组。 代码： 1234567void Create_MGraph(Einfo&amp; definfo = 0)&#123; /*用来防止多次创建邻接矩阵*/ if(VerTex.size() != Edge.size())&#123; const int N_Vertex = Get_n_Vertex(); Edge.resize(N_Vertex,vector&lt;Einfo&gt;(N_Vertex,definfo)); &#125;&#125; 添加边 思路：因为邻接矩阵是一个二维数组，所以添加边的时候直接把顶点下标当做邻接矩阵的坐标位置进行编写即可。 代码： 1234567891011void Add_Edge(const int i,const int j, const Einfo&amp;info = 1)&#123; /*要先创建邻接矩阵才能实现添加边操作*/ if(VerTex.size() != Edge.size()) Create_MGraph(); Edge[i][j] = info; if(undirected)&#123; Edge[j][i] = info; &#125;&#125; 具体代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;template&lt;typename VT, typename Einfo&gt;class MGraph &#123; vector&lt;VT&gt;Vertex;//顶点集 vector&lt;vector&lt;Einfo&gt;&gt;Edges; //邻接矩阵 unsigned int Num_Edge;//边数 bool undirected;//标记是否为无向图public: /*构造函数*/ MGraph(bool undirected = true):undirected(undirected),Num_Edge(0)&#123;&#125; /*获得顶点总数*/ int Get_n_vertex() &#123; return Vertex.size(); &#125; int Get_n_edges() &#123; return Num_Edge; &#125; void create_Mgraph(const Einfo&amp; definfo = 0) &#123; if (Edges.size() != Vertex.size()) &#123; const int n_vertex = Get_n_vertex(); Edges.resize(n_vertex, vector&lt;Einfo&gt;(n_vertex, definfo)); &#125; &#125; void Add_VerTex(VT vertex) &#123; Vertex.push_back(vertex); &#125; void Add_Edges(int i, int j, Einfo info) &#123; if (Edges.size() != Vertex.size()) create_Mgraph(); Edges[i][j] = info; Num_Edge++; if (undirected) &#123; Edges[j][i] = info; &#125; &#125; void Print_Mgraph() &#123; for (auto&amp; e : Edges) &#123; for (auto&amp; w : e) &#123; cout &lt;&lt; w &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; &#125; void print() &#123; cout &lt;&lt; "顶点："; for (auto&amp; i : Vertex) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl &lt;&lt; "邻接矩阵:" &lt;&lt; endl; Print_Mgraph(); &#125;&#125;;int main() &#123; MGraph&lt;char, double&gt; G(false); G.Add_VerTex('A'); G.Add_VerTex('B'); G.Add_VerTex('C'); G.Add_VerTex('D'); G.Add_Edges(0, 1, 12.3); G.Add_Edges(0, 3, 9.5); G.Add_Edges(0, 2, 3.1); G.Add_Edges(1, 2, 13); G.Add_Edges(2, 3, 6); G.print(); cout &lt;&lt; "顶点数量为: " &lt;&lt; G.Get_n_vertex() &lt;&lt; endl; cout &lt;&lt; "边的数量为: " &lt;&lt; G.Get_n_edges() &lt;&lt; endl; &#125; 实验结果： —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（6.3）图的实现边表]]></title>
    <url>%2F2019%2F08%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%886-3%EF%BC%89%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BE%B9%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[边表 边表是把图的顶点，和边分别用顺序表进行存储的结构 这种存储结构是最简单、最容易实现的图存储结构 缺点：如果边的数目过大，会使效率降低 代码实现及思路 边表结构 思路：因为边表是通过两个顺序表分别存储顶点集和边集的存储结构，所以在实现时可以通过创建顶点集和边集的结构，其中边集要有两个顶点在顶点集中的下标数值，和该边对应的权值。其中顺序表可以通过C++内置的vector结构实现。 代码实现： 12345678910111213141516171819202122template &lt;typename VT,typename Einfo&gt; class ElistGraph&#123; /*实现边集结构*/ struct Edge&#123; /*边两头的顶点在顶点集的下标*/ int x; int y; Einfo info;//用来存储权的数据 /*边集构造函数*/ Edge(int i,int j,Einfo info):x(i),y(j),info(info)&#123;&#125;; &#125; vector&lt;VT&gt;VerTex;//顶点集 vector&lt;Edge&gt;Edges;//边集 bool undirected;//用来标记是否为无向图 public: /*边表构造函数(默认为无向表)*/ ElistGraph(bool undirected = true):undirected(undirecter)&#123;&#125;; &#125;; 添加顶点 思路：直接通过对vector结构进行操作添加即可 代码实现： 1void add_VerTex(VT vertex)&#123;VerTex.push_back(vertex);&#125; 添加边 思路：跟添加顶点操作一致 代码实现： 1void add_Edge(const int i, const int j, const Einfo&amp; info)&#123;Edges.push_back(Edge(i,j,info));&#125; 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;/** VT 顶点数据* Einfo 边数据类型(权)*/template &lt;typename VT,typename Einfo&gt;class ElistGraph &#123; struct Edge &#123; int x; int y; Einfo info; Edge(int i, int j, Einfo inf) :x(i), y(j), info(inf) &#123;&#125;; &#125;; vector&lt;VT&gt; VerTex; vector&lt;Edge&gt; Edges; bool undirected;//判断是否为无向图public: /*默认为有向图*/ ElistGraph(bool undirected = true):undirected(undirected)&#123;&#125; /*添加顶点*/ void Add_VerTex(VT vertex) &#123; VerTex.push_back(vertex); &#125; /*添加边*/ void Add_Edges(const int i, const int j, const Einfo&amp; info) &#123; Edges.push_back(Edge(i, j ,info)); &#125; /*重载运算符*/ VT operator[](int i)&#123;return VerTex[i];&#125; VT&amp; operator[](int i) &#123; return VerTex[i]; &#125; /*获得顶点数量*/ int get_n_VT() const&#123; return VerTex.size(); &#125; /*获得边的数量*/ int get_n_e() const&#123; return Edges.size(); &#125; /*打印信息*/ void print() &#123; cout &lt;&lt; "顶点：" &lt;&lt; endl; for (auto&amp; x : VerTex) &#123; cout &lt;&lt; x &lt;&lt; " "; &#125; cout &lt;&lt; endl &lt;&lt; "边：" &lt;&lt; endl; for (auto&amp; e : Edges) &#123; cout &lt;&lt; e.x &lt;&lt; " " &lt;&lt; e.y &lt;&lt; " " &lt;&lt; e.info &lt;&lt; endl; &#125; &#125; &#125;;int main() &#123; ElistGraph&lt;char, double&gt; G(false); G.Add_VerTex('A'); G.Add_VerTex('B'); G.Add_VerTex('C'); G.Add_VerTex('D'); G.Add_Edges(0, 1, 12.3); G.Add_Edges(0, 3, 9.5); G.Add_Edges(0, 2, 3.1); G.Add_Edges(1, 2, 13); G.Add_Edges(2, 3, 6); G.print(); cout &lt;&lt; "顶点数量为: " &lt;&lt; G.get_n_VT() &lt;&lt; endl; cout &lt;&lt; "边的数量为: " &lt;&lt; G.get_n_e() &lt;&lt; endl;&#125; ​ 实验结果： —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（6.2）图的抽象数据类型]]></title>
    <url>%2F2019%2F08%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%886-2%EF%BC%89%E5%9B%BE%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[图的抽象数据类型 ADT Graph Data V是具有相同特性的数据元素的集合名称为顶点集 Relation R = {VR} VR = {|V,W∈V且P(V,W) 表示从V，W的弧，P(v,w)定义了弧的的意义} Operation createGraph(&amp;G,V,VR) 初始条件：V是图的顶点集，VR是图中边/弧的集合 操作结果：按V和VR的定义构造图G DFSTraverse(G) 初始条件：图G存在 操作结果：对图进行深度优先遍历，在遍历过程中对每个顶点访问一次 BFSTraverse(G) 初始条件：图G存在 操作结果：对图进行广度优先遍历，在遍历过程中对每个顶点访问一次 图的数据存储结构 边表 数组表示法(邻接矩阵) 邻接表 十字链表(有向图) 多重邻接表(无向图) — (本文完)]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（2.7）左值和右值、左右值引用、std::move()函数]]></title>
    <url>%2F2019%2F08%2F15%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-7%EF%BC%89%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E3%80%81%E5%B7%A6%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81std-move-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[左值和右值 左值：可以在等号左边的值，通常叫左值 特点：拥有地址，可以被修改和赋值 右值：不能在等号左边的值，通常为右值 特点：临时数据，没有地址，不能够修改和赋值 通俗点讲：左值就是地址值，而右值则是一个单纯的数据 12345int a;int b;b = 1;//此时b是一个地址值，是一个左值，也就是此时这个b代表内存地址，而1只是单纯的数据，为右值a = b;//此时的a是一个左值，而此时的b计算机认为它是一个数据，而不是b这个变量的地址值，故此时b为右值 左值引用和右值引用 左值引用： 123int a = 1;int&amp; a_t = a; int&amp; a_t = 1;//报错：左值引用不能绑定给右值 右值引用： 12int a = 1；int&amp;&amp; a_t = 1//右值引用可以绑定给右值 实质上：右值引用又是一个左值 123int a = 1;int&amp; b = a;int&amp;&amp; b_t = b;//允许 前置运算符和后置运算符 前置运算符(++i)是左值表达式 ++i 实质上，先直接给变量 i+1，然后返回 i 本身。 (++i) = 100;//允许，因为++i 是左值表达式，结果 i 的值为100 —i 同理 后置运算符(i++)是右值表达式 i++ 实质上，先把 i 赋值给一个临时变量 t ，然后再让i + 1，最后返回临时变量 t (i++) = 100//报错 i— 同理 右值引用的作用假设，有两个变量a和b，其中a要拷贝给b，那么正常情况下，b也要先创建内存空间，然后再把a的内容赋值给b。但在C++11后新引入了 &amp;&amp; 运算符，即：右值引用，在实现上述赋值操作时，由于b没有创建空间，而a却有自己的内存空间，那么可以用右值引用直接获得a空间的地址和数据，直接给b，而不是要b再创建空间去接收a的内容。 提高程序运行效率，把拷贝对象变成移动对象来提高程序运行效率 std::move函数 作用：把左值引用强转成右值，使右值引用可以绑定左值 12int a = 1;int&amp;&amp; r_a = std::move(a); 示例：1234string str1 = "ShuHao";string str2 = std::move(str1);cout &lt;&lt;"str1的值为: "&lt;&lt; str1 &lt;&lt; endl;cout &lt;&lt; "str2的值为: " &lt;&lt; str2 &lt;&lt; endl; 实验结果： 可以发现，str1经过move的处理变成了空字符串，其实在实质上，是因为string这个类中通过赋值运算符调用了，移动拷贝函数，即：str2先创建了自己的内存空间，然后把str1的内容先给str2，再把str1，的内容清空。 从两个的图可以发现，str1和srt2的内存地址是不同的，说明执行这个赋值过程中，str2是开辟了新的内存空间，在进行拷贝。 但如果使用右值引用： 可以发现：str1和str2是同一块内存地址，说明str2在执行赋值的时候没有创建新的空间，而是直接引用str1原有的空间，从而免除了str2创建新空间的步骤，提高了程序运行效率 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（6-1）图的定义及概念]]></title>
    <url>%2F2019%2F08%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%886-1%EF%BC%89%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[图 定义：图G(graph)是一些点和线的集合 图中的点叫作顶点(VerTex) 两个顶点的连线叫作边(Edges) Graph = (V,E) V：顶点(数据元素)的有穷非空集合 E：边的有穷集合 图的分类 无向图 每一条边都是没有方向的 顶点集合{A,B,C,D} 边集合{(A,B),(A,D),(C,D),(C,B),(A,C)} 有向图 每一条边有方向的，也称弧(arc) 顶点集合{A,B,C,D} 边集合{(B,A),(A,D),(B,C),(C,A)} 完全图 任意两个顶点都有一条边相连的图叫作完全图 无向完全图：如果有N个结点那么它有N(N-1)/2条边 有向完全图：如果有N个结点那么它有N(N-1)条边 网 网是边或弧带权的图 无向网 有向网 子图 1和2是3的子图 其他 如果边(V,U)∈E，则称顶点V和U互为邻接点(Adjacent) 例：A/B、B/C、C/D…互为邻接点 边(V,U)依附于(incident)顶点V和U(或边与顶点相关联) 例：边(A,B)依附于顶点A、B上 顶点V的度(Degree)是和V相关联的边的数量，记为TD(V)，对于有向图：有出度和入度 例：A的度为3、D的度为2 握手定理：边数(E) = 各顶点度数和/2 相关术语解释 路径 若从一个顶点Vi出发，沿一些边经过一些顶点，再到达顶点Vk,则称沿途的经过顶点的序列为从Vi到Vk的路径 路径的长度 路径上的边或弧的数目 回路(环) 起点与终点相同的路径 简单路径 没有重复顶点的路径，即不含回路 简单回路 除起点和终点相同外，没有其余重复顶点的路径 连通图 在无向图G中，如果从顶点V到顶点V`有路径，则称V和V’是连通的 如果对于图中的任意两个顶点Vi和Vk都是连通的，则称G是连通图 是否连通是对无向图来说的 强连通图 在有向图G中，从顶点u到顶点v有路径，且从顶点v到顶点u也有路径，则称u和v是强连通的 如果有向图的任意两个顶点u和v都是强连通，则称G是强连通图 是否强连通是对于有向图来说的 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.14.1）哈夫曼编码表的代码实现]]></title>
    <url>%2F2019%2F08%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-14-1%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E8%A1%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[哈夫曼编码表 根据构建的哈夫曼树，左分支标记为0有分支标记为1 通过二维数组保存编码表 代码实现 1234567891011121314151617181920char code[256][128] //存储哈夫曼编码表void Codeing(haffmanNode* node,char* temparray,int index)&#123; /*处理空结点的情况+递归出口*/ if(!node)return; /*当到达叶结点的时候*/ if(!node-&gt;R_Node || !node-&gt;L_Node)&#123; temparray[index] = '\0'; strcpy_s(code[node-&gt;data-0],128,temparray); return; &#125; /*递归获取编码表*/ temparray[index] = '0'; Codeing(node-&gt;L_Node,temparray,index++); temparray[index] = '1'; Codeing(node-&gt;R_Node,temparray,index++);&#125; 技术小结： temparray数组用来临时存储字符对应的哈夫曼编码，存储格式为字符串 这里采用二维数组来存储哈夫曼编码表，第一维下标为字符对于的ASCII码，所储存的为对应的编码 当到达叶结点的时候，在该位置下标的temparry设置为结束符，意味着一个字符串(字符编码)的存储完毕 编码过程解析 第一步：Codeing(haffmanNode* node,char* temparray,int index) 根据哈夫曼树构建完毕的node数组 定义char* temparray[128]；index = 0； parent4 拥有左右孩子且不空、temparray[0] = 0 第二步: Codeing(node(parent4)-&gt;L_Node,temparray,index++); index = 1 B无左右孩子执行if(!node-&gt;R_Node || !node-&gt;L_Node)，temparry[1] = ‘\0’ code[66(B)] = “0” return结束此处递归 第三步： Codeing(node(parent4)-&gt;R_Node,temparray,index++); index = 1、temparray[0] = 1 parent3 拥有左右孩子且不空执行左递归、temparry[1] = 0 第四步：Codeing(node(parent3)-&gt;L_Node,temparray,index++); index = 2 D结点没有左右孩子执行if(!node-&gt;R_Node || !node-&gt;L_Node)、temparray[2] = ‘\0’ code[68(D)] = “10” return结束此处递归 第五步：Codeing(node(parent3)-&gt;R_Node,temparray,index++)； temparry[1] = 1,index = 2 parent2拥有左右孩子且不空指向左递归、temparry[2] = 0 第六步：Codeing(node(parent2)-&gt;L_Node,temparray,index++)； index = 3 parent1拥有左右孩子且不空指向左递归、temparry[3] = 0 第七步：Codeing(node(parent1)-&gt;L_Node,temparray,index++)； index = 4 C结点没有左右孩子执行if(!node-&gt;R_Node || !node-&gt;L_Node)、temparray[4] = ‘\0’ code[67(C)] = “1100” return结束此处递归 第八步：Codeing(node(parent1)-&gt;R_Node,temparray,index++)； temparry[3] = 1，index = 4 E结点没有左右孩子执行if(!node-&gt;R_Node || !node-&gt;L_Node)、temparray[4] = ‘\0’ code[69(E)] = “1101” return结束此处递归 第九步：Codeing(node(parent2)-&gt;R_Node,temparray,index++)； temparry[2] = 1、index = 3 A结点没有左右孩子执行if(!node-&gt;R_Node || !node-&gt;L_Node)、temparray[3] = ‘\0’ code[65(A)] = “111” | code[下标] | 储存元素（编码） || :————: | :———————: || 65（A） | 111 || 66（B） | 0 || 67（C） | 1100 || 68（D） | 10 || 69（E） | 1101 | 解析过程错误小结： 函数递归时传参是形参，即index在递归时自加了。结束该分支后返回上一个函数时index值还是递归自加前的值 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.14）哈夫曼树的构建代码实现]]></title>
    <url>%2F2019%2F08%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-14%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[哈夫曼树的构建哈夫曼树的构建步骤 根据权重进行从小到大排列 取最小的两个构成一个子树,并使两个的权值相加用来代替这两个结点 根据这个新的权重再进行排列 重复1.2.3步 代码实现(顺序结构储存) 结点的构建 根据哈夫曼树的构建，结点首先要包含权值、左右子树指针，其次要包含数据 1234567891011121314struct haffmanNode&#123; int weigth;//权值 char data;//数据 haffmanNode* L_Node;//左孩子 haffmanNode* R_Node;//右孩子&#125;/*顺序结构存储二叉树*/haffmanNode node[256]；haffmanNode allL_Node[128];haffmanNode allR_Node[128]; 根据权值进行排序(冒泡排序) 12345678910111213void sortHaffmanNode(haffmanNode* nodes,int length)&#123; haffmanNode temp; for(int i = 0; i &lt; length-1; i++)&#123; for(int k = 0; k &lt; length - 1 - i; k++)&#123; if(nodes[k].weight &lt; nodes[k+1].weight)&#123; temp = nodes[k]; nodes[k] = nodes[k+1]; nodes[k+1] = temp; &#125; &#125; &#125;&#125; 哈夫曼树的构建 对结点先进行排序取最小的构成一颗树 12345678910111213141516171819202122void CreateHaffmanTree(haffmanNode* nodes, int length)&#123; if(length &lt;= 1)return;//递归出口 /*根据权值进行排序*/ sortHaffmanNode(nodes,length); /*用来压缩成哈夫曼编码用*/ allL_Node[length] = nodes[length-1];//保存左结点 allR_Node[length] = nodes[length-2];//保存右结点 /*取最小权重的两个结点重新组成树*/ haffmanNode parent; parent.weight = allL_Node[length].weight + allR_Node[length].weight; parent.L_Node = &amp;allL_Node[length]; parent.R_Node = &amp;allR_Node[length]; nodes[length - 2] = parent; //递归直至哈夫曼树创建完成 CreateHaffmanTree(nodes,length - 1);&#125; 哈夫曼树构建解析例图： 第一步：void CreateHaffmanTree(haffNode* node, int length) node数组内容{A(12),B(26),C(5),D(18),E(4)}，length = 5； 排序后 node{B,D,A,C,E},取最小结点C、E组成树 allL_Node[5] = C、allR_Node[5] = E parent1：weight = (4 + 5)9、L_Node = C、R_Node = E node 数组内容变更为{B(26),D(18),A(12),parent1(9)} 第二步：CreateHaffmanTree(node, length - 1(4)) node 数组内容{B(26),D(18),A(12),parent1(9)}，length = 4 排序后 node{B,D,A,parent1},取最小结点A、parent1组成树 allL_Node[4] = parent1、allR_Node[4] = A parent2：weight = (9+12)21、L_Node = parent1、R_Node = A\ node 数组内容变更为{B(26),D(18),parent2(21)} 第三步：CreateHaffmanTree(node, length - 1(3)) node 数组内容{B(26),D(18),parent2(21)}、length = 3 排序后 node{B,parent2,D},取最小结点parent2、D组成树 allL_Node[3] = D、allR_Node[3] = parent2 parent3：weight = (18+21)39、L_Node = D、R_Node = parent2 node 数组内容变更为{B(26),parent3(39)} 第四步：CreateHaffmanTree(node, length - 1(2)) node 数组内容{B(26),parent3(39)}、length = 2 排序后 node{parent3,B},取最小结点parent3、B组成树 allL_Node[2] = B、allR_Node[2] = parent3 parent4：weight = (26+39)65、L_Node = B、R_Node = parent3 node 数组内容变更为{parent4(65)} 第五步：CreateHaffmanTree(node, length - 1(1)) length = 1 符合if(length &lt;= 1)return;结束递归，哈夫曼树创建完毕 allL_Node 1 2 3 4 5 \ NULL B D parent1 C allR_Node 1 2 3 4 5 \ NULL parent3 parent2 A E —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.13）哈夫曼编码]]></title>
    <url>%2F2019%2F08%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-13%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[哈夫曼编码哈夫曼编码是什么？哈夫曼编码是用来压缩数据的一种手段，在网络上信息的传输都是通过二进制来进行输送的（0和1），在进行数据输送的时候，首先就要将即将输送的数据进行转码，使其变为二进制再进行传输。例如： 要传输‘ABCADBBAED’这段数据。且你知道一个二进制转换编码表： | 字符 | 编码 || :—: | :—: || A | 000 || B | 100 || C | 110 || D | 111 || E | 101 | 则这段字符串会先转换成二进制码：000100110000111100100000101111 上面的二进制转换表编码是以3位进行编码的，而用哈夫曼编码进行编译转换，则会让这段字符串传输的时候能够更为简短。 哈夫曼编码的使用哈夫曼编码是通过哈夫曼树进行转换出来的，例如在上面的字符串：‘ABCADBBAED’是出现在一个文章里面的，这个文章里面含有： 字符 出现次数 A 12 B 26 C 5 D 18 E 4 根据上表进行转换为哈夫曼树 通过对哈夫曼树处理，往左走为0往右走为1，通过记录会形成一个新的转换表 | 字符 | 编码 || :—: | :—: || A | 111 || B | 0 || C | 1100 || D | 10 || E | 1101 | 根据表中的内容把要输送的字符串‘ABCADBBAED’进行转换成二进制111011001111000111110110 对比一开始用3个编码进行转换的字符串编码会发现，哈夫曼编码进行转换处理的二进制码数为24个，比前面的少了6个，可以发现运用哈夫曼编码可以使传输的二进制码被压缩成更简单二进制码。 哈夫曼编码的好处 使转换的二进制码更简洁 哈夫曼编码是通过检测传输的字符串中字符的出现频率进行生成对应的编码表。采用的是前缀编码。 因为采用的前缀的编码，进行译码的时候减少出错 …. 译码进行译码的过程很简单，通过一开始构建的哈夫曼树，进行译码。 例如：111011001111000111110110 译码过程：从根开始遇到0就走左，遇到1就走右，当到达叶结点的时候，翻译出该字符，然后重新返回根结点重新识别 译码结果：ABCADBBAED 小结： 从上面的译码过程可以看出，对哈夫曼编码编码后的二进制码进行译码的时候只需根据编码对哈夫曼树进行遍历即可。 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.12）中序线索二叉树的遍历]]></title>
    <url>%2F2019%2F08%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-12%EF%BC%89%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[中序线索二叉树在（5.11）中的线索二叉树便为中序二叉树，因其线索化时利用的是中序遍历。所以构建的线索二叉树为中序线索二叉树。 中序线索二叉树的遍历算法通过构建的中序线索二叉树的特点。叶子结点存在直接指向前驱和后继的结点的指针，在遍历的时候就可以快速的定位。 代码： 12345678910111213141516171819void Threaded_Mid_Traversal(BiTreeNode* R)&#123; if(!R)return; while(R-&gt;L_Node)&#123; R = R-&gt;L_Node; &#125; while(R)&#123; cout &lt;&lt; R-&gt;data &lt;&lt; " "; if(!R-&gt;RTag)&#123; R = R-&gt;R_Node; while(R-&gt;LTag)&#123; R = R-&gt;L_Node; &#125; &#125;else R = R-&gt;R_Node; &#125;&#125; 实验结果： 总结：通过利用线索来进行遍历就可以避免递归或者要使用栈结构来进行遍历。 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.11）线索二叉树]]></title>
    <url>%2F2019%2F08%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-11%EF%BC%89%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[线索二叉树在构造一个二叉树的时候，我们通常会用两个指针来分别代表左孩子和右孩子，但在叶结点上这两个指针往往是空的，且不但是叶结点，在少数结点上也会存在左右孩子不存在的情况下，那么这些空的指针往往会造成资源的浪费，这就为什么要存在线索二叉树，它能使这些空掉的指针能重新运用起来。 线索二叉树的构成为了实现线索二叉树能够使空的指针能被重新利用起来，所以在结点结构定义的时候再添加两个标识符变量。这些标识符存在的目的是为了区分一个结点的左右孩子是否为空，如果是空那么就会指向前驱或者后置结点，如果不为空说明这个指针是指向左右孩子的。 从上面的图可以看出来，当右标识符为&#39;0&#39;的时候说明他的右孩子指针指向的是右孩子，当标识符为&#39;1&#39;的时候，说明这个结点的右孩子指针指向的不是右孩子(即：该结点没有右孩子)而是这个结点的前驱结点，同理，左标识符便是判断其左孩子的指针是指向后置结点还是左孩子。 二叉树线索化根据上面所说的线索二叉树，从最基本的来看，线索二叉树相比普通二叉树就是在没有左孩子或者右孩子的结点中这些本该指向左右孩子的指针不为空，使其能重新废物利用。所以把一个二叉树线索化的主要思路便是遍历一个二叉树，逐一判断每个结点的左右孩子是否为空，若为空那么就让其能指向这个结点的前驱结点或者后置结点。 综上所述，线索化的主要操作就是基于遍历算法。 12345678void Tree_Threaded(BiTreeNode* R)&#123; if(!R)return; Tree_Threaded(R -&gt; L_Node); //在此区域内实现线索二叉树的主要操作... Tree_Threaded(R -&gt; R_Node);&#125; 在开始线索化之前还需要将结点结构进行变化，即要多定义两个标识符表示用来进行判断左右孩子指针的指向。 代码： 123456789struct BiTreeNode&#123; char data; BiTreeNode* L_Node; BiTreeNode* R_Node; /*标识符变量*/ int RTag; int LTag;&#125;; 其次二叉树存在没有利用的指针，线索化后，这些空指针会指向该结点的前驱结点或者后置结点，这也就是说在线索化过程中还要有两个临时变量能够指向受判断结点的前驱结点和后置结点，方便在判断该结点在没有左右孩子的情况下，使其两个指针能够快速的指向前驱和后置结点。 线索化二叉树的代码实现 代码： 123456789101112131415void Tree_Threaded(BiTreeNode* R，BiTreeNode* &amp;pre)&#123; if(!R)return; Tree_Threaded(R -&gt; L_Node,pre); if(!R-&gt;L_Node)&#123; R-&gt;L_Node = pre; R-&gt;LTag = 1; &#125; if(pre &amp;&amp; !pre-&gt;R_Node)&#123; pre-&gt;R_Node = R; pre-&gt;RTag = 1; &#125; pre = R; Tree_Threaded(R -&gt; R_Node,pre);&#125; 二叉树线索化解析：例图： 第一次： | | A | B | C | D | E || :——: | :—: | :—: | :—: | :——-: | :—: || R_Node | | | | | || L_Node | | | | nullptr | || RTag | | | | | || LTag | | | | 0 | | pre指向D 第二次： | | A | B | C | D | E || :——: | :—: | :—: | :—: | :——-: | :—: || R_Node | | E | | B | || L_Node | | D | | nullptr | B || RTag | | 0 | | 1 | || LTag | | 0 | | 0 | 1 | pre先指向B，递归至E结点后指向E 第三次： | | A | B | C | D | E || :——: | :—: | :—: | :—: | :——-: | :—: || R_Node | C | E | | B | A || L_Node | B | D | | nullptr | B || RTag | 0 | 0 | | 1 | 1 || LTag | 0 | 0 | | 0 | 1 | pre先指向E后指向A 第四次： | | A | B | C | D | E || :——: | :—: | :—: | :——-: | :——-: | :—: || R_Node | C | E | nullptr | B | A || L_Node | B | D | A | nullptr | B || RTag | 0 | 0 | 0 | 1 | 1 || LTag | 0 | 0 | 1 | 0 | 1 | pre先指向A后指向C 线索二叉树的好处：从上面可以看出，线索二叉树的一些结点空出来的指针被重新利用起来，再到达叶子结点的时候，可以直接通过左右孩子的指针快速定位到其的前驱结点或后继结点，根据这个性质在进行遍历的时候就可以直接访问这些通过线索链接起来的结点。 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5-10）前序遍历非递归实现]]></title>
    <url>%2F2019%2F08%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-10%EF%BC%89%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前序遍历的非递归实现 思路：跟中序遍历的差不多，通过栈结构，进行排序访问输出。先从根结点开始，往下进行访问和移动，因为是堆栈所以要注意，在进行左右孩子移动的时候，应该让右孩子先入栈，左孩子后入栈，根据栈结构FIBO(先进后出)的结构特点，所以左孩子会先进行访问 代码： 12345678910111213141516bool pre_Traversal(BiTreeNode* R)&#123; stack&lt;BiTreeNode*&gt; s; BiTreeNode* T = R; s.push(T); while(!s.empty())&#123; T = s.top();s.pop(); cout &lt;&lt; T-&gt;data &lt;&lt; " "; if(T-&gt;R_Node)s.push(T-&gt;R_Node); if(T-&gt;L_Node)s.push(T-&gt;L_Node); &#125; return true;&#125;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.9.1）二叉树的遍历非递归[附加]]]></title>
    <url>%2F2019%2F07%2F31%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-9-1%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92-%E9%99%84%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[代码1:1234567891011121314151617bool Mid_Traversal(BiTreeNode* Root)&#123; stack&lt;BiTreeNode*&gt; s; BiTreeNode* T = Root; while(!s.empty()||T)&#123; if(T)&#123; T = T-&gt;L_Node; s.push(T) &#125;else&#123; T = s.top(); s.pop(); cout &lt;&lt; T-&gt;data &lt;&lt; " "; T = T-&gt;R_Node; &#125; &#125; return true; &#125; 代码2：123456789101112131415161718bool Mid_Traversal(BiTreeNode* Root)&#123; stack&lt;BiTreeNode*&gt; s; BiTreeNode* T = Root; s.push(T); while(!s.empty())&#123; while(T = s.top()) s.push(T-&gt;L_Node); T = s.top();s.pop(); if(!s.empty())&#123; T = s.top();s.pop(); if (!Visit(T))return -1; s.push(T-&gt;R_Node); &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.9）二叉树的遍历非递归]]></title>
    <url>%2F2019%2F07%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-9%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[递归的优缺点二叉树的遍历可以使用递归的方式来实现，递归调用函数思路简单，且可以让代码简洁清晰，但是递归也有其不够好的地方的。总所周知程序中函数的调用是要消耗系统内存的，在小范围小幅度的递归对程序不会有太大的影响，但是如果递归的深度太大，会使内存枯竭，程序崩溃。即：递归即有好处也有坏处 递归的优点： 代码简洁 递归的缺点： 过多递归会影响系统内存和程序运行效率 二叉树非递归的代码实现及思路正如上面所说，函数递归在遍历较小的二叉树是没有太大的问题的。但若遍历深度巨大的二叉树，使用递归来遍历是不太可行的。所以二叉树非递归的方式来实现遍历也理所当然的变的重要。 二叉树非递归遍历的实现思路：通过栈数据结构，进行入栈操作，先把树的每一个结点的左孩子入栈直至访问到叶结点，随后进行访问，访问一个出栈一个，并检测此时的右孩子是否为空，若不空，重复上述的操作即可。 代码实现: 123456789101112131415161718bool Mid_Traversal(BiTreeNode* Root)&#123; stack&lt;BiTreeNode*&gt; s; BiTreeNode* T = Root; do&#123; while(T)&#123; s.push(T); T = T-&gt;L_Node; &#125; T = s.top(); s.pop(); cout &lt;&lt; T-&gt;data &lt;&lt; " "; T = T-&gt;R_Node; &#125;while(!s.Empty()||T); return true;&#125; 实验结果: 函数流程演示 第一步：A结点不空进入循环，入栈。 | 栈顶 || :—: || A | 第二步：B结点入栈、第三次循环D结点入栈。 | 栈顶 || :—: || D || B || A | 第三步：跳出循环，T指针指向栈顶,访问栈顶数据，并出栈。 T：-&gt;D 输出了D | 栈顶 || :—: || B || A | 第四步：T重新指向此时指向结点的右孩子。第一次外循环结束。 T：-&gt;D.R_Node(nullptr) 第五步：开始第二次外循环，因为T为空内循环不执行、T指向栈顶，访问栈顶数据。 T：-&gt;B 输出了B | 栈顶 || :—: || A | 第六步：T指向了B结点的右孩子E，结束第二次外循环。 T：-&gt;E 第七步：此时T不空执行内循环，E入栈,,T指向E结点的左孩子,因为E结点的左孩子为空跳出循环。 | 栈顶 || :—: || E || A | 第八步：T指向栈顶，访问栈顶数据，出栈。 T：-&gt;E 输出了E | 栈顶 || :—: || A | 第九步：T指向E结点的右孩子，因为为空所以结束第三次外循环。 T：-&gt;E.R_Node(nullptr) 第十步：因为此时T为空不执行内循环，T指向栈顶，访问栈顶数据，出栈。 T：-&gt;A 输出了A | 栈顶 || :—: || 空 | 第十一步：T指向A结点的右孩子C，因为是空栈，所以也结束第四次外循环，重新开始下一轮循环。 T：-&gt;C 第十二步：T不为空，指向内循环，入栈，更新T指向C的左孩子，为空结束内循环。 | 栈顶 || :—: || C | 第十三步：T指向栈顶，访问栈顶，出栈 T：-&gt;C 输出了C | 栈顶 || :—: || 空 | 第十四步：T指向C结点的右孩子，但为空，且栈也为空栈，跳出外循环。结束遍历操作。 结果输出：D、B、E、A、C —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.8）哈夫曼树概念及定义]]></title>
    <url>%2F2019%2F07%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-8%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[哈夫曼树概念给定n个权作为n个结点，构造一颗二叉树，若树的带权路径长度(WPL)最短，就称其为哈夫曼树也称其为最优二叉树。 相关术语及概念解释 路径和路径长度：从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数量称为路径长度。 树的路径长度：就是树根到每一个结点的路径长度之和 带权路径长度：从根结点到该结点之间的路径长度与权的乘积 树的带权路径长度：就是树的每一个结点路径长度乘以权值之和 其中树的带权路径长度(WPL)若为最小，那么就称这个数为哈夫曼树 哈夫曼树的应用 场景设置 假设要对一个班级里的50位同学进行评分，其中人员分数分配如下 | | 优秀 | 良好 | 中等 | 及格 | 不及格 || ——- | ——- | ———— | ———— | ———— | ——— || 分值a | a&gt;=90 | 80&lt;=a&lt;90 | 70&lt;=a&lt;80 | 60&lt;=a&lt;70 | a&lt;60 || 人数 | 8 | 21 | 12 | 7 | 2 | 并把他们用下面的二叉树进行统计分类 会发现 要想把所有人进行统计完毕一共需要判断 2*1 + 2*7 + 3*12 + 4*21 + 4*8 = 168次。 如果把上面的树进行变换变为如下的二叉树 一共需要判断3*2 + 7*3 + 12*2 + 21*2 + 2*8 = 109次相比前面的二叉树发现判断的次数变少了，说明用第二种二叉树进行判断分类效率更高。 从上面可以发现，判断次数的计算类似于树的带权距离计算。所以只要保证其树的带权距离最短那么效率就会越高。 哈夫曼树的生成就以上面的的例子创建哈夫曼树 第一步：对人数进行排序(也就是对权值进行排序)从大到小的顺序分别是 | 良好 | 中等 | 优秀 | 及格 | 不及格 || —— | —— | —— | —— | ——— || 21 | 12 | 8 | 7 | 2 | 第二步：取最小的两个作为左右结点(习惯性左节点小于右节点)并让其和称为其根结点 即： 第三步：将其和加入原来的从大到小排列的顺序中替代最小的两个，重新排序 | 良好 | 中等 | 及格/不及格 | 优秀 || —— | —— | —————- | —— || 21 | 12 | 9 | 8 | 第四步：取最小的两个重复第二步操作 第五步：把左右子树的和代替原来的优秀和及格/不及格，重新排序 | 良好 | 优秀、及格/不及格 | 中等 || —— | ————————- | —— || 21 | 17 | 12 | 第六步，重复第四步操作 第七步：继续替换并重新排序 | 良好 | 优秀、及格/不及格、中等 || —— | ———————————- || 21 | 29 | 第八步：重复第四步 完成哈夫曼树 根据上图可知：要完全判断分类，需要判断21*1 + 12*2 + 8*3 + 2*4 + 7*4 = 105次比一开始109更有效率，这就哈夫曼树也称最优二叉树的创建。 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（2.6）RTTI运行时类型检测]]></title>
    <url>%2F2019%2F07%2F22%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-6%EF%BC%89RTTI%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[RTTI是什么RTTI(Run Time Type Identification)运行时类型识别，它能使程序在运行时推断出基类指针或引用实际指向的内存地址是基类还是某个派生类。 C++中RTTI提供了两个操作符 dynamic_cast typeid RTTI使用的必要条件:基类一定要包含虚函数，因为在没有虚函数的时候，类就不会创建虚函数表，导致在运行时检查的时候会获取静态的类型。即只会获得指针定义的类型而不是它指向的实际类型。 dynamic_cast运算符 作用：能将基类的指针或者引用安全地转换为派生类的指针或引用。 代码定义：dynamic_cast&lt;目标类型&gt;(目标数据) 指针转换 如果转换成功：结果会返回一个正确的指针 如果转换失败：会返回一个空指针 代码演示： 1234567891011121314151617181920212223242526272829303132class person&#123; virtual void work()&#123; cout &lt;&lt; "人们在工作" &lt;&lt; endl; &#125;&#125;;class teacher:public person&#123; void work()&#123; cout &lt;&lt; "老师在讲课" &lt;&lt; endl; &#125;&#125;;class student:public person&#123; void work()&#123; cout &lt;&lt; "学生在学习" &lt;&lt; endl; &#125;&#125;;int main()&#123; person* p1 = new teacher; person* p2 = new student; student* s1 = new student; student* s2 = dynamic_cast&lt;student* &gt;(p2);//把基类指针安全的转换为子类指针 s2-&gt;work(); teacher* t1 = dynamic_cast&lt;teacher*&gt;(p2);//转化失败返回的是空指针 if (t1 == nullptr) &#123; cout &lt;&lt; "t1是空指针" &lt;&lt; endl; &#125;&#125; 实验结果: 结论：从实例可以发现，dynamic_cast的使条件是基类含有虚函数的，且如果转换失败那么会获得一个空指针，转换成功会获得正确的指针。 如果基类中不含有虚函数那么会出错 引用转换 注意：与指针不同的是如果引用用dynamic_cast进行转换并且转换失败会抛出一个std::bad_cast异常(因为不存在空引用所以会抛出异常)可以用try catch语句进行捕获。 代码演示： 12345678910111213141516int main()&#123; person* p1 = new teacher; person* p2 = new student; person&amp; p3 = *p1; teacher&amp; t2 = dynamic_cast&lt;teacher&amp;&gt;(p3); t2.work(); try&#123; student&amp; s3 = dynamic_cast&lt;student&amp;&gt;(p3); cout &lt;&lt; "没出异常！" &lt;&lt; endl; &#125;catch(std::bad_cast)&#123; cout &lt;&lt; "出异常了！！" &lt;&lt; endl; &#125; &#125; 实验结果: typeid运算符 作用：返回指针或者引用所指向对象地址的实际类型，实际上该函数会返回一个type_info类对象。 代码定义：typeid(表达式) 代码演示: 12345678910111213141516171819202122232425class person&#123; virtual void work()&#123; cout &lt;&lt; "人们在工作" &lt;&lt; endl; &#125;&#125;;class teacher:public person&#123; void work()&#123; cout &lt;&lt; "老师在讲课" &lt;&lt; endl; &#125;&#125;;class student:public person&#123; void work()&#123; cout &lt;&lt; "学生在学习" &lt;&lt; endl; &#125;&#125;;int main()&#123; person* p1 = new teacher; person* p2 = new student; cout &lt;&lt; typeid(p1).name() &lt;&lt; endl; cout &lt;&lt; typeid(p2).name() &lt;&lt; endl;&#125; 实验结果: 发现问题:咦？为什么返回的是class person*？，答案很明显：因为p1和p2的实际类型就是person*如果: 1234567int main()&#123; person* p1 = new teacher; person* p2 = new student; cout &lt;&lt; typeid(*p1).name() &lt;&lt; endl; cout &lt;&lt; typeid(*p2).name() &lt;&lt; endl;&#125; 实验结果: 因为*p1和*p2的实际类型才是teacher和student 从上面可以发现：typeid主要目的是为了比较两个指针是否指向同一种类型的对象 例如： 1234567891011121314int main()&#123; person* p1 = new teacher; person* p2 = new student; if(typeid(p1) == typeid(p2))&#123; cout &lt;&lt; "p1和p2类型相同" &lt;&lt; endl; &#125; if(typeid(*p1) == typeid(*p2))&#123; cout &lt;&lt; "*p1和*p2类型相同" &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; "*p1和*p2类型不相同" &lt;&lt; endl; &#125;&#125; 实验结果: 补充：typeid的实质12345int main()&#123; cout &lt;&lt; typeid("ShuHao").name() &lt;&lt; endl; cout &lt;&lt; typeid(100).name() &lt;&lt; endl; cout &lt;&lt; typeid(12.345).name() &lt;&lt; endl;&#125; 实验结果: 没有虚函数的情况：1234567891011121314int main()&#123; person* p1 = new teacher; person* p2 = new student; if(typeid(p1) == typeid(p2))&#123; cout &lt;&lt; "p1和p2类型相同" &lt;&lt; endl; &#125; if(typeid(*p1) == typeid(*p2))&#123; cout &lt;&lt; "*p1和*p2类型相同" &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; "*p1和*p2类型不相同" &lt;&lt; endl; &#125;&#125; 实验结果: 可以发现 *p1和*p2此时在没有虚函数的情况下类型也相同了。原因很明显：因为没有虚函数表，会默认认为是定义时的类型也就是person* 结论：要使RTTI机制能正常的使用，基类一定要含有虚函数。 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-(2.5)友元函数、友元类]]></title>
    <url>%2F2019%2F07%2F21%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2-5-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E3%80%81%E5%8F%8B%E5%85%83%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[友元函数何为友元，众所周知一个类中private里的内容是不允许除本类的其他地方进行访问的，protected类的数据也只能由其子类去访问，而友元函数的特点就是，对一个类中的private和protected都可以进行调用和访问。 12345678910class A &#123;private: int data; &#125;;void fun1(A&amp; t) &#123; t.data = 10;//报错，不能访问private成员 &#125; 实验结果: 从上面可以发现，在正常的情况下，外面的函数是不可以访问私有成员的，但如果是友元函数便可以访问 友元函数声明： 在类中： friend 返回值类型 函数名(参数)； 1234567891011121314151617class A &#123;private: int data; friend void fun1(A&amp; t); &#125;;void fun1(A&amp; t) &#123; t.data = 10; cout &lt;&lt; "类A中的私有成员data的值为 " &lt;&lt; t.data &lt;&lt; endl; &#125;int main() &#123; A a; fun1(a);&#125; 实验结果: 友元类正如友元函数一样，友元类是可以访问朋友类中的所有成员和函数 123456789101112131415161718class A &#123;private: int data; friend void fun1(A&amp; t); friend class C;//把类C定义为A的友元类&#125;;void fun1(A&amp; t) &#123; t.data = 10; cout &lt;&lt; "类A中的私有成员data的值为 " &lt;&lt; t.data &lt;&lt; endl; &#125;class C&#123; public: void GetClassA_data(A a)&#123; cout &lt;&lt; a.data &lt;&lt; endl; &#125;//可访问A的所有成员&#125;; 实验结果: 友元成员函数定义友元类，则可以对其所有成员进行访问，在某些时候是不安全且没有必要的，所有就引入了友元成员函数，只允许外类访问其的若干个公有的成员函数。 1234567891011121314151617181920212223242526272829303132class A;class C &#123;public: void GetClassA_data(A a);//将要调用A中的私有成员，所以要设置为友元函数 void SetClassA_data(int x, A&amp; a);//没有设置为友元函数不能调用类A中私有成员 &#125;;class A &#123;private: int data = 10;public: friend void C::GetClassA_data(A a);//把C中的GetClassA_data函数设置为友元函数，使其 能调用私有成员&#125;;void C::GetClassA_data(A a) &#123;//C中的成员函数，因为是类A的友元函数可以调用其私有成员 cout &lt;&lt; a.data &lt;&lt; endl;&#125;void C::SetClassA_data(int x, A&amp; a) &#123; //a.data = x;&#125;int main() &#123; A a; C c; cout &lt;&lt; "A中的私有数据data的值为： "; c.GetClassA_data(a);&#125; 实验结果： 但如果没有把成员函数设置为友元函数，则一样不能调用其私有成员。 其次，如果某类中的成员函数是另一个类的友元成员函数，那么该函数一定要是公有的(因为另一个类才能访问该函数并把该函数设置为本类的友元函数) 总结及友元的注意事项： 注意事项： 友元函数是单向的 A是B的友元，所以可以调用B中的所有成员数据，但B不能调用A中的所有数据。 友元函数没有传递性 A是B的友元，B是C的友元，不代表A是C的友元 总结： 友元函数的优缺点很明显： 优点：只要定义了非本类的函数为友元函数，那么该函数可以调用该类所有成员数据、成员函数 缺点：破坏了封装性，降低了类的可靠性和可维护性。]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.7）二叉树遍历的衍生运用]]></title>
    <url>%2F2019%2F07%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-7%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84%E8%A1%8D%E7%94%9F%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[二叉树遍历的衍生运用例图： 递归求树的深度/高度 代码实现: 12345678int GetTreeDepth(BiTreeNode* T)&#123; if(!T)return 0;//递归出口 int l = GetTreeDepth(T-&gt;L_Node); int r = GetTreeDepth(T-&gt;R_Node); return (l &gt; r) ? (l + 1) : (r + 1);&#125; 实验结果: 实现思路: 根据树的深度的概念—树中结点的最大层次或结点的最大深度，结点的深度又为结点的祖先个数+1，所以可以通过递归，从根结点开始往左右子树进行递归操作，当左右子树某一边的深度大于另一边的时候，返回最大的另一边的深度 + 1即可。 递归求得树的总结点个数 代码实现： 12345678int AllNodeCount(BiTreeNode* T)&#123; if(!T)return 0;//递归出口 int l = AllNodeCount(T-&gt;L_Node); int r = AllNodeCount(T-&gt;R_Node); return (l + r + 1);&#125; 实验结果： 实现思路：进行递归只要某个结点不为空就返回 1，通过递归进行累加，最终根结点会得到所有子树结点数量累加值。 —（本文未完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.6）树的广度优先遍历算法]]></title>
    <url>%2F2019%2F07%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-6%EF%BC%89%E6%A0%91%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[广度优先遍历二叉树 又名：层次遍历 正如名字所描述，该遍历二叉树的方式是以层进行的，期间运用的队列的知识，通过先进先出的原理。 如上图所示：整体思路是先让根结点进队并输出其数据并出队，然后让其左子树再进队，右子树再进队，通过循环重复上述过程 具体代码： 123456789101112void Traversal(BiTreeNode* R)&#123; queue&lt;BiTreeNode*&gt; Q; Q.push(R); while(!Q.empty())&#123; BiTreeNode* T = Q.front(); cout &lt;&lt; T-&gt;data &lt;&lt; " "; Q.pop(); if (T-&gt;L_Node)Q.push(T-&gt;L_Node); if (T-&gt;R_Node)Q.push(T-&gt;R_Node); &#125;&#125; 实验结果:]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（2.4）虚函数、纯虚函数、override/final、虚析构函数]]></title>
    <url>%2F2019%2F07%2F19%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-4%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81override-final%E3%80%81%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[虚函数与纯虚函数虚函数 虚函数关键字：virtual 情形： 1234567891011121314151617181920212223242526class person&#123; public: void work()&#123; cout &lt;&lt; "人们在工作" &lt;&lt; endl; &#125;&#125;;class student:public person&#123; public: void work()&#123; cout &lt;&lt; "学生在学习" &lt;&lt; endl; &#125;&#125;;class teacher:public person&#123; public: void work()&#123; cout &lt;&lt; "老师在教学" &lt;&lt; endl; &#125;&#125;;int main()&#123; person* p = new teacher; p-&gt;work();&#125; 实验结果： 发现问题：按照逻辑一个父类指针里面存储的子类对象的地址，调用同名的work()函数应该是要调用子类的函数，但结果却是调用了父类的构造函数。 解决：根据上面所述，如果这样的话父类指针可以承载子类对象的地址的作用就没有意义了，有没有可以让父类指针根据其承载的对象地址来决定调用具体哪一个同名函数呢？答案是有的，那就是虚函数，在父类中把要定义成虚函数的成员函数声明前加virtual关键字即可使其成为虚函数。 12345678910111213141516171819202122232425262728293031class person&#123; public: virtual void work()&#123; cout &lt;&lt; "人们在工作" &lt;&lt; endl; &#125;&#125;;class student:public person&#123; public: void work()&#123; cout &lt;&lt; "学生在学习" &lt;&lt; endl; &#125;&#125;;class teacher:public person&#123; public: void work()&#123; cout &lt;&lt; "老师在教学" &lt;&lt; endl; &#125;&#125;;int main()&#123; teacher* t = new teacher; person* p = new person; student* s = new student person* ps[3]&#123;t,p,s&#125;; for(int i = 0; i &lt; 3; i++)&#123; ps[i]-&gt;work(); &#125;&#125; 在基类中把work函数设定为虚函数后，后面用父类指针类型调用该函数时会动态的绑定对象即在程序运行时会根据该指针所指向对象的类型来决定调用函数。 实验结果： 注意：当父类中的某一个函数定义为虚函数的时候，继承与其的子类的同名同参函数将默认都为虚函数，也就是说子类中的该函数前加virtual和不加都没有影响 纯虚函数 代码定义： virtual 返回值类型 函数名(参数) = 0； virtual void fun1() = 0; 注意点： ①当一个基类中含有纯虚函数时，该类被称为抽象类，不能实例化对象。 ②当一个子类继承与一个抽象类时，该子类一定要重写该抽象类的纯虚函数 override/final 关键字在C++11后引入了override和final关键字，其中override关键字的作用跟Java里的一样，就是标识出该函数是重写父类的同名函数的方便检查和辨识。而final关键字就是标识出该函数不能被重写。 代码定义：返回值类型 函数名(参数) override/final{} void fun1()override{} int fun2()final{} override 具体例子： 1234567891011121314class person &#123;public: virtual void work() &#123; cout &lt;&lt; "人们在工作" &lt;&lt; endl; &#125;&#125;;class teacher :public person &#123;public: void work(int a)override&#123;//报错：因为override关键字自动检查，重写函数错误 cout &lt;&lt; "老师在教学" &lt;&lt; endl; &#125;&#125;; final 具体例子: 1234567891011121314class person &#123;public: virtual void work() final&#123; cout &lt;&lt; "人们在工作" &lt;&lt; endl; &#125;&#125;;class teacher :public person &#123;public: void work()&#123;//报错：不能重写final关键字修饰的函数 cout &lt;&lt; "老师在教学" &lt;&lt; endl; &#125;&#125;; 虚析构函数顾名思义就是定义为虚函数的析构函数。存在继承关系的父类中的析构函数一定要定义为虚函数。为什么？让我们慢慢道来 1234567891011121314151617181920212223242526class person &#123;public: person() &#123; cout &lt;&lt; "调用了父类person的构造函数person()" &lt;&lt; endl; &#125; ~person() &#123; cout &lt;&lt; "调用了父类person的析构函数~person()" &lt;&lt; endl; &#125;&#125;;class student :public person &#123;public: student() &#123; cout &lt;&lt; "调用了子类student的构造函数student()" &lt;&lt; endl; &#125; ~student() &#123; cout &lt;&lt; "调用了子类student的析构函数~student()" &lt;&lt; endl; &#125;&#125;;int main() &#123; student s;&#125; 实验结果： 从上面可以看出，当在栈区定义子类对象，其父类和子类构造函数和析构函数都被正常的调用，但是当用父类类型的指针来存储子类对象的地址，释放空间时会发现： 1234int main()&#123; person* p_s = new student; delete p_s&#125; 实验结果： 发现问题：子类的析构函数没有被调用！这意味着子类内存地址还没有正确地被释放，这样必然会引起重大的隐患。 为什么会出现这个问题？如何解决：要解决上述的问题只需把父类的析构函数定义为虚函数，为什么这样做？正如前面介绍虚函数一样，只有虚函数才能在程序运行时动态绑定识别对象。定义为虚函数，系统会根据父类指针实际指向的地址来调用对应的函数，析构函数也是一样。所以为了避免这种隐患的出现，存在继承关系的父类的析构函数一定要定义为虚函数。 解决： —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.5）二叉树的链式实现与二叉树的先、中、后序遍历]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-5%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E3%80%81%E4%B8%AD%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树的链式实现创建链表二叉树 二叉树的链表实现有两种情况 二叉链表：一个结点带有指向左右子树的指针和一个数据 三叉链表：除了带有分别指向左右子树的两个指针外还有一个指向双亲结点的指针 现以二叉链表为例创建一个二叉树 1234567891011121314struct BiTreeNode&#123; char data; BiTreeNode* L_Node = nullptr;//指向左子树的指针 BiTreeNode* R_Node = nullptr;//指向右子树的指针&#125;int main()&#123; BiTreeNode* T = new BiTreeNode(); T-&gt;data = 'A'; T-&gt;L_Node = new BiTreeNode(); T-&gt;L_Node-&gt;data = 'B'; T-&gt;R_Node = new BiTreeNode(); T-&gt;R_Node-&gt;data = 'C'; BiTreeNode* p = T-&gt;L_Node; p-&gt;L_Node = new BiTreeNode(); p-&gt;L_Node-&gt;data = 'D'; p-&gt;R_Node = new BiTreeNode(); p-&gt;R_Node-&gt;data = 'E';&#125; 二叉树的遍历 遍历对于二叉树来说是非常重要的。遍历是数结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 二叉树的遍历分为三种 前序遍历(根-左子树-右子树) 中序遍历(左子树-根-右子树) 后序遍历(左子树-右子树-根) 前序遍历 前序遍历就是先从根开始然后递归左子树再递归右子树。 例如： 遍历的结果为： A、B、D、E、C 代码实现： 1234567void Pre_Traversal(BiTreeNode* T)&#123; if(!T)return;//如果T为空那么就结束 cout &lt;&lt; T-&gt;data;//先从根开始 Pre_Traversal(T-&gt;L_Node);//递归遍历左子树 Pre_Traversal(T-&gt;R_Node);//递归遍历右子树&#125; 实验结果： 具体递归实现解释： 中序遍历 中序遍历就是先递归左子树开始然后再到根再递归右子树。 例如： 遍历的结果为： D、B、E、A、C 代码实现： 1234567void Mid_Traversal(BiTreeNode* T)&#123; if(!T)return;//如果T为空那么就结束 Mid_Traversal(T-&gt;L_Node);//递归遍历左子树 cout &lt;&lt; T-&gt;data; Mid_Traversal(T-&gt;R_Node);//递归遍历右子树&#125; 实验结果： 后序遍历 例如： 遍历的结果为： D、E、B、C、A 代码实现： 12345678void Post_Traversal(BiTreeNode* T)&#123; if(!T)return;//如果T为空那么就结束 Post_Traversal(T-&gt;L_Node);//递归遍历左子树 Post_Traversal(T-&gt;R_Node);//递归遍历右子树 cout &lt;&lt; T-&gt;data; &#125; 实验结果： 具体文字解释： ①先从Post_Traversal(T(A))开始进入函数执行Post_Traversal(T(A)-&gt;L_Node(B)) ②在Post_Traversal(T(B))中又先执行执行Post_Traversal(T(B)-&gt;L_Node(D)) ③在执行Post_Traversal(T(D))的时候因为执行D结点中的Post_Traversal(T(D)-&gt;L_Node)为空结束递归，执行下一句Post_Traversal(T(D)-&gt;R_Node)也为空结束递归，执行cout &lt;&lt; ‘D’;到这里Post_Traversal(T(D))函数执行完毕，继续执行B结点中的Post_Traversal(T(B)-&gt;R_Node(E)) ④在执行Post_Traversal(T(E))的时候发现E的左右子树都为空，那么就只执行了cout &lt;&lt; ‘E’;返回B结点执行下一句cout &lt;&lt; ‘B’;至此Post_Traversal(T(A)-&gt;L_Node(B))已经执行完毕返回至A结点 ⑤执行A结点中的Post_Traversal(T(A)-&gt;R_Node(C))也就是执行Post_Traversal(T(C))发现C结点的左右子树也为空，那么只执行了C结点中的cout &lt;&lt; ‘C’;返回A结点的函数，到这里A结点的Post_Traversal(T(A)-&gt;R_Node(C))执行完毕，再执行下一句cout &lt;&lt; ‘A’; ⑥当cout &lt;&lt; ‘A’;执行完毕后Post_Traversal(T(A))函数结束。屏幕上输出DEBCA —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.4）二叉树的顺序储存结构]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-4%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[二叉树的抽象数据结构 ADT BinaryTree Data D是具有相同特征的数据元素的集合 Relative 若D = ∅，则R = ∅； 若D ≠ ∅，则R = {H}； root唯一 Dj∩Dk = ∅ ….. Operation createBiTree(&amp;T , defination) //构建二叉树 ……. endADT]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（2.3）拷贝构造函数、继承与访问等级、函数遮蔽]]></title>
    <url>%2F2019%2F07%2F18%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-3%EF%BC%89%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%AE%BF%E9%97%AE%E7%AD%89%E7%BA%A7%E3%80%81%E5%87%BD%E6%95%B0%E9%81%AE%E8%94%BD%2F</url>
    <content type="text"><![CDATA[拷贝构造函数拷贝构造函数是什么？ 拷贝构造函数是一个特殊的构造函数。与普通构造函数不同的是，当对象执行拷贝的时候将会自动调用拷贝构造函数。 12345678910111213class student&#123; public: student()&#123; cout &lt;&lt; " 这是student()构造函数" &lt;&lt; endl; &#125;&#125;;int main()&#123; student s1;//调用student()构造函数 student s2;//调用student()构造函数 student s3 = s2;//没有调用student()构造函数 &#125; 实验结果： 为什么s3对象被创建的时候没有调用无参的构造函数呢？原因就是s3执行了拷贝操作，调用的是默认的拷贝构造函数。 拷贝构造函数 拷贝构造函数与构造函数一样，当没有自己定义的拷贝构造函数的时候，会像构造函数一样系统自动生成一个空函数体的默认拷贝构造函数。 拷贝构造函数的形参中包含一个该类对象的引用(通常是const 修饰) student(const student&amp; T); 12345678910111213141516171819class student&#123; public: /*普通构造函数*/ student()&#123; cout &lt;&lt; " 这是student()构造函数" &lt;&lt; endl; &#125; /*拷贝构造函数*/ student(const student&amp; T)&#123; cout &lt;&lt; " 这是student()拷贝构造函数" &lt;&lt; endl; &#125;&#125;;int main()&#123; student s1;//调用student()构造函数 student s2;//调用student()构造函数 student s3 = s2;//没有调用student()构造函数 &#125; 实验结果: 继承与访问等级 三种访问权限 public：可以被任意实体所访问 protected：只允许本类或者子类的成员函数来访问 private：只允许本类的成员函数访问 三种继承访问 public、protected、private | 基类中的访问权限 | 子类继承基类的继承方式 | 子类得到的访问权限 || ———————— | ——————————— | ————————— || public | public | public || protected | public | protected || private | public | 子类无访问权限 || | | || public | protected | protected || protected | protected | protected || private | protected | 子类无访问权限 || | | || public | private | private || protected | private | private || private | private | 子类无访问权限 | 总结： 子类public继承父类不改变父类的访问权限 protected继承将父类中public成员变为子类的protected成员 private继承使得父类所有成员在子类中的访问权限变为private 父类中的private成员不受继承方式的影响，子类(其他类)永远无权访问 对于父类来讲，尤其是父类的成员函数，如果你不想让外边访问，就设置为private，如果想让子类访问则设置为protected，想公开就设置为public 函数遮蔽 当出现父类中与子类中都含有同名的函数时会出现函数遮蔽现象，即子类调用该函数时，父类的重载函数将不可见 123456789101112131415161718192021222324252627282930class student &#123;public: void fun1(int i) &#123; cout &lt;&lt; "这是父类的fun1(int i)" &lt;&lt; endl; &#125; void fun1(int i,int k) &#123; cout &lt;&lt; "这是父类的fun1(int i,int k)" &lt;&lt; endl; &#125;&#125;;class person:public student&#123;public: void fun1(int i) &#123; cout &lt;&lt; "这是子类的fun1(int i)" &lt;&lt; endl; &#125;&#125;;int main()&#123; person p1; p1.fun1(1); p1.fun(2,1)//报错&#125; 实验结果： 如何解决函数遮蔽？ 用域运算符 父类名：：函数名 12345int main()&#123; person p1; p1.student::fun1(1); p1.student::fun1(1，2);&#125; 实验结果： 用using关键字(C++11) 子类中成员函数中加using 父类名：：函数名 123456789101112131415161718class person:public student&#123;public: void fun1(int i) &#123; cout &lt;&lt; "这是子类的fun1(int i)" &lt;&lt; endl; &#125; using student::fun1;&#125;;int main()&#123; person p1; p1.fun1(1); p1.fun1(1，2);&#125; 实验结果： 可以发现此时父类的重载函数也可以使用了，但是单参的fun1()函数将被子类的遮蔽。 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.3）二叉树的性质及推导]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-3%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%E5%8F%8A%E6%8E%A8%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[二叉树的性质性质1：(层级):pencil: 在二叉树的第i层上至多有2i-1个结点。 即：下层的结点最多是上层结点的2倍 性质2：(深度):pencil: 深度为k的二叉树至多有2k-1个结点。 性质3:pencil:： 对于任何一颗二叉树，若2度的结点数有n2个，则叶子结点n0的个数比为n2+1 | 符号 | 解释 || ——————- | ————————————- || n0 | 度数为0的结点数(叶结点数) || n | 总结点数 || n1 | 度数为1的结点数 || n2 | 度数为2的结点数 || B | 分枝数 | n0 = n2+1 其他公式:mag_right:： 分枝数(B)： B = n1+2n2 B = n - 1(n为总结点数)B 推导过程（n0 = n2+1）:scroll:： 因为 B = n -1① 且 n = n0 + n1 + n2② 所以B = n0 + n1 + n2 - 1 ③所以 n0 = B - n1 - n2 + 1④ 又因为B = n1+2n2 代入④ n0 = n1 + 2n2 - n1 - n2 + 1 得n0 = n2+1 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.2）二叉树]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-2%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树(Binary Tree) 二叉树是一个连通的无环图，并且每一个顶点的度不大于3。有根二叉树还要满足根结点的度不大于2。 只有一个称为根的结点 除根外，其余结点分为不相交的子集T1和T2，分别称为T的左子树和右子树，且T1和T2本身又都是二叉树 二叉树与树： | 二叉树 | 树 || ——————————————————— | ——————————— || 至多只有两个子树 | 没有限制子树的个数上限 || 子树有左右之分，其次序不能颠倒(有序树) | 子树可有序也可以无序 || 具有递归性质 | 具有递归性质 | 二叉树的五中基本形态 空树 只有一个根结点的二叉树 只有左子树 只有右子树 完全二叉树 二叉树的优点 普通树相比二叉树代码很难实现 二叉树结构简单，规律性强 所有树都可以转为唯一对应的二叉树 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（5.1）树的定义及概念]]></title>
    <url>%2F2019%2F07%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%885-1%EF%BC%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[树概念及定义 树是一个有层级结构的数据结构 定义：树是有n（n&gt;=0）个结点组成的有限集合 如果n = 0 ，称为空树 如果n &gt; 0, 则： 有一个特点的称之为为根(root)的结点，它只有直接后继，没有直接前驱。 除根以外的其他结点划分为m(m &gt;= 0)个互不相交的有限集合，T0、T1、…、Tm-1，每个集合又是一颗树，称为根的子树。和根有直接关系的结点分别是这些子树的根。 特点：每个结点有零个或多个子结点；没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除了根结点外，每个子结点可以分为多个不相交的子树。 树结构与线性结构 线性结构：一对一 树结构：一对多 线性结构 树结构 第一个元素(无前驱) 根结点(无前驱) 最后一个元素(无后继) 多个叶子结点(无后继) 其他数据元素(一个前驱、一个后继) 树中的其他结点(一个前驱、多个后继) 树结构的一些术语 根：唯一没有双亲的结点，其他结点都有唯一的双亲 结点的度：一个结点含有的子树的个数称为该结点的度 树的度：树结构中，最大的结点的度称为树的度 分支结点：度数不为0的结点 叶结点：度数为0的结点 孩子结点/子结点：某个结点的子树的根 双亲结点/父节点：若一个结点含有子结点，则这个结点称为其子结点的父结点 兄弟结点：同一个双亲结点的孩子结点之间互为兄弟结点 结点的祖先：从根到该节点所经分支上的所有节点 子孙：以某节点为根的子树中任一节点都称为该节点的子孙 森林：多个数的集合 子树森林：一个结点的所有子树构成的森林 结点的深度：结点的祖先个数+1 结点的高度：从结点到其子树叶结点经过的最大边数+1，叶结点的高度为1 结点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推 树的高度：高度最大的结点的高度 树的深度：树中结点的最大层次或结点的最大深度 堂兄弟结点：双亲在同一层的节点互为堂兄弟 有序树：每个结点的子树有次序之分 无序树：每个结点的子树没有次序之分 树的类型树的抽象数据类型 ADT Tree DATA 父子关系 Operator Tree() //初始化 Tree(definition) //从输入definition中创建树 Tree(const Tree &amp; T) //复制树 Node root() // 返回根结点 int depth() //获得树的高度 int size() //获得树的结点个数 Node parent(Node p) //获得结点p的双亲 Node[] children(p) //返回结点P的所有孩子 Node[] silbings(parent , p) //返回结点p的所有兄弟 Node find() //查找结点 …… endADT —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（4.4.2）查询子串位置二-KMP算法[难点]]]></title>
    <url>%2F2019%2F07%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%884-4-2%EF%BC%89%E6%9F%A5%E8%AF%A2%E5%AD%90%E4%B8%B2%E4%BD%8D%E7%BD%AE%E4%BA%8C-KMP%E7%AE%97%E6%B3%95-%E9%9A%BE%E7%82%B9%2F</url>
    <content type="text"><![CDATA[简单(BF)算法的缺陷 简单算法的实现:pencil:：就让子串与主串进行一个个判断。 例如 “acdcda”中找“cda”那么有：①c先与主串中的‘a’比较不匹配 主串后移、②c与主串中的‘c‘匹配，子串后移让d与主串中的‘b’比较。不匹配主串后移、③c与主串中的‘d’比较，匹配子串后移、④a与主串中的‘c’比较，不匹配,主串后移、⑤c与主串中的‘d’不匹配，主串后移、⑥c与子串中的‘c’匹配,子串后移，d与主串的下一个‘d’匹配，子串再后移，a与主串中的下一个‘a’匹配。找到，返回主串中第二个‘c’的位置。 发现问题​:exclamation:：从上面可以看出，在③开始子串与已经比较过的主串字符又重新比较一次，从而大大的浪费了效率。 KMP算法 正如上面所说的，简单算法，因为在最差的情况下，会进行大量的无意义的比较匹配。而KMP算法的发明者们便想：能否更加比较不匹配所给出的信息，跳过无意义的比较呢？这就是KMP算法的核心。 —（本文未完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（4.4.1）查询子串位置算法一—简单算法]]></title>
    <url>%2F2019%2F07%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%884-4-1%EF%BC%89%E6%9F%A5%E8%AF%A2%E5%AD%90%E4%B8%B2%E4%BD%8D%E7%BD%AE%E7%AE%97%E6%B3%95%E4%B8%80%E2%80%94%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[简单(BF)算法的代码实现及思路 算法作用:mag:：查找在给定的子串在主串中的位置。例如：子串“llo”在主串“hello”的位置为3。 实现思路:bulb:：BF的算法的核心就是子串对主串逐一比较。所以只需用第一个循环来匹配子串的首字符与主串中的字符是否相等，如果相等那么在对子串后面的字符与此时主串的后面的字符进行比较。 例如：要在“AB CADB CADA BCA”中查找子串“ CADA”则从主串A中第一个开始查找，因为“A”与“ ”不匹配所以子串与主串的下一个字符比较，但也不同所以后移，当到了第三个的时候开始匹配，所以主串的第四个字符与子串第二个比较…主串第五个与子串第三个比较….。但到了主串的第七个字符与子串第4个字符不一样，所以匹配失败，主串后移一位又与子串的第一位开始比较。 具体实现:computer:: 123456789101112131415161718192021int find(String str) &#123; int j = 0; int k = 0; int n = 0; for (int i = 0; i &lt; size &amp;&amp; j &lt; str.size; i++) &#123; if (this-&gt;str[k] == str.str[j]) &#123; j++; k++; &#125; else &#123; j = 0; n++; k = n; &#125; &#125; if (j &lt;= str.size)return n; return -1; &#125; 实验结果:key:: 算法优化:wrench:： 12345678910111213141516int find(String ch)&#123; int i = 0; int j = 0; while(i &lt; size &amp;&amp; j &lt; ch.size)&#123; if(str[i] == ch.str[j])&#123; i++; j++; &#125;else&#123; i = i + 1 - j; j = 0; &#125; &#125; if(j &lt;= ch.size) return i - j; return -1; &#125; —（本文完）&lt;原创&gt; 子串对主串的逐一比较. 例如要在“AB CADB CADA BCA”中查找子串“ CADA”则从主串A中第一个开始查找，因为“A”与“ ”不匹配所以子串与主串的下一个字符比较，但也不同所以后移，当到了第三个的时候开始匹配，所以主串的第四个字符与子串第二个比较…主串第五个与子串第三个比较….。但到了主串的第七个字符与子串第4个字符不一样，所以匹配失败，主串后移一位又与子串的第一位开始比较。 &#8617;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（4.3）实现字符串结构、相关操作代码和实现思路]]></title>
    <url>%2F2019%2F07%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%884-3%EF%BC%89%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%93%E6%9E%84%E3%80%81%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E4%BB%A3%E7%A0%81%E5%92%8C%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[字符串结构的实现 具体代码:computer:： 12345678910111213141516class String&#123; char* str;//字符串 int size;//字符串长度 public: String(const char* ch)&#123; /*计算ch长度*/ char* temp = ch; while(*temp++ != '\0'); str = new char[temp - ch];//创建字符串 size = temp - ch - 1; for(int i = 0; i &lt;= size; i++)str[i] = ch[i]; &#125; .......&#125; 字符串是由字符数组来实现的,所以字符串的构造函数首先要根据const char* ch（传入的字符数组）求得其长度，然后创建足够大的空间，并对其逐一赋值即可完成String类型的创建。 相关简单操作的代码实现和实现思路 返回指定位置指定长度的子串 subString() 实现思路:exclamation:：根据用户输入指定的长度来创建足够大的空间的char* temp用来储存子串，然后用循环从指定位置开始对temp进行赋值，直到长度达到用户给定的长度即可。并在后面补上一个结束符(‘\0’),因为这是一个主串中的子串，后尾赋值的时候没有结束符。最后丢入String类型的构造函数中，释放temp的空间，返回新的字符串。 具体代码:computer:： 1234567891011121314String subString(int pos,int len)&#123; char* temp = new char[len+1]; for(int i = 0,k = pos; i &lt; len;i++,k++)&#123;//对子串进行逐一赋值 temp[i] = this-&gt;str[k]; &#125; temp[len] = '\0';//末尾补上结束符 String str(temp); delete[] temp;//释放堆空间 return str;//返回新的String&#125; 实验结果: 重载运算符+=使其实现字符串的拼接 实现思路:exclamation::拼接顾名思义，是把两个字符串连起来，所以定义一个new_size用来拼接后的字符串长度，只需分别求左右运算数的size相加即可。然后更加这个new_size长度定义一个新的字符串。之后先对左运算数，进行逐一赋值，然后在对右运算数进行赋值。即可完成拼接。 具体实现:computer:: 1234567891011121314String&amp; operator+= (const String&amp; str)&#123; int new_size = this-&gt;size + str.size; char* temp = new char[new_size+1];//最后需要一个结束符所以+1 if(!temp)return *this; int i = 0; while(i &lt; this-&gt;size)&#123;temp[i] = this-&gt;str[i]&#125;; for(int k = 0; k &lt;= str.size; k++,i++)&#123; temp[i] = str[k]; &#125; delete[]this-&gt;str; str = temp; size = new_size;&#125; 实验结果: 具体完成代码:scroll:： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;using namespace std;class String &#123;public: char* str; int size;public: /*构造函数*/ String(const char* str) &#123; const char* temp = str; while (*temp++ != '\0'); this-&gt;str = new char[temp - str]; if (!this-&gt;str)throw "内存分配失败"; size = temp - str - 1; for (int i = 0; i &lt;= size; i++)this-&gt;str[i] = str[i]; &#125; /*返回指定位置指定长度的子串*/ String subString(int pos, int len) &#123; if (pos &lt; 0 || pos &gt;= size)throw "指定位置超界"; if (pos + len &gt;= size)throw"待获取子串超界"; char* temp = new char[len + 1]; for (int i = 0, k = pos; i &lt;= len ; i++, k++) &#123; temp[i] = this-&gt;str[k]; &#125; temp[len] = '\0'; String str(temp); delete[]temp; return str; &#125; /*重载运算符+=*/ String&amp; operator+=(const String&amp; str) &#123; int new_size = this-&gt;size + str.size; char* temp = new char[new_size + 1]; if (!temp)return *this; int i = 0; while (i &lt; this-&gt;size) &#123; temp[i] = this-&gt;str[i]; i++; &#125; for (int k = 0; k &lt;= str.size; k++, i++) &#123; temp[i] = str.str[k]; &#125; delete[] this-&gt;str; this-&gt;str = temp; size = new_size; &#125; &#125;;int main() &#123; String str("hello world "); cout &lt;&lt; "原字符串为:" &lt;&lt; str.str &lt;&lt; endl; String str2 = str.subString(2, 3); cout &lt;&lt; "其位置2开始长度为3的字串为 : " &lt;&lt;str2.str &lt;&lt; endl; String str3("ShuHao"); str += str3; cout &lt;&lt; str.str &lt;&lt; endl;&#125; —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（2.2）类中的static函数/成员变量、类函数const后缀、mutable]]></title>
    <url>%2F2019%2F07%2F12%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-2%EF%BC%89%E7%B1%BB%E4%B8%AD%E7%9A%84static%E5%87%BD%E6%95%B0-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E7%B1%BB%E5%87%BD%E6%95%B0const%E5%90%8E%E7%BC%80%E3%80%81mutable%2F</url>
    <content type="text"><![CDATA[static关键字 静态关键字，无论是变量还是函数，只要加static关键字就会把其存储在静态常量区，与栈区堆区区分使用。静态，顾名思义就是不会动态变化的值。例如有一个静态变量，它会一直保持它原本的值，即便在某个函数段的生命期结束。 静态变量在普通函数 123456789101112int fun1(int a)&#123; static int b = 10;//静态变量，再重新进入函数体的时候会按照上次进入函数体的状态。 //即：静态变量只会初始化一次(默认初始化为0)。 cout &lt;&lt; "此时b的值为: " &lt;&lt; b &lt;&lt; endl; b+=a; return b;&#125;int main()&#123; cout &lt;&lt; fun1(1) &lt;&lt; endl; cout &lt;&lt; fun1(2) &lt;&lt; endl;&#125; 实验结果： 从上面的实验结果可以看出，静态变量在普通函数中只会初始化一次，假若没有给初始值，将默认初始化为0，因为静态变量是存储在静态常量区，所以即便过了在fun1函数的生命期，仍没有被回收，下次再次调用该函数时，静态变量会保存上次调用时的数据。 类中的静态变量 1234567891011//student.hclass student&#123; public： static int num;//声明 .... &#125;//student.cppint student::num = 10;//定义(定义时不需要再加static关键字) 类中的静态变量的特点： 它不是某个对象所拥有的，而是整个类拥有的，即每一个对象都共享该静态变量 在类中，静态变量只是声明因为还没有分配空间 只能在一个.cpp文件中定义并初始化类中的静态变量(分配内存)，否则会报变量重定义错误 在定义时不用再加static关键字 在定义时要用::(域运算符)标识是某个类中的变量，不然会当成普通变量定义 静态变量的体现： 12345678910student person1;person1.num = 11;cout &lt;&lt; "这是person1的num： "&lt;&lt; person1.num &lt;&lt; endl;student person2;person2.num = 12;cout &lt;&lt; "这是person2的num： "&lt;&lt; person2.num &lt;&lt; endl;cout &lt;&lt; "此时person1的num： " &lt;&lt; person1.num &lt;&lt; endl;cout &lt;&lt; "用类名来调用的num: " &lt;&lt; student::num &lt;&lt; endl; 实验结果: static成员函数 更静态变量一样，是属于类的，即调用时可以不用依靠对象来调用，直接类名::函数名来调用。 1234567891011121314151617//student.hclass student&#123; public： string name; static int num;//声明 static void setnum(int a); &#125;//student.cppint student::num = 10;//定义(定义时不需要再加static关键字)void student::setnum(int a)&#123; num = a;//修改静态变量 name = "xiaoming"//错误，因为name是属于对象的&#125; 值得注意的是，在静态函数中不能调修改非静态成员，因为非静态成员是每个对象各自有的，而不是共享的。 类中const函数后缀、mutableconst函数后缀 在类中，可以对成员函数后面添加const后缀 作用：告诫编译器，带后缀的成员函数不会修改成员变量。 具体代码: 1234567class student&#123; string name; public: void fun1() const&#123; name = "xiaoming";//报错：因为在const后缀中的函数中不允许修改成员变量 &#125;&#125; 编译后报错 : mutable mutable关键字的作用即是反制const后缀成员函数。 作用让某个成员变量可以在const后缀的成员函数中修改。 具体代码: 12345678class student&#123; mutable string name; public: void fun1() const&#123; name = "xiaoming";//编译通过 &#125;&#125; —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（4.2）实现字符串strlen和strcpy]]></title>
    <url>%2F2019%2F07%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%884-2%EF%BC%89%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2strlen%E5%92%8Cstrcpy%2F</url>
    <content type="text"><![CDATA[实现字符串中的简单操作一strlen() 作用：返回字符串的长度 实现思路：因为在c/c++中字符串是以char*指针来实现的，并且这些字符串中的末尾都有一个‘\0’结束符，所以在c/c++中可以利用指针和地址来求得字符串的长度，首先定义一个临时指针然后用待求字符串长度的字符串对其进行赋值，再用循环对这个临时指针进行自加移动，当判断在某个地址中的数据为‘\0’结束符的时候，再让其与原来的字符串相减，即可得到字符串的长度。 具体实现: 123456int strlen(const char* str)&#123; const char* temp = str; while(*temp != '\0')&#123;temp++;&#125; return temp - str;&#125; 实验结果: strcpy() 作用：进行字符串复制操作 实现思路：因为这个函数本身是实现复制操作，所以可以用原字符串对目标字符串进行逐一赋值即可实现。用一个临时指针存储目标字符串，然后用原字符串对这个临时指针进行逐一修改赋值，然后返回目标字符串即可。 具体实现: 123456char* strcpy(char* p,const char* s)&#123; char* temp = p; while((*temp++ = *s++) != 0); return p&#125; 实验结果: 错误记录：在编写strcpy()时，忘记了char*p是一个指针，结果直接运用循环对其进行自加移动赋值修改，然后再返回该指针。 错误代码: 12345char* strcpy(char* p , const char* s)&#123; while((*p++ = *s++) != 0); return p;&#125; 实验结果: 错误总结:上述错误代码中，因为p是一个指针，在循环的时候虽然是进行了逐一修改赋值，但指针也随之移动了，所以结果s不再是指向该字符串的首字符地址，而是指向了未知的末尾地址，从而造成指针p变成野指针。返回的结果也就想当然的是乱码了。 —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
        <tag>错误记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-(4.1)字符串]]></title>
    <url>%2F2019%2F07%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-4-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[(字符)串类型定义及概念串的一些概念 以(&quot;Hello world&quot;)为例 主串：即整个字符串被称为主串。 str = “Hello World”；str就是主串 子串：在主串中的一小段。(顺序相同) &quot;llo&quot;是主串“Hello World”的字串、“eH”不是该主串的字串(顺序错了) 位置：某个字符、或字符段的第一个字符位于主串的位置下标。 例如字串“llo”在主串&quot;Hello World&quot;的位置为3 串相等：当两个字符串之间，完全相同(长度相同，每个字符相同且位置相同)称为两个串相等 ”hello world“与“Hello World”不相等(字符不相等) 空串：串长度为为0的字符串被称为空串。 注意：空串与空格串不一样，空格串中的空格也算一个字符长度 串的抽象数据类型 ADT String Data：字符序列，以c/c++为例，char*类型数据，字符序列 Operation： bool init(T,char*) //初始化一个字符串 int find(S ,T) //查找字符串中是否存在字串 String strcat(T , S) //拼接字符串 String subStr(S,pos,size) //将s中的pos位置开始size长度的字串获取 bool inserStr(s,pos,T) //将T插入到s的pos位置 bool deleteStr(S,pos,size) //将S的pos位置开始的size长度的字串删除 bool copy(T,S) //将S拷贝给T int size() //获得字符串长度 void clear() //清空字符串 ……. endADT —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（2.1）类与构造函数]]></title>
    <url>%2F2019%2F07%2F08%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-1%EF%BC%89%E7%B1%BB%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[C++中的构造函数定义 在类中构造函数是在类对象创建时自动调用的，且不能主动调用构造函数，给类充当对其成员变量继续初始化的职能。 1234567891011121314151617class student&#123; int id; string name; public: student(); student(int i,string n);&#125;;student::student()&#123; cout &lt;&lt; "无参构造函数" &lt;&lt; endl;&#125;student::student(int i,string n)&#123; id = i; name = n; cout &lt;&lt; "带参构造函数 " &lt;&lt; endl;&#125; 构造函数的特点就是函数名没有返回值，函数名与类名相同，当没有定义构造函数的时候，系统会默认调用默认构造函数(函数体为空)。 在创建对象时如果是在栈区的定义方法如下： 1234567student person1(1000, "xiaoming");//最常用student person2;//调用无参构造方法student person3&#123;1021,"zhangsan"&#125;;//用大括号与小括号一样/*其余的定义方法(类堆区定义)*/student person4 = student(123, "lisi");student person5 = student(); 在创建对象的时候回调用相对应的有参或者无参的构造函数。 实验结果: 在创建对象时如果是在堆区的定义方法如下: 123student* person1 = new student(100,"xiaoming");student* person2 = new student();//student* person3 = new student;效果与person2的一样 堆区创建对象时应用指针来接收。 实验结果: 函数中的默认参数 默认参数在函数声明时就添加上。 给定默认参数的形参往右的形参都需要给与默认参数 void fun (int a , int b = 12, int c)错误 void fun (int a , int b = 12 , int c = 10)正确 含有默认参数的函数重构时需要注意参数识别混乱的问题 123456789101112int fun1(int a,int b,int c)&#123; return a+b+c;&#125;/*下方两个函数，在使用时会混乱*/int fun1(int a,int b,int c = 12)&#123; return a+b+c;&#125;int fun1(int a,int b)&#123; return a+b;&#125; 如上所示，第二个函数和第三个函数在使用时会混乱，因为你给定两个参数给函数fun1(1,2)时，不能识别你是要使用只有两个参数的函数(第三个函数),还是有默认值、三个参数的函数(第二个函数)。 类的隐式转换及explicit隐式转换 当类创建一个对象的时候若此类中有一个构造函数只含有一个参数，那么在对象创建的时候会发生隐式转换。隐式装换说白了就是没有显示表现类型转换，而是直接隐藏着进行类型转换。例如： 1234567891011121314class student&#123; int id; public: student(int i);&#125;;student::student(int i)&#123; id = i; cout &lt;&lt; "调用了student::student(int i)这个构造函数" &lt;&lt; endl; cout &lt;&lt; "id: " &lt;&lt; id;&#125;int main()&#123; student person = 100;//在没有重载运算符=的情况下，100被“赋值”给了student类的对象person&#125; 实验结果: 如上所示，本应该整型的100(int)在没有对其强制转换的情况下居然赋值给了一个student类对象，实质上这里发生了隐式转换，因为student类中含有一个只有一个参数的构造函数，当一个数字对其student类对象进行赋值的时候先调用了这个一个参数的构造函数，即先把整数转换成一个student对象再进行对象拷贝操作。 12345student person;int a = 100;person = a;/*实质上发生了如下的操作*/person = student(a);//把整型转换成对象再对其进行对象拷贝。 更奇妙的是，如果你以一个括号进行如上赋值，括号内的最后一个值将会隐式转换并调用student的单参构造函数。 123456789101112131415161718192021222324class student&#123; int id; public: student(); student(int i);&#125;;/*无参构造函数*/student::student() &#123; cout &lt;&lt; "无参构造函数" &lt;&lt; endl;&#125;/*带一个参数构造函数*/student::student(int i)&#123; id = i; cout &lt;&lt; "调用了student::student(int i)这个构造函数" &lt;&lt; endl; cout &lt;&lt; "id: " &lt;&lt; id;&#125;int main()&#123; student person; person = (100,200,300,400);//这样操作也会产生隐式转换的问题 //括号内最后一个数字(400)会进行隐式装换&#125; 实验结果: explicit关键字 为了解决上面的隐式转换的问题，可以在类中单参的构造函数声明前加explicit让其成为显示的构造函数。 12345678910111213141516171819202122class student&#123; int id; public: student(); explicit student(int i);//让隐藏的单参构造函数显现。&#125;;/*无参构造函数*/student::student() &#123; cout &lt;&lt; "无参构造函数" &lt;&lt; endl;&#125;/*带一个参数构造函数*/student::student(int i)&#123; id = i; cout &lt;&lt; "调用了student::student(int i)这个构造函数" &lt;&lt; endl; cout &lt;&lt; "id: " &lt;&lt; id;&#125;int main()&#123; student person = 100;//报错，无法找到匹配的构造函数&#125; 实验效果： 注意:只有单参构造函数的存在下才有如上所说的隐式转换的问题，所以explicit关键字只能作用于单参构造函数的声明上，在多参数构造函数声明加此关键字没有作用。 对于单参构造函数一般都需要加explicit关键字，除非某些极少例子允许隐式转换。 对应的如果要使其函数隐式调用可以加implicit 构造函数的初始化列表 先看下面一个例子 1234567891011class number&#123; int a; int b; int c; public: number(int n1,int n2,int n3);&#125;number::number(int n1,int n2,int n3):a(n1),b(n2),c(n3)&#123; &#125; 在构造函数定义后以一个冒号开头，后接成员变量+括号，括号里加要对成员变量初始化的原值，就被称为构造函数的初始化列表。 构造函数的初始化列表有以下特点 初始化列表中，成员变量的赋值是根据你定义成员变量的先后进行的。即可以不按顺序。例如： 上方先定义a,在定义b，其次是c，那么在初始化列表中对其进行初始化的时候，是先对a进行初始化其次是b，然后是c。 12345678910111213141516class number&#123; int a ; int b ; int c ; public: number(int n1,int n2,int n3);&#125;number::number(int n1,int n2,int n3):a(b),b(c),c(n3)&#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; endl;&#125;int main ()&#123; number n(100,200,300);&#125; 实验结果： 解释: 首先因为a先定义，所以先对a进行初始化，但此时b为-858993460，所以a被赋值为-858993460，其次是b，因为此时c也为-858993460，所以b也被赋值成-858993460，最后到c，成被传进的300赋值，所以现在c才为300，而前面对a,b赋值时c都还不是300。 为什么要用构造函数初始化列表来对成员变量进行赋值？ 如果是在构造函数中对成员变量赋值，那么这时程序干了两件事，首先对成员变量初始化，其次对其进行赋值操作。所以如果用初始化列表进行初始化，可以免除一步，从而提高程序效率。 高大上，帅，显得程序员专业。 —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（3.5）顺序存储结构队列]]></title>
    <url>%2F2019%2F07%2F06%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%883-5%EF%BC%89%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[顺序队列算法即实现思路顺序储存结构的队列定义(以char类型为例) 实现思路：因为顺序队列是要基于数组来实现队列的操作，所以可以定义两个数值头数值(front)和尾数值(rear)，在创建队列的时候根据capacity(队列容量)的大小创建线性表，然后让头数值和尾数值都为0代表数组下标为0的第一个数据的位置，入队时对rear进行操作移动即可实现，出队只需移动front即可完成出队。 12345678910111213class SqQueue&#123; char* datas;//线性表 int capacity;//队列容量 int front;//队首 int rear;//队尾 public: SqQueue(int c)&#123; capacity = c; datas = new char[capacity]; front = rear = 0; &#125; &#125; 顺序队列 入队操作 思路：因为顺序队列是要通过数组来实现队列的数据结构。所以可以先定义两个值分别代表尾数值和头数值，创建队列时，这头尾两个数值均为0，代表为数组第一个元素。入队时只需让下标为尾数值的数组元素进行添值即可。 具体实现： 1234567bool push(T e)&#123; if(rear == capacity) return false; datas[rear] = e; rear++; return true;&#125; 出队操作 思路：直接让头数值进行自加即可实现出队操作 具体实现： 123bool pop()&#123; front++;&#125; 出现一个问题:前面只是实现了基本的队列应该有的操作，如果对其进行出队操作，一定量的数据出队后会照成队列无法使用的情况。为此可以对顺序队列进行改造优化使它成为环状的顺序队列从而可以循环使用。 循环队列 入队操作： 思路：相比顺序队列，循环队列在入队操作时只是对尾数值进行改进使其只能在队列容量之内循环变化。即：rear = (rear+1)%capacity 算法解释：(以容量为5的队列为例) 第一步：push入队一个元素rear让其从初值0加1再取模5【(0+1)%5 = 1%5 = 1】以此类推，第二个数据入队，rear为2….第四个为4。 第二步：当到达尾数值即下标为4的时候再进行上方的运算。即【(4+1)%5 = 5%5=0】重置尾数值为0。 具体实现： 1234567bool push(T e)&#123; if((rear+1)%capacity == front)//满队判断 return false; datas[rear] = e; rear = (rear+1)%capacity; return true;&#125; 满队的处理：这里是用(rear+1)%capacity == front来作为满队判断的，即队首和队尾都只隔了1。例如：当队首为3，队尾为2为满队。因为(2+1)%5 = 3%5 = 3 出队操作 思路：与顺序队列相同，只是队头也要控制在capacity队列容量之内，即front = (front + 1)% capacity。 具体实现： 123456bool pop()&#123; if(front == rear)//空队判断 return false front = (front + 1)% capacity; return true;&#125; 具体代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt; class SqQueue &#123; T* datas; int capacity; int rear; int front;public: /*构造函数*/ SqQueue(int c = 10) &#123; capacity = c; datas = new T[capacity]; rear = front = 0; &#125; /*入队操作*/ bool push(T e) &#123; if ((rear + 1) % capacity == front) return false; datas[rear] = e; rear = (rear+1)%capacity; return true; &#125; /*出队操作*/ bool pop() &#123; if (rear == front) return false; front = (front + 1) % capacity; &#125; void tr(void(*fb)(T&amp; e)) &#123; for (int i = front; i &lt; rear; i++) &#123; fb(datas[i]); &#125; &#125;&#125;;void Print(char&amp; a) &#123; cout &lt;&lt; a &lt;&lt; " ";&#125;int main() &#123; SqQueue&lt;char&gt; s; cout &lt;&lt; "数据a入队了" &lt;&lt; endl; s.push('a'); s.tr(Print); cout &lt;&lt; endl; cout &lt;&lt; "数据b入队了" &lt;&lt; endl; s.push('b'); s.tr(Print); cout &lt;&lt; endl; cout &lt;&lt; "数据c入队了" &lt;&lt; endl; s.push('c'); s.tr(Print); cout &lt;&lt; endl; cout &lt;&lt; "数据d入队了" &lt;&lt; endl; s.push('d'); s.tr(Print); cout &lt;&lt; endl; cout &lt;&lt; "数据e入队了" &lt;&lt; endl; s.push('e'); s.tr(Print); cout &lt;&lt; endl; cout &lt;&lt; "头数据出队了 " &lt;&lt; endl; s.pop(); s.tr(Print); cout &lt;&lt; endl; cout &lt;&lt; "头数据出队了 " &lt;&lt; endl; s.pop(); s.tr(Print); cout &lt;&lt; endl; cout &lt;&lt; "头数据出队了 " &lt;&lt; endl; s.pop(); s.tr(Print); cout &lt;&lt; endl; cout &lt;&lt; "头数据出队了 " &lt;&lt; endl; s.pop(); s.tr(Print); cout &lt;&lt; endl; cout &lt;&lt; "头数据出队了 " &lt;&lt; endl; s.pop(); s.tr(Print); cout &lt;&lt; endl;&#125; 实验结果: —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-(1.7)数据类型转换]]></title>
    <url>%2F2019%2F07%2F04%2FC%2B%2B%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-(1.7)%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[C语言风格的类型转换12345678/*隐式转换*/int a = 100;double b = 2.3;cout &lt;&lt; a+b &lt;&lt;endl;//结果转换成double型/*显示转换*/double c = 2.345;cout &lt;&lt; (int)c &lt;&lt;endl;//结果转换成整型 c++的强制类型转换 C++中的强制类型装换提供它们其目的是拥有更丰富的含义和功能，更好的类型检查机制。 代码定义： 强制类型转换名&lt;type&gt;(express) type:目标数据类型 express：转换的原数据目标 static_cast静态转换 在编译时进行类型转换。 使用场合 相关类型转换：int-&gt;double 123double a = 2.345; int b = static_cast&lt;int&gt;(a); cout &lt;&lt; b; 继承关系转换：子类-&gt;父类 父类a = statci_cast&lt;父类&gt;(子类数据) 万用指针(void*)与其他类型指针之间转换 1234567int a = 100; int* a_ptr = &amp;a; void* n = a_ptr; int* temp = n;//报错：不能把万能指针转换成int* int* temp = static_cast&lt;int*&gt;(n);//允许 注意：对万能指针进行转换时要注意转换的安全性和准确性。（例：不能把string转换成double类型） 使用错误的场合 除万能指针的转换，其余指针类型之间不能相互转换 123456double a = 12123;double* a_ptr = &amp;a;int* t = static_cast&lt;int*&gt;(a_ptr);//报错，不同指针类型间不能转换double* b = static&lt;double*&gt;(a_ptr);//允许：同种类型可以转换(没有意义) dynamic_cast动态转换 在运行时进行类型识别和检查。 const_cast常量转换 编译时对数据进行指针和引用常量和变量直接的相互转换。 12345678const int a = 100; a = 200;//报错：不能修改常量的数值。 int b = const_cast&lt;int&gt;(a);//报错：const_cast只能去除指针或引用的const const int* a_ptr = &amp;a; int* b_ptr = const_cast&lt;int*&gt;(a_ptr);//允许 注意: 不要对变为变量的指针修改其里面的值。例如上方：*b_ptr = 200；//不可以，不要这样干，风险较大。 reinterpret_cast重新解释 在编译时，处理无关系类型的转换。（例如：int-&gt;int*、double*-&gt;int*) 使用场合 把整型转换成指针类型、不同类型指针之间的转换。 int-&gt;int*、double*-&gt;int* 把一个指针转换成整型。 int*-&gt;int —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（3.4）队列及链式队列的实现]]></title>
    <url>%2F2019%2F07%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%883-4%EF%BC%89%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列的基本概念及定义 定义： 队列与栈相似，相比栈的先进后出，队列是先进先出为特征的，队列的增添必须是在队列后边进行添加，删除则在前面，正与它的名字一样，队列这种数据结构跟平常时人们买票排队一样，先去排的会先买到票，后面来的只能先排着队。 特征：先进先出(FIFO,First In First Out) 队列的抽象数据类型 ADT Queue Data 线性关系(a1,a2,…,an) Operation bool push(e) 入队操作 bool pop() 出队 T&amp;front() 获得队首数据 bool empty() 判断队列是否为空 void clear() 清空队列 …….. 链式队列实现算法及思路 入队操作 思路：因为队列是先进先出的，所以要使一个指针能始终能指向新进来的元素，方便后续出队操作。所以可以先让尾指针的next指针指向这个新入队的元素，然后再让尾指针指向这个元素。 具体代码实现: 123456789101112bool push(T e)&#123; Node* p = new Node; if(!p)return false; p-&gt;data = e; p-&gt;next = nullptr; rear-&gt;next = p; rear = p; return true&#125; 出队操作 思路：先进先出，此时可以直接删除第一个数据，即头结点next指向的数据。但要记住这操作不能在队列为空的情况下使用。 具体代码实现： 1234567891011bool pop()&#123; if(rear == head) return false; Node* p = head-&gt;next; head-&gt;next = p-&gt;next; delete p; return true; &#125; 具体代码实现情况： 入队(完成) push(T e) 出队(完成) pop() 是否为空(完成) IsEmpty(); 获得队首元素(完成) getFirst() 清空队列(完成) clear() 具体代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;class Queue &#123; struct Node &#123; T data; Node* next; &#125;; Node* head; Node* rear;public: Queue() &#123; head = new Node; head-&gt;next = nullptr; rear = head; &#125; /*入队操作*/ bool push(T e) &#123; Node* p = new Node; p-&gt;data = e; p-&gt;next = nullptr; rear-&gt;next = p; rear = p; return true; &#125; /*出队操作*/ bool pop() &#123; if (head == rear) return false; Node* p = head-&gt;next; head-&gt;next = p-&gt;next; delete p; return true; &#125; /*是否为空*/ bool IsEmpty() &#123; return head == rear; &#125; /*获得首元素*/ T getFirst() &#123; return head-&gt;next; &#125; /*清空队列*/ bool clear() &#123; Node* p = head-&gt;next; Node* q = nullptr; while (p != rear) &#123; q = p; p = p-&gt;next; delete q; &#125; delete rear; rear = head; return true; &#125; void Ta(void(*fb)(T&amp; e)) &#123; Node* p = head; while (p != rear) &#123; p = p-&gt;next; fb(p-&gt;data); &#125; &#125;&#125;;template &lt;typename T&gt; void print(T&amp; e) &#123; cout &lt;&lt; e &lt;&lt; " ";&#125;int main() &#123; Queue&lt;char&gt; q; cout &lt;&lt; "a数据进队了" &lt;&lt; endl; q.push('a'); q.Ta(print); cout &lt;&lt; endl; cout &lt;&lt; "b数据进队了" &lt;&lt; endl; q.push('b'); q.Ta(print); cout &lt;&lt; endl; cout &lt;&lt; "c数据进队了" &lt;&lt; endl; q.push('c'); q.Ta(print); cout &lt;&lt; endl; cout &lt;&lt; "d数据进队了" &lt;&lt; endl; q.push('d'); q.Ta(print); cout &lt;&lt; endl; cout &lt;&lt; "清空队列" &lt;&lt; endl; q.clear(); cout &lt;&lt; "e数据进队了" &lt;&lt; endl; q.push('e'); q.Ta(print); cout &lt;&lt; endl; cout &lt;&lt; "f数据进队了" &lt;&lt; endl; q.push('f'); q.Ta(print); cout &lt;&lt; endl; cout &lt;&lt; "g数据进队了" &lt;&lt; endl; q.push('g'); q.Ta(print); cout &lt;&lt; endl; cout &lt;&lt; "h数据进队了" &lt;&lt; endl; q.push('h'); q.Ta(print); cout &lt;&lt; endl; cout &lt;&lt; "首数据出队了" &lt;&lt; endl; q.pop(); q.Ta(print); cout &lt;&lt; endl; cout &lt;&lt; "首数据出队了" &lt;&lt; endl; q.pop(); q.Ta(print); cout &lt;&lt; endl; cout &lt;&lt; "首数据出队了" &lt;&lt; endl; q.pop(); q.Ta(print); cout &lt;&lt; endl;&#125; 实验结果: —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈的应用-括号匹配]]></title>
    <url>%2F2019%2F07%2F02%2F%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8-%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[括号匹配 对一段字符串进行检查和判断括号是否匹配。例如：{（）[]{}} 匹配。即出现一个左括号就一定要一个相对应的右括号与其匹配。 实现思路：可以对一个字符串进行扫描和检查，如果是左括号那么就入栈，如果遇到一个与之匹配的右括号，那么就使其出栈。最后判断栈是否为空从而判断括号是否匹配即可。 以（{heheda}[123]())为例。 第一步扫描上方字符串。发现第一个左括号‘(’使其入栈，第二个&#39;{&#39;入栈，发现&#39;}&#39;为右括号，与栈顶数据进行匹配发现，此时栈顶就是&#39;{&#39;与之匹配那么就出栈。（类似消消乐） 具体代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include"LKStack.h"#include&lt;iostream&gt;bool CheckStr(string str) &#123; LkStack&lt;char&gt; stack; cout &lt;&lt; "字符串：" &lt;&lt; str &lt;&lt; " "; for (int i = 0; i &lt; str.length(); i++) &#123; /*如果是左括号那么就入栈，等待匹配*/ if (str[i] == '[' || str[i] == '&#123;' || str[i] == '(') &#123; stack.push_back(str[i]); &#125; /*如果是右括号那么就对栈顶数据进行判断，如果匹配那么就使此时的栈顶数据出栈*/ if (str[i] == ']' || str[i] == '&#125;' || str[i] == ')') &#123; /*排除只出现右括号没出现左括号的情况，和多出有右括号的情况*/ if (stack.isEmpty()) &#123; cout &lt;&lt; "括号不匹配！" &lt;&lt; endl; return false; &#125; if (!stack.isEmpty() &amp;&amp; str[i] == ']' &amp;&amp; stack.GetTop() == '[') stack.pop(); if (!stack.isEmpty() &amp;&amp; str[i] == '&#125;' &amp;&amp; stack.GetTop() == '&#123;') stack.pop(); if (!stack.isEmpty()&amp;&amp; str[i] == ')' &amp;&amp; stack.GetTop() == '(') stack.pop(); &#125;&#125; /*如果空栈那么就说明左括号全部匹配完毕，括号匹配成功，反之括号不匹配*/ if (stack.isEmpty()) &#123; cout &lt;&lt; "括号匹配成功！" &lt;&lt; endl; return true; &#125; else &#123; cout &lt;&lt; "括号不匹配！" &lt;&lt; endl; return false; &#125; &#125;int main() &#123; CheckStr("12312()()[]&#123;&#123;&#125;&#125; "); CheckStr("&#125;"); CheckStr("[()(),hello&#123;&#125;]"); CheckStr("test"); CheckStr("()(&#125;[]");&#125; 实验结果： —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法性能分析]]></title>
    <url>%2F2019%2F07%2F02%2F%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[算法性能分析好的算法应当满足 正确性：算法应能满足具体问题的需求 可读性：算法应应易于阅读和理解 健壮性：输入数据非法时，算法也能适当作出反应或进行处理 高效性：算法执行时间短，占用存储空间少 时间复杂度 程序：算法在计算机上的实现 程序的执行时间取决于如下因素： 算法本身 问题规模 编程语言 硬件性能 选择一个“基本操作”，分析基本操作执行的次数 用该基本操作的重复次数表示算法的执行时间，一般为问题规模n的函数f(n)，简称“频度”。 算法的时间复杂度为：和f(n)同阶的简化无穷大量T(n) = O(f(n))]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表应用- 两数相加]]></title>
    <url>%2F2019%2F06%2F29%2F%E9%93%BE%E8%A1%A8%E5%BA%94%E7%94%A8-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[两数相加 问题： 给定两个非空链表来表示两个非负整数。位数按照逆序方式储存，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。你可以假设除了数字0之外，这两个数字都不会以零开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出: 7 -&gt; 0 -&gt; 8 原因: 342 + 465 = 807 一些算法的思路： 先把一个数字转换为一个链表 243 转换为 2 -&gt; 4 -&gt; 3 所以先用一个 将数字转换为链表的函数 12345678Lklist ToLKlist(int r) &#123; Lklist stack; while (r) &#123; stack.push(r % 10); r /= 10; &#125; return stack;&#125; 实现思路：对进来的数字，直接模10取个位，然后后插入一个链表中，然后取十位……以此类推直到把所以值都后插入链表中。 转换数字后就会得到两个链表。然后进行相加。相加时得实现把链表转换成数字，例如 2 -&gt; 4 -&gt; 3转换成数字342。 123456789101112int number(Lklist num) &#123; int result = 0; int len = num.Getlength(); int i = 1; while (!num.IsEmpty()) &#123; result += num.getfirst() * i; num.deletefirst(); i *= 10; &#125; return result;&#125; 实现思路：因为获得的数字链表是2 -&gt; 4 -&gt; 3，而实际对应的数字是342，所以可以先把第一个个位数字获得，加上十位，百位。 最后一步把相加的结果再ToLKlist()用变为链表。 具体实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;iostream&gt;using namespace std;class Lklist &#123; struct LNode &#123; int data; LNode* next; &#125;; LNode* head; int length;public: Lklist() &#123; head = new LNode; head-&gt;next = nullptr; length = 0; &#125; /*前插操作*/ bool push(int e) &#123; LNode* p = new LNode; if (!p)return false; p-&gt;data = e; p-&gt;next = head-&gt;next; head-&gt;next = p; length++; return true; &#125; /*后插操作*/ bool push_back(int e) &#123; LNode* p = head; LNode* q = new LNode(); int j = 0; while (p-&gt;next) &#123; p = p-&gt;next; &#125; if (!p)return false; q-&gt;data = e; q-&gt;next = 0; p-&gt;next = q; length++; return true; &#125; /*删除第一个数据操作*/ bool deletefirst() &#123; if (!head-&gt;next) return false; LNode* p = head-&gt;next-&gt;next; delete head-&gt;next; head-&gt;next = p; length--; return true; &#125; /*获得第一个元素*/ int getfirst() &#123; return head-&gt;next-&gt;data; &#125; /*判断是否为空链表*/ bool IsEmpty() &#123; return head-&gt;next == nullptr; &#125; /*获得链表长度*/ int Getlength() &#123; return length; &#125;&#125;;/*转换为数字*/int number(Lklist num) &#123; int result = 0; int len = num.Getlength(); int i = 1; while (!num.IsEmpty()) &#123; result += num.getfirst() * i; num.deletefirst(); i *= 10; &#125; return result;&#125;/*数字转换为链表*/Lklist ToLKlist(int r) &#123; Lklist stack; while (r) &#123; stack.push(r % 10); r /= 10; &#125; return stack;&#125;/*两数相加核心代码*/Lklist TwoNumberAdd(Lklist num1, Lklist num2) &#123; int a = number(num1); int b = number(num2); return ToLKlist(a + b);&#125;int main() &#123; int a; int b; Lklist s; cout &lt;&lt; "请输入第一个数： "; cin &gt;&gt; a; cout &lt;&lt; endl &lt;&lt; "请输入第二个数： "; cin &gt;&gt; b; s = TwoNumberAdd(ToLKlist(a), ToLKlist(b)); int i = 0; int len = s.Getlength(); while (!s.IsEmpty()) &#123; cout &lt;&lt; s.getfirst(); if (i &lt; len - 1) &#123; cout &lt;&lt; "-&gt;"; i++; &#125; s.deletefirst(); &#125;&#125; 实验结果: 标准参考答案：1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public : ListNode* addTwoNumber(ListNode* l1, ListNode* l2) &#123; int x = 0; int y = 0; int carry = 0; int sum = 0; ListNode* h = nullptr; ListNode** t = &amp;h; while (l1!=nullptr||l2!=nullptr) &#123; x = getValueAndMoveNext(l1); y = getValueAndMoveNext(l2); sum = carry + x + y; ListNode* node = new ListNode(sum % 10); *t = node; t = (&amp;node-&gt;next); carry = sum / 10; &#125; if (carry &gt; 0) &#123; ListNode* node = new ListNode(carry % 10); *t = node; &#125; return h;&#125;private: int getValueAndMoveNext(ListNode*&amp; l) &#123; int x = 0; if (l != nullptr) &#123; x = l-&gt;val; l = l-&gt;next; &#125; return x; &#125;&#125;; 参考答案的核心算法思路： ListNode* addTwoNumber(ListNode* l1, ListNode* l2) 这步先把两个链表的第一个元素取出存入X和Y中，然后让其想加并加上一个进位carry数。以(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)为例。 第一步： 取出两个链表中的第一个元素2和5。 第二步： 让其相加并加上一个进位数即sum = carry(此时为0) + 2 + 5 = 7 第三步： 把结果7模上10并push_back进结果链表。此时结果为7并且是结果链表的第一个数据 然后重置进位carry即：carry = sum / 10,因为2 + 5 = 7小于10所以不用进位。 第四步： 循环上面的步骤 第二次循环中4和6的和是10，模上10取余后的结果为0，push_back进结果链表作为第二个数据 因为10是大于等于10的，所以要进位，故进行carry = sum / 10时，carry结果会为1作为下一次循环，sum = carry + x + y中的进位 总体来看，首先因为题目描述为 位数按照逆序方式储存，所以这里运用了普通加法运算。即：从个位开始相加，满10进1至下位的思路。 个人实现代码优化后：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;iostream&gt;using namespace std;class LKlist &#123;public: struct LNode &#123; int data; LNode* next; &#125;; LNode* head; int length;public: LKlist() &#123; head = new LNode(); head-&gt;next = nullptr; length = 0; &#125; bool push_back(int e) &#123; LNode* p = new LNode; LNode* t = head; p-&gt;data = e; while (t-&gt;next) &#123; t = t-&gt;next; &#125; t-&gt;next = p; p-&gt;next = nullptr; length++; return true; &#125; bool IsEmpty() &#123; return head-&gt;next == nullptr; &#125; bool deletefirst() &#123; if (!head-&gt;next) return false; LNode* p = head-&gt;next-&gt;next; delete head-&gt;next; head-&gt;next = p; length--; return true; &#125; int getfirst() &#123; return head-&gt;next-&gt;data; &#125; int Getlength()&#123; return length; &#125;&#125;;int getValueAndMoveNext(LKlist&amp; l) &#123; int x = 0; LKlist::LNode* T; if (l.head-&gt;next) &#123; x = l.head-&gt;next-&gt;data; T = l.head-&gt;next-&gt;next; delete l.head-&gt;next; l.head-&gt;next = T; &#125; return x;&#125;LKlist addTwoNumber(LKlist&amp; l1, LKlist&amp; l2) &#123; int x = 0; int y = 0; int sum = 0; int carry = 0; LKlist h; while (!l1.IsEmpty() || !l2.IsEmpty()) &#123; x = getValueAndMoveNext(l1); y = getValueAndMoveNext(l2); sum = carry + x + y; h.push_back(sum % 10); carry = sum / 10; &#125; if (carry &gt; 0) &#123; h.push_back(carry % 10); &#125; return h;&#125; 实验结果: —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈的应用-进制的转换]]></title>
    <url>%2F2019%2F06%2F29%2F%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8-%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[数制转换 以十进制转八进制为例，十进制转八进制的时候是把十进制模8取其余数直至除尽，最终结果为余数从下到上的数。 例如： 结合数据结构栈，可以发现转换最终结果跟栈的出栈一样，所以用栈来实现十进制的转换就较为方便 123456789101112void changeNumber(int n,int b)&#123;//n为十进制数，b为将要转的进制数 Stack&lt;int&gt; stack；//定义一个栈 while(n)&#123; stack.push(n%b);//获取余数并入栈 n = n/b;//更新n &#125; while(!stack.isEmpty())&#123;//出栈并输出。直至为空栈 cout &lt;&lt; stack.getTop();//获得栈顶元素 stack.pop();//每输出一个就出栈一个数据 &#125; &#125; 代码实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;using namespace std;/***********链栈实现************/template&lt;typename T&gt;class Stack &#123; struct LNode &#123; T data; LNode* next; &#125;; LNode* head;public: Stack() &#123; head = new LNode; head-&gt;next = nullptr; &#125; /*入栈操作*/ bool push(T e) &#123; LNode* p = new LNode; if (!p)return false; p-&gt;data = e; p-&gt;next = head-&gt;next; head-&gt;next = p; return true; &#125; /*出栈操作*/ bool pop() &#123; if (!head-&gt;next) return false; LNode* p = head-&gt;next-&gt;next; delete head-&gt;next; head-&gt;next = p; return true; &#125; /*获得栈顶元素*/ T getTop() &#123; return head-&gt;next-&gt;data; &#125; /*判断是否为空栈*/ bool IsEmpty() &#123; return head-&gt;next == nullptr; &#125;&#125;;/*********************************//*数据转换*/void ChangeNumber(int n,int b) &#123; Stack&lt;int&gt; stack; int result = 0; while (n) &#123; stack.push(n % b); n = n / b; &#125; while (!stack.IsEmpty()) &#123; cout &lt;&lt; stack.getTop(); stack.pop(); &#125; &#125;int main() &#123; ChangeNumber(75, 8);&#125; 实验结果: —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ vector容器常用操作和内存释放]]></title>
    <url>%2F2019%2F06%2F29%2FC-vector%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%2F</url>
    <content type="text"><![CDATA[一、对字符串的处理 对字符串每一个字符进行遍历修改操作 12345678910111213141516#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int main() &#123; string ifo = "ShuHaoHwang"; for (auto iter = ifo.begin(); iter != ifo.end(); iter++) &#123; *iter = toupper(*iter); &#125; cout &lt;&lt; ifo &lt;&lt; endl;&#125; 二、查找配置项信息及内存释放 用迭代器及vector容器实现通过一个配置项名就能查询获得相应配置项的信息，最后利用vector进行内存释放。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;struct conf&#123; char confname[40];//配置项名 char confid[100];//配置项信息&#125;;char* getifo(vector&lt;conf*&gt;&amp; a, const char* s) &#123; vector&lt;conf*&gt;::iterator iter; for (iter = a.begin(); iter != a.end(); iter++) &#123; if (strcmp((*iter)-&gt;confname, s) == 0) &#123;//如果找到对应配置项名，就返回其配置项的信息 return (*iter)-&gt;confid; &#125; &#125; return nullptr;&#125;int main() &#123; conf* server = new conf; conf* server2 = new conf; /*配置项名1*/ strcpy_s(server-&gt;confname,sizeof(server-&gt;confname),"ServerName"); /*配置信息1*/ strcpy_s(server-&gt;confid, sizeof(server-&gt;confid), "1区"); /*配置项名2*/ strcpy_s(server2-&gt;confname, sizeof(server2-&gt;confname), "ServerID"); /*配置信息2*/ strcpy_s(server2-&gt;confid, sizeof(server2-&gt;confid), "10000"); vector&lt;conf*&gt; cinfo; cinfo.push_back(server);//把结构指针放入容器 cinfo.push_back(server2); vector&lt;conf*&gt;::iterator iter; /*查找信息*/ char* temp; temp = getifo(cinfo, "ServerName"); if (temp != nullptr) &#123; cout &lt;&lt; "ServerName: " &lt;&lt; temp &lt;&lt; endl; &#125; /*释放内存*/ for (iter = cinfo.begin(); iter != cinfo.end(); iter++) &#123; delete (*iter);//因为*iter是一个指针 &#125; cinfo.clear();//最后清空容器 &#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>技术类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++迭代器的失控范例和解决方案]]></title>
    <url>%2F2019%2F06%2F28%2FC-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%A4%B1%E6%8E%A7%E8%8C%83%E4%BE%8B%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[迭代器失控范例情形一： 很多在使用迭代器类型进行遍历容器的操作进行对容器容量的变化都会导致迭代器的失控，即输出错误的值。例如：要对vector容器进行push_back()操作、对vector容器进行插入操作、删除操作。都会使end()函数返回的迭代器类型位置错乱，导致出现可能会修改未被使用内存的风险，从而使程序崩溃。 例如： 1234567891011vector&lt;int&gt; arrays&#123;12,35,56,78&#125;;vector&lt;int&gt;::iterator iter = arrays.begin();for(iter;iter!=arrays.end();iter++)&#123; cout &lt;&lt; *iter &lt;&lt;endl; arrays.push_back(2);&#125;//或者下面这种情况for(iter;iter!=arrays.end();iter++)&#123; cout &lt;&lt; *iter &lt;&lt;endl; arrays.insert(1,100);&#125; 实验结果： 在一般情况下，如果只是要对容器进行添加一个元素，可以使用下面的方法。 123456789101112vector&lt;int&gt; arrays&#123;12,35,56,78&#125;;vector&lt;int&gt;::iterator iter = arrays.begin();for(iter;iter!=arrays.end();iter++)&#123; cout &lt;&lt; *iter &lt;&lt;endl; arrays.push_back(2); break;//添加元素后直接跳出&#125;//再进行一次迭代器遍历for(iter;iter!=arrays.end();iter++)&#123; cout &lt;&lt; *iter &lt;&lt;endl; arrays.push_back(2);&#125; 实验结果： 如果真的在实际项目中要进行在迭代器遍历容器的时候对容器多次进行增添内容，可以使用下面的方法。 123456789101112131415vector&lt;int&gt; arrays&#123;12,35,56,78&#125;;vector&lt;int&gt;::iterator iter = arrays.begin();int i = 0//用来控制插入次数（循环次数） while(iter != arrays.end())&#123; iter = arrays.insert(iter,100); if(i &gt; 5) break; iter++; i++; &#125;for(iter = arrays.begin(); iter != arrays.end(); iter++)&#123; cout &lt;&lt; *iter &lt;&lt; endl;&#125; 实验结果： 实现思路:因为arrays.insert()的返回值是一个迭代器类型，所以在循环中不断刷新循环的起始位置(因为是前插，所以end()的值没有发生变化)。多次更新迭代器的起始begin()的值，从而使迭代器类型的指向不会失控。 同样的如果使用push_back(): 123456789101112131415161718vector&lt;int&gt; arrays&#123;12,35,56,78&#125;;vector&lt;int&gt;::iterator iter = arrays.begin();int i = 0//用来控制插入次数（循环次数） while(iter != arrays.end())&#123; arrays.push_back(100);//不断更新iter的值起始 iter = arrays.begin() if(i &gt; 5) break; iter++; i++; &#125;for(iter = arrays.begin(); iter != arrays.end(); iter++)&#123; cout &lt;&lt; *iter &lt;&lt; endl;&#125; 实验结果： 总体：即每对容器的容量进行变化一次便刷新迭代器的值。使其成为新的迭代器进行操作，就可以避免容器的失控。弊端：麻烦，代码较繁杂。 情形二： 如果在某个时候要对容器进行清空操作，多数下使用容器自带的clear()函数即可。但在某些特殊情况下，要对vector容器的某些元素进行删除，就得使用容器自带的` `函数。但是这样做就是对容器容量进行修改操作，会使迭代器指向失控。 例如： 12345vector&lt;int&gt; arrays&#123;12,35,56,78&#125;vector&lt;int&gt;::iterator iter;for(iter = arrays.begin(); iter != arrays.end(); iter++)&#123; arrays.erase(iter);&#125; 使用结果 如果真的要进行这样的操作可以这样做： 12345678910vector&lt;int&gt; arrays&#123;12,35,56,78&#125;vector&lt;int&gt;::iterator iter = arrays.begin();while(iter != arrays.end())&#123; iter = arrays.erase(iter);//直接让erase函数来更新迭代器指向的位置&#125;//for版for(iter; iter != arrays.end(); )&#123; iter = arrays.erase(iter);&#125; 实验结果： 实现思路：因为erase()函数是清除该位置的数据，并返回下一个元素的位置，所以可以通过它来对迭代器进行更新，从而不会时迭代器指向失控。 此情形更好的实现版本 1234567vector&lt;int&gt; arrays&#123;12,35,56,78&#125;vector&lt;int&gt;::iterator iter = arrays.begin();while(!arrays.empty())&#123;//如果不为空就继续 auto iter = arrays.begin();//每开始一轮循环就更新迭代器的指向。 arrays.erase(iter);&#125; —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>技术类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（1.6）迭代器]]></title>
    <url>%2F2019%2F06%2F26%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%881-6%EF%BC%89%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[迭代器的基本概念; 迭代器是一种遍历容器元素的一种数据类型，这种数据类型类似指针。 通过迭代器可以读取容器中的数据元素，也可以修改里面的数据元素 容器迭代器类型：(vector为例) 代码定义： 12vector&lt;int&gt; arrays = &#123;12,34,88&#125;;vector&lt;int&gt;::iterator iter;//迭代器定义，其中vector&lt;int&gt;::iterator是数据类型 操作 begin()/end() 用来返回迭代类型。 具体用法: rend()/rbegin() 这个是配套于vector&lt;int&gt;::r_iterator iter 具体用法: 实际运用： 1.用for语句遍历一个容器： 1234567vector&lt;int&gt; arrays = &#123;12,56,88,96&#125;; vector&lt;int&gt;::iterator iter = arrays.begin(); for (iter = arrays.begin(); iter != arrays.end(); iter++) &#123; cout &lt;&lt; *iter &lt;&lt; endl; &#125; 实验结果： 可以看出，迭代器类型是一个类似于指针一样的东西，允许自增/自减。在获得值或者修改的时候是用*iter进行操作。 const_iterator迭代器 不能改变迭代器指向的地址的内容。类似常量指针。 12345678vector&lt;int&gt; arrays = &#123;12,56,88,96&#125;; vector&lt;int&gt;::const_iterator iter = arrays.begin(); for (iter = arrays.begin(); iter != arrays.end(); iter++) &#123; cout &lt;&lt; *iter &lt;&lt; endl; (*iter)++;//报错。不能修改值 &#125; 使用情形1： 如果你的容器类型是常量的话const vector&lt;int&gt; arrays，那么你就只能且一定要常量迭代器。 cbegin()/cend()（C++11后才有的新特性） 这两个函数与begin()/end()很相似，只是无论迭代器类型是常量迭代器还是普通迭代器都返回一个常量迭代器 原来的begin()/end()会根据迭代器类型来返回。 迭代器失控 正常操作： 1234vector&lt;int&gt;arrays = &#123;12,56,88,96&#125;;for(auto a::arrays)&#123; cout &lt;&lt; a &lt;&lt; endl;&#125; 运行结果： 错误操作: 1234567891011121314vector&lt;int&gt;arrays = &#123;12,56,88,96&#125;;for(auto a::arrays)&#123; cout &lt;&lt; a &lt;&lt; endl; arrays.push_back(100);&#125;//上面等价于vector&lt;int&gt;arrays = &#123;12,56,88,96&#125;;vector&lt;int&gt;::iterator iter;for(iter = arrays.begin(); iter != arrays.end(); iter++)&#123; cout &lt;&lt; *iter &lt;&lt; endl; arrays.push_back(100);&#125; 运行结果: 结论：千万不要在迭代器操作过程中，千万不要改变vector(容器)的容量。这样错误的操作即：从容器删除，增加（使容器容量改变），可能会使迭代器指针失控，不能代表容器中的元素,在多数情况下程序会奔溃。 如果一定要在循环中进行容量增减操作： 1234567891011vector&lt;int&gt;arrays = &#123;12,56,88,96&#125;;vector&lt;int&gt;::iterator iter;for(iter = arrays.begin(); iter != arrays.end(); iter++)&#123; cout &lt;&lt; *iter &lt;&lt; endl; arrays.push_back(100); break；//直接break；&#125;//再开一个迭代器循环，此时的迭代器指针的值将重新赋值。for(iter = arrays.begin(); iter != arrays.end(); iter++)&#123; cout &lt;&lt; *iter &lt;&lt; endl;&#125; —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（3.3）链栈]]></title>
    <url>%2F2019%2F06%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%883-3%EF%BC%89%E9%93%BE%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈的链式实现算法及思路 栈的链式实现是以前插法为基础的。即以头结点next指向的是栈顶，进行入栈出栈等操作。 入栈 思路：创建好空链栈后，每插入一个数据，便创建一个新的结点p，让p结点的next指针等于head的next指针，让head的next指针再指向新结点p，从而完成push_back操作。 具体实现： 12345678bool push_back(T e)&#123; LNode*p = new LNode(); p-&gt;data = e; p-&gt;next = head-&gt;next; head-&gt;next = p; return true;&#125; 出栈 思路：直接让head的next指针指向head-&gt;next-&gt;next即跳过原栈的数据，所以可以先让一个临时的p指向head-&gt;next,然后让head的next指针直接指向p的next指针。之后释放p的空间。(注意：进行出栈操作要首先判断是否空栈) 具体实现： 123456789bool pop()&#123; LNode* p = head-&gt;next; if(!head-&gt;next)&#123; head-&gt;next = p-&gt;next; delete p; return true; &#125; return false;&#125; 析构函数 思路：析构函数就是链栈的销毁操作。总体上先把所有的数据进行出栈并释放空间，最后再把头结点释放了。所以要先用循环，分别释放每一个数据的空间。循环结束的判断条件是head-&gt;next 为空。 具体实现： 12345678~LkStack()&#123; LNode*p = head-&gt;next; while(p)&#123; head-&gt;next = p-&gt;next; delete p; p = head-&gt;next; &#125;&#125; 具体代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;class LkStack&#123; struct LNode &#123; T data; LNode* next; &#125;; LNode* head;public: LkStack() &#123; head = new LNode(); head-&gt;next = nullptr; &#125; ~LkStack() &#123; LNode* p = head-&gt;next; while (p) &#123; head-&gt;next = p-&gt;next; delete p; p = head-&gt;next; &#125; delete head; &#125; /*入栈操作*/ bool push_back(T e) &#123; LNode* p = new LNode(); p-&gt;data = e; p-&gt;next = head-&gt;next; head-&gt;next = p; return true; &#125; /*出栈操作*/ bool pop() &#123; if (!isEmpty()) &#123; LNode* p = head-&gt;next; head-&gt;next = p-&gt;next; delete p; return true; &#125; return false; &#125; /*是否为空*/ bool isEmpty() &#123; if (!head-&gt;next) return true; return false; &#125; /*获得栈顶数据*/ T&amp; GetTop() &#123; return head-&gt;next-&gt;data; &#125;&#125;;int main() &#123; LkStack&lt;int&gt; stack; cout &lt;&lt; "入栈了数据1" &lt;&lt;endl; stack.push_back(1); cout &lt;&lt; "入栈了数据2" &lt;&lt;endl; stack.push_back(2); cout &lt;&lt; "入栈了数据3" &lt;&lt;endl; stack.push_back(3); cout &lt;&lt; "入栈了数据4" &lt;&lt;endl; stack.push_back(4); cout &lt;&lt; "入栈了数据5" &lt;&lt;endl; stack.push_back(5); while (!stack.isEmpty()) &#123; cout &lt;&lt; stack.GetTop() &lt;&lt; endl; stack.pop(); &#125;&#125; —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++个人学习路线]]></title>
    <url>%2F2019%2F06%2F25%2FC-%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[此文章是加密文章，请输入密码后查看. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>个人随感</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习计划</tag>
        <tag>目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（1.5）vector容器详解]]></title>
    <url>%2F2019%2F06%2F25%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%881-5%EF%BC%89vector%E5%AE%B9%E5%99%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[vector的基本介绍及概念 标准库中的一个集合或者动态数组，可以存放若干个对象。它能把其他对象装起来，也称为容器。 代码定义： vector&lt;typename&gt; name; 在vector之后加一对&lt;&gt;,其&lt;&gt;内部填数据类型 定义及初始化vector对象 例：vector&lt;int&gt; arrays;创建一个int型的空的vector对象，里面没有包含任何元素。 初始化： 往空vector容器添加元素： arrays.push_back(100);往arrays容器中加入一个100。 元素拷贝的初始方式 vector&lt;int&gt;arrays2(arrays);把arrays直接拷贝进arrays2。 vector&lt;int&gt;arrays3 = arrays;同上。 用列表初始化(C++11标准后才有的新特性) vector&lt;int&gt;arrays4 = {12,32,45,67}; 创建指定数量的元素 vector&lt;int&gt; arrays5(15,-200);创建15个int类型的元素，每个元素都是-200。(不给初值就给默认初始值为0) vector&lt;string&gt; arrays6(5,&quot;hello&quot;);同上。 多种初始化方式 vector&lt;int&gt; arrays7{10};初始化，给一个元素，该元素数据是10. vector arrays8{“hello”};同上。 vector arrays8{10};分配10个string类型的数据都为“”(空串)。 因为10是整型，string类型不匹配所以分配10个元素空间作处理。 注意：要想正常的通过{}进行初始化，那么{}里边的值的类型，必须跟vector类型相同。 vector对象的操作 最常用的是不清楚具体元素数量，通过vector动态增加/简述，故一般使用前先创建一个空容器。vector&lt;int&gt; arrays 具体操作： 判断容器是否为空(bool) arrays.empty() 在容器末尾添加一个元素 arrays.push_back(int num) 返回容器总长度(元素个数) arrays.size() 清空容器 arrays.clear() 可以类似数组一样的用法(下标从0开始) arrays[n] 赋值 vector&lt;int&gt; arrays2; arrays2 = arrays; 注意：这里是类似普通数据类型的赋值一样，不是拷贝！ 123vector&lt;int&gt; arrays2; arrays2 = arrays;//此时array2里的 元素 及 元素个数 跟arrays一样。array2 = &#123;12,34,55,67&#125;//此时array2长度变为4，元素分别是12,34,55,67 相等 两个vector相等，首先元素要相同，对应位置的元素相同。 for循环遍历 for(auto &amp; v: arrays){} for(vector&lt;int&gt; v: arrays){} for遍历一些注意点： 1234for(auto v:arrays)&#123;//千万不要这样使用！！！ arrays.push_back(88);//在遍历的时候再往里面插入新元素，会导致arrays结构混乱 cout &lt;&lt; v &lt;&lt; endl;&#125; 原因：因为遍历的时候会记录arrays最后一个值的地址，如果插入新的值，会照成地址紊乱，输出乱值。 结论：千万不要在for遍历语句或类似操作中，改变遍历源的数值（删除/增加都不可以），调试找bug的时候会非常难发现。 —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（3.2）顺序栈的实现]]></title>
    <url>%2F2019%2F06%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%883-2%EF%BC%89%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[顺序栈的实现与算法思路（以char数据类型为例） 入栈push(char e)； 思路：在栈未满的情况下，直接对top(栈顶)指针指向的地址内容进行赋值，修改完毕后，直接top++移动栈顶至下一个位置。如果栈满则调用扩容操作。 具体实现： 1234567bool SqStack::push(char e) &#123; if ((top - data) == capacity)//容量满了就进行扩容 realloc(); *top = e; top++;//直接修改并移动top指针 return true;&#125; 出栈pop(); 思路：在没有空栈的情况下，直接让top自减一。 具体实现： 1234567bool SqStack::pop() &#123; if (top == data)//判断是否空栈。 return false; top--; return true; &#125; 顺序栈的实现情况 出栈(完成) push(char e) 入栈(完成) pop() 扩容(完成) realloc() 遍历(完成) Traverse(void(*fb)(char&amp; e)) 获得栈顶数据(完成) GetTop() 是否为空栈(完成) IsStackEmpty() 获得栈总容量(完成) GetCapacity() 具体代码： 123456789101112131415161718192021222324252627282930313233343536//Sqstack.h#ifndef _SQSTACK_H_#define _SQSTACK_H_ class SqStack &#123; char* top = nullptr; char* data = nullptr; int capacity;public: /*构造函数*/ SqStack(int c = 5); /*入栈操作*/ bool push(char e); /*出栈操作*/ bool pop(); /*遍历*/ void Traverse(void(*fb)(char&amp;e)); char GetTop(); bool IsStackEmpty(); int GetCapacity();private: /*扩容*/ bool realloc();&#125;; /*打印*/ void Print(char&amp; e);#endif // !_SQSTACK_H_ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//Sqstack.cpp#include&lt;iostream&gt;#include"Sqstack.h"using namespace std;/*构造函数*/SqStack::SqStack(int c) &#123; capacity = c;//默认给一个初值 data = new char[capacity]; top = data;&#125;/*扩容*/bool SqStack::realloc() &#123; char* n_data = new char[2 * capacity]; for (int i = 0; i &lt; capacity; i++) &#123; n_data[i] = data[i]; &#125; delete[]data; data = n_data; top = data + capacity;//这里要注意top也有重新赋值新的地址 capacity *= 2; cout &lt;&lt; "扩容成功！！" &lt;&lt; endl; return true;&#125;/*入栈操作*/bool SqStack::push(char e) &#123; if ((top - data) == capacity) realloc(); *top = e; top++; return true;&#125;/*出栈操作*/bool SqStack::pop() &#123; if (top == data) return false; top--; return true; &#125;/*遍历*/void SqStack::Traverse(void(*fb)(char&amp; e)) &#123; for (int i = 0; i &lt; top - data; i++) &#123; fb(data[i]); &#125; &#125;/*获得栈顶元素*/char SqStack::GetTop() &#123; return*(top - 1);&#125;/*判断是否空栈*/bool SqStack::IsStackEmpty() &#123; if (top == data) return true; return false;&#125;/*获得容量*/int SqStack::GetCapacity() &#123; return capacity;&#125;/*打印*/ void Print(char&amp; e) &#123; cout &lt;&lt; e &lt;&lt; " "; &#125; 123456789101112131415161718192021222324252627//main.cpp#include&lt;iostream&gt;#include"Sqstack.h"using namespace std;int main() &#123; SqStack stack; cout &lt;&lt; "入栈一个数据a" &lt;&lt; endl; stack.push('a'); stack.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "入栈一个数据b" &lt;&lt; endl; stack.push('b'); stack.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "入栈一个数据c" &lt;&lt; endl; stack.push('c'); stack.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "入栈一个数据d" &lt;&lt; endl; stack.push('d'); stack.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "入栈一个数据e" &lt;&lt; endl; stack.push('e'); stack.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "入栈一个数据f" &lt;&lt; endl; stack.push('f'); stack.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "出栈一个数据" &lt;&lt; endl; stack.pop(); stack.Traverse(Print); cout &lt;&lt; endl; &#125; —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（3.1）栈]]></title>
    <url>%2F2019%2F06%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%883-1%EF%BC%89%E6%A0%88%2F</url>
    <content type="text"><![CDATA[初识栈 定义：栈(stack)是限定仅在表尾插入和删除操作的线性表。 允许插入和删除的一段称为栈顶(top),另一段称为栈底(bottom)。 不含任何数据元素的栈称为空栈。 特点： 先进后出 后进先出 **注意：** 栈又被称为后进先出(Last in First out)的线性表 栈的插入操作，被称为进栈，也称压栈、入栈(push) 栈的删除操作也称出栈，也称为弹栈(pop) 示意图： 栈的抽象数据类型 ADT 栈(Stack) Data 栈的数据对象集合为{a1,a2,a3,…,an},每一个元素的类型均为同一个数据类型。其中除了第一个数据为，每个元素有且只有一个直接前驱元素，除了最后一个数据外，每个元素有且只有一个直接的后继元素。数据元素之间的关系是一对一的关系， Operation InitStack；初始化，创建一个空栈 destoryStack; 销毁栈 StackEmpty；判断是否为空 clearStack； 清空栈 getTop；获得栈顶元素 push 压栈 pop 出栈 stacklength；获得栈的长度 endADT 注意：栈本身就是一个线性表结构、线性表的顺序储存和链式存储，对于栈来说也同样适用 —（本文未完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（1.4）函数新特性、const关键字精解]]></title>
    <url>%2F2019%2F06%2F23%2FC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%881-4%EF%BC%89%E5%87%BD%E6%95%B0%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%81const%E5%85%B3%E9%94%AE%E5%AD%97%E7%B2%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[函数 函数定义中，形参如果不会使用，则可以不给形参变量名，只给数据类型。 例如：int func(int a,int) 函数定义只能有一个，函数声明可以有多个。 其余概念： 函数声明是可以只有形参类型，没有形参名。 函数组织： 函数声明在头文件中。 函数定义单独在一个cpp文件中。(内联函数除外) 注意:在头文件定义函数时容易出现函数重复定义的报错。 函数新特性： 以往的函数是 [^前置返回类型]: 把函数返回类型放在函数之前，这种写法，叫前置返回类型。 `` 123void func(int a)&#123;//前置返回类型 return;&#125; 新版的可以由后置返回类型即：返回值写在函数后边 123auto func(int a)-&gt;int&#123;//后置返回类型 return a;&#125; 前面放auto,表示函数返回类型放在参数列表之后，而放在参数列表之后的返回类型是通过-&gt;开始的。 内联函数(inline关键字) 在函数前加inline使其变为内联函数。例：inline void func() 只在定义前面加关键字inline。 内联函数干了什么？ 使编译器在编译时能够识别内联函数里的内容并尝试把其与被调用的地方进行替换，此举节省了函数调用带来的消耗，从而可以提供程序运行效率。 使用场合： 当函数体很小，但调用很频繁的这种函数，应使用内联函数以提高效率。 与其他函数定义不同的是：内联函数的定义应该放在头文件。 使用不当： 不应该把太长的代码块的函数变为内联函数。 不用把有循环，函数递归的函数变为内联函数。 这些容易时代码膨胀,且如果在内联函数运行的时间比调用函数更慢，内联函数就没有意义了。 为什么要把内联函数定义在头文件：内联函数是为了告诉编译器标识的函数可以再调用时进行替换，只有这样做编译器才会把函数体里面的内容直接替换到调用的地方，如果你在函数声明的前面加inline编译器就不能直接获得函数体里面的内容，所以内联函数因在函数定义前加关键字inline。 正因为这样才建议把内联函数定义在头文件中，在每个调用该inline函数的文件中包含该头文件。这种方法保证了每个inline函数只有一个定义，且程序员无需复制代码，并且不可能在程序的生命周期中引起无意的不匹配的事情。 函数杂合用法总结：void函数： 函数返回类型为void，表示函数不返回任何类型。但是可以调用一个返回值类型为void，让其成为另一个返回值为void的函数的返回值。 123456789void func1()&#123; cout &lt;&lt; "hello" &lt;&lt; endl; return;&#125;void func2()&#123; return func1();//返回一个另一个返回值为void的函数&#125; 函数返回指针： 这是一个及其错误且危险的写法，即通过函数返回函数里面一个临时变量的地址。函数中的变量的生命期只限于函数内部，当函数结束时临时变量直接被系统回收，但这种情况，把已回收的临时变量的地址在外面继续被使用。即使用了野指针里面的值，用了不是属于自己的地址里的数据（使程序崩溃）。 123456789int* myfunc()&#123; int t = 9; return &amp;t;&#125;int main()&#123; int* p = myfunc(); *p = 6;&#125; 函数返回引用： 同上。如果在函数外头用一个引用来获取这个函数的返回值，就会造成把系统已回收的内存进行使用这是很危险的。但如果你是用一个非引用变量来接收其返回值，只是单单获取它的值而不是得到它的地址。所以这样做是安全的 123456789101112int&amp; myfunc()&#123; int t = 9; return t;&#125;int main()&#123; int&amp; p = myfunc(); p = 6;//错误用法造成t和p的地址是相同的，即：&amp;p = &amp;t 。修改了被回收的地址中的值。 int k = myfunc(); k = 3;//安全，因为k只接收到值，即&amp;k != &amp;t&#125; const关键字： const char*、char const *、char* const的区别 const char*： 这样定义是对指针指向的地址定义为常量。即指针可以发生变化，但不能修改指针指向的值。 123456789101112int main()&#123; char str[]&#123; "hello" &#125;; const char* a = str; a++;//允许，指针地址值可以发生变化 *a = 'f';//报错，不能修改内容 /*不仅仅是char，其余类型都是如此*/ int b = 4; int const * p = &amp;b; p++;&#125; char const*: 等价于const char* char*const 与上面相反，这样定义的是指针常量，即指针不能进行移动，但可以修改指针所指向的数值。 123456int main()&#123; int a = 4; int * const b = &amp;a; b++;//报错，不能修改指针指向的地址 *b = 9；//允许，可以修改指针地址的内容。&#125; 扩展：const char* const 这个是const char* 与char* const的结合，即：不能修改指针指向的地址里面的内容，也不能改变指针的指向。 const char&amp; 这样定义使这个引用只能绑在一个变量上，而不能再次切换绑定对象，且不能修改其内容值。 12345678int main()&#123; int a = 4; int c = 6; const int&amp; b = a; b = c;//报错，不能改变绑定对象 b = 2;//报错，不能修改其内容 &#125; —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.9）顺序存储结构与链式存储结构的逆置]]></title>
    <url>%2F2019%2F06%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-9%EF%BC%89%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E9%80%86%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[顺序结构的逆置算法与思路： 夹逼法： 思路：通过对数组头部和尾部相互对调并向中间靠近。 实现：(假设以整型为数据类型实现) 12345678910//length为顺序表总长度。bool Convert()&#123; int temp;//用来对换位置时使用的临时变量 for(int i = 0; i &lt; length/2; i++)&#123;//注意：length要除于2！！！！length要除于2！！！！ temp = datas[i]; datas[i] = datas[length - 1 - i];//前后换位置并向中间靠近 datas[length - 1 - i] = temp; &#125; return true;&#125; 注意：这里的length是要除于2的，因为只需向中间靠近即可而不是再往中间远离。即：移动的范围只是数组长度的一半。 算法优化： 12345678910//length为顺序表总长度。bool Convert()&#123; int temp;//用来对换位置时使用的临时变量 for(int i = 0 ，j = length - 1; i &lt; j; i++,j--)&#123; temp = datas[i]; datas[i] = datas[j];//前后换位置并向中间靠近 datas[j] = temp; &#125; return true;&#125; 此方法更能体现夹逼法。 链式存储结构的逆置算法与思路： 思路：把头结点和数据结点断开，然后把数据结点一个个前插进链表。（循环链表和单向链表均适用）,具体做法先让一个结点指针p保存第一个数据的地址，然后让头结点的next指针归零（即：使其与数据结点断开），开始循环：让一个临时指针指向p的下一个数据的地址，然后把这个第一个数据插入头结点后面（此时p指向为第一个数据的地址），即：p-&gt;next = head-&gt;next;head -&gt;next = p;其次移动指针p到下一个数据，这里就要运用到一开始的临时指针了。循环上面的操作，直到把所有数据都前插完毕。 实现1(单向链表)： 12345678910111213141516bool Convert()&#123; LNode* p = head-&gt;next; LNode* temp = nullptr;//临时指针 head-&gt;next = nullptr; while(p)&#123; temp = p-&gt;next;//获取下一个数据的值 p-&gt;next = head-&gt;next;//前插 head-&gt;next = p; p = temp;//移动指针到下一个数据 &#125; return true;&#125; 实现2(循环链表) 12345678910111213141516bool Convert()&#123; LNode* p = head-&gt;next; LNode* temp = nullptr;//临时指针 head-&gt;next = nullptr; while(p!=head)&#123; temp = p-&gt;next;//获取下一个数据的值 p-&gt;next = head-&gt;next;//前插 head-&gt;next = p; p = temp;//移动指针到下一个数据 &#125; return true;&#125; 前后只是循环条件发生变化。 —（本文完）&lt;原创&gt;&lt;待增添修改&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.8）线性表的顺序存储结构和链式存储结构之间的比较]]></title>
    <url>%2F2019%2F06%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-8%EF%BC%89%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[顺序结构与链式结构的比较： 顺序结构 链式结构 按序号下标读取 直接读取通过A[index]即可获的数据+++ 要从头开始找，找的下标才能获取数据—- 内存实验 要先规定好顺序结构的长度，可能没有利用好空间或空间不够用，不够用时还要扩容可能没有足够的空间或多出空间—- 按需要分配，想要一个就一个可利用很小的碎片空间+++ 插入元素 插入一个元素需要不断移动后面的元素，速度慢，消耗相比大—- 直接插入，速度快，消耗相比小+++ 删除 需要移动元素—- 直接删除+++ —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-（1.3）范围for语句、动态分配、nullptr]]></title>
    <url>%2F2019%2F06%2F21%2FC%2B%2B%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%881-3%EF%BC%89%E8%8C%83%E5%9B%B4for%E8%AF%AD%E5%8F%A5%EF%BC%8C%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[For循环新特性： 可以使用for语句进行遍历数组（c++11新特性） 123456789101112131415#include&lt;iostream&gt;using namespace std;int main()&#123; int nums[] = &#123;1,2,5,6,8,21&#125;; int nums2[]&#123;33,1,75,45&#125;;//数组的新定义方法。 for(auto x:nums)&#123; cout &lt;&lt; x &lt;&lt; " "; &#125; cout &lt;&lt; endl &lt;&lt; endl;//auto自动判断数组类型。 for(auto x:nums2)&#123; cout &lt;&lt; x &lt;&lt; " "; &#125;&#125; 运行效果： 优化： 很显然通过这个for循环遍历数组是用过把数组内的每一个元素复制进x里面进行输出的。这里的复制操作将消耗一部分的效率。为提高程序运行效率这里可以采用引用来进行遍历。 123for(auto&amp;x : nums)&#123; cout &lt;&lt; x &lt;&lt; " ";&#125; 动态分配内存基本概念： 简述c语言与c++语言的内存分配不同： | C语言 | C++语言 || ——————————————— | —————————————————————- || 程序区、静态存储区、动态存储区 | 堆、栈、全局/静态区、常量存储区、程序代码区 | 其中C++语言： 栈：一般函数内的局部变量都会存在这。例如 int a = 4 此时这个a就是存储在栈区的（由编译器自动完成分配和释放，速度快，有限）。 堆：由程序员自己分配和释放。用new/malloc分配，delete/free释放。忘记释放后，当程序结束后才会被系统收回。 全局/静态存储区：存储全局变量和static变量，程序结束后被回收。 常量存储区： const定义的和一些字符串。 程序代码区 堆和栈的不同用途和区别 | 栈 | 堆 || ———————————————————— | —————————————————————————————— || 空间有限，分配速度快，程序员控制不了 | 只要不超出时间拥有的物理内存，也在操作系统运行你嫩功能分配最大内存大小之内，都可以分配。分配速度慢，好处是灵活。随时分配随时释放。 | malloc和free 这两个是c语言中对内存动态处理的函数（c++中的new和delete是关键字） void *malloc(int Numbytes): Numbytes:要分配的字节数。分配成功返回被分配内存的指针，分配失败则返回NULL； 1int* p = malloc() void free (void *FirstByte): 将之前malloc分配的内存空间还给程序。 12345678int* p = NULL;p = (int*)malloc(4*sizeof(int));if(p!=NULL)&#123; //分配成功 *p = 5; cout &lt;&lt; *p &lt;&lt; endl; free(p);&#125; 补充：字符串拷贝函数 strcpy(char*p,char*s)与strcpy_s(char*p,int size,char*s) strcpy()函数不安全：当指针s的字符串的长度大于指针p分配的内存时仍然继续往里进行拷贝字符串且不报错，使程序变的不再稳定。 strcpy_s()函数给定了一个size来限定指针s的长度，如果实际指针s的字符串长度大于size那么程序就会弹窗报错。 使用strcpy函数 123456789101112#include&lt;iostream&gt;using namespace std;int main() &#123; char* p = NULL; p = (char*) malloc(20 * sizeof(char)); strcpy(p, "Hello ShuHaoHwang"); cout &lt;&lt; p &lt;&lt; endl;&#125; 结果编译不通过并报错： 使用strcpy_s函数 情况1：源字符串实际长度小于size值。 123456789101112#include&lt;iostream&gt;using namespace std;int main() &#123; char* p = NULL; p = (char*) malloc(20 * sizeof(char)); strcpy_s(p, 2,"Hello ShuHaoHwang"); cout &lt;&lt; p &lt;&lt; endl;&#125; 结果运行报错： 情况2：正常情况。 123456789101112#include&lt;iostream&gt;using namespace std;int main() &#123; char* p = NULL; p = (char*) malloc(20 * sizeof(char)); strcpy_s(p, 20,"Hello ShuHaoHwang"); cout &lt;&lt; p &lt;&lt; endl;&#125; 正常运行： new和delete new/delete和malloc/free一样干了同样的事——分配和释放空间，同时new，delete还干了更多事情。 new与delete配对使用。malloc与free配对使用。 不要重复释放指针。 new的一般使用格式： 指针变量名 = new 类型; int* p = new int; 指针类型名 = new 类型(初始值)； int* p= new int(2);//给初始值 指针类型名 = new 类型[内存单元个数] (数组); int* p = new int[10]; 注意:当用指针分配一个数组的时候用 delete[] 指针名 mallo/free与new/delete的区别： malloc/free new/delete 只做了分配和释放内存工作 除了分配和释放内存，还进行了初始化工作(new)，和清理工作(delete)等 nullptr： nullptr是意为空指针。先看一段代码： 1234567891011121314#include&lt;iostream&gt;using namespace std;int main() &#123; int* a = 0; int* b = NULL; int* c = nullptr; cout &lt;&lt; "0 == NULL? " &lt;&lt; (a == b) &lt;&lt; endl &lt;&lt; "0 == nullptr? " &lt;&lt; (a == c) &lt;&lt; endl &lt;&lt; "NULL == nullptr? " &lt;&lt; (b == c) &lt;&lt; endl;&#125; 实验结果： 从实验结果发现对于指针来说他们三者并没有不同，都代表这空指针指向0x000000，但实质上nullptr是一个指针。NULL是一个数字它等于0；即： 12int p = NULL;//成立！p的值为0。int a = nullptr;//报错：数据类型不一致。 根据下面的代码探索nullptr和NULL： 12345678910#include&lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; typeid(NULL).name() &lt;&lt; endl; cout &lt;&lt; typeid(nullptr).name() &lt;&lt; endl; &#125; 提示:typeid(数据名).name():返回的是该数据的数据类型 实验结果： nullptr与NULL数据类型不同。nullptr本质上是一个指针，引入这个关键字的目的是区别代表数字时的NULL和代表指针空地址时的NULL防止混淆。 实际用法：在重载函数时nullptr会被识别成指针从而调用指针类型的重载 结论：对于指针的初始化，以往用到和指针有关的NULL的场合，能用nullptr的大家全部用nullptr取代NULL。 —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.7）双向链表]]></title>
    <url>%2F2019%2F06%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-7%EF%BC%89%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[双向链表 与单向链表的不同之处： 单向链表 双向链表 只知道后继节点，不知道前驱节点。每次查找只能从头开始查找。 相比单向链表增加了一个前驱指针，使前驱节点很快就能被找到 双向链表由于有了前后指针。可以使其从前往后走，也可以从后往前走。 根据双向链表具有前后两个指针的这个特性 在插入算法和删除算法中都有很好的优势 插入算法： 12345678910111213141516171819202122bool InsertElement(int index, T e) &#123; LNode* node = new LNode(); LNode* p = head; node-&gt;data = e; int j = 0; while (j &lt; index)//直接定位到要插入的位置即可 &#123; p = p-&gt;next; j++; &#125; p-&gt;prior-&gt;next = node;//指定位置的前一个数据的next指针指向新插入的数据地址 node-&gt;prior = p-&gt;prior;//新插入数据的prior指针指向原来位置数据的前一个数据地址 p-&gt;prior = node;//插入位置的前一个数据更变为新插入的数据地址 node-&gt;next = p;//新插入数据的next指针指向插入位置的地址 length++;//链表总长度加1 return true; &#125; 删除算法 12345678910111213141516bool DeleteElement(int index) &#123; LNode* p = head; int j = 0; while (j &lt; index)//直接定位到要删除的数据结点 &#123; p = p-&gt;next; j++; &#125; p-&gt;prior-&gt;next = p-&gt;next;//待删除的数据的前一个数据的next指针指向待删除数据的下一个数据的地址 p-&gt;next-&gt;prior = p-&gt;prior;//待删除数据的下一个数据的prior指针指向待删除数据的前一个数据 delete p;//释放待删除数据的空间 return true; &#125; 删除算法即可以直接跳过待删除数据结点。 其他测试代码详情：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;class BSLkList &#123; struct LNode &#123; T data; LNode* next; LNode* prior; &#125;; LNode* head; LNode* rear; int length;public: BSLkList() &#123; head = new LNode(); head-&gt;next = head; head-&gt;prior = head; rear = head; length = 0; &#125; /*后插操作*/ bool Push_back(T e) &#123; length++; LNode* node = new LNode(); LNode* p = head; if (!node) return false; while (p-&gt;next != head) &#123; p = p-&gt;next; &#125; node-&gt;data = e; p-&gt;next = node; node-&gt;next = head; node-&gt;prior = p; rear = node; return true; &#125; /*插入操作*/ bool InsertElement(int index, T e) &#123; LNode* node = new LNode(); LNode* p = head; node-&gt;data = e; int j = 0; while (j &lt; index) &#123; p = p-&gt;next; j++; &#125; p-&gt;prior-&gt;next = node; node-&gt;prior = p-&gt;prior; p-&gt;prior = node; node-&gt;next = p; length++; return true; &#125; /*删除操作*/ bool DeleteElement(int index) &#123; LNode* p = head; int j = 0; while (j &lt; index) &#123; p = p-&gt;next; j++; &#125; p-&gt;prior-&gt;next = p-&gt;next; p-&gt;next-&gt;prior = p-&gt;prior; delete p; return true; &#125; /*遍历操作*/ void Traverse(void(*fb)(T&amp; e)) &#123; LNode* p = head-&gt;next; while (p != head) &#123; fb(p-&gt;data); p = p-&gt;next; &#125; &#125; /*指定位置遍历操作*/ void Traverse(T e, void(*fb)(T&amp; e)) &#123; LNode* s = GetDataAddress(e); LNode* p = s; do &#123; if(s!=head) fb(s-&gt;data); s = s-&gt;next; &#125; while (s != p); &#125; private: /*获得指定结点地址操作*/ LNode* GetDataAddress(T e) &#123; LNode* p = head; while (p-&gt;next != head) &#123; if (p-&gt;data == e) return p; p = p-&gt;next; &#125; return NULL; &#125;&#125;;template&lt;typename T&gt;void Print(T&amp;e) &#123; cout &lt;&lt; e &lt;&lt; " ";&#125;int main() &#123; BSLkList&lt;char&gt; list; cout &lt;&lt; "后插入了一个A数据" &lt;&lt; endl; list.Push_back('A'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后插入了一个B数据" &lt;&lt; endl; list.Push_back('B'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后插入了一个C数据" &lt;&lt; endl; list.Push_back('C'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; "在2号位置插入了一个p数据" &lt;&lt; endl; list.InsertElement(2, 'p'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "在2号位置插入了一个p数据" &lt;&lt; endl; list.InsertElement(2, 'p'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; "删除了3号位置的数据" &lt;&lt; endl; list.DeleteElement(3); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "删除了1号位置的数据" &lt;&lt; endl; list.DeleteElement(1); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; "从B数据开始遍历" &lt;&lt; endl; list.Traverse('B', Print); cout &lt;&lt; endl;;&#125; 测试效果图： —(本文完)&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.6.1）附加：循环链表的优点之从指定结点开始遍历]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-6-1%EF%BC%89%E9%99%84%E5%8A%A0%EF%BC%9A%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E7%82%B9%E4%B9%8B%E4%BB%8E%E6%8C%87%E5%AE%9A%E7%BB%93%E7%82%B9%E5%BC%80%E5%A7%8B%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[体现循环链表的优点之从指定结点开始遍历​ 上一篇总结文章介绍了循环链表的基本概念和个人理解，但我觉得能很好区分非循环链表和循环链表初了链表的合并，还有一个就是循环链表可以从指定的结点开始遍历整个链表，这是非循环链表所做不到的。非循环链表每次遍历只能从头一个个开始遍历每一个元素，而循环链表就不同了，因为它的尾部是与头部相连的，这样就可以实现从某一个结点开始就可以遍历到链表每一个结点上，大大提高了效率。 这里通过遍历函数来体现这一特性。 123456789101112131415161718192021222324252627282930313233//查找链表中的某一个元素并获得它的地址LNode* GetDataAddress(T e) &#123; LNode* p = head-&gt;next; while (p != head) &#123; if (p-&gt;data == e) return p; p = p-&gt;next; &#125; return NULL; &#125;/*从某一个结点进行遍历*/ void Traverse(T e,void(*fb)(T&amp; t)) &#123; LNode* p = GetDataAddress(e);//获得指定结点的地址 LNode* q = p; if (!p) &#123; cout &lt;&lt; "链表为空" &lt;&lt; endl; return; &#125; do &#123; if(p!=head)//越过头结点 fb(p-&gt;data); p = p-&gt;next; &#125; while (p != q); &#125; 思路：先获得指定结点的地址先记录下来，并再用一个指针记下这个位置（便于判断）。其次这里使用的是do-while循环结构（使用do-while循环可以避免while循环漏遍历一个指定结点的数据），先调用函数指针的内容，然后移动指针p。直到指针p再次等于原来的指定结点的地址就停止。 具体实验代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;class CLkList&#123; struct LNode &#123; T data;//数据 LNode* next;//指向下一个数据的指针 &#125;; LNode* head;//头指针 LNode* rear;//尾指针 int length;public: /*构造函数*/ CLkList() &#123; head = new LNode(); length = 0; if (!head)throw"No Memory";//若没有new出来就抛出异常 head-&gt;next = head; rear = head-&gt;next; &#125; /*后插入操作*/ bool push_back(T e) &#123; length++; LNode* p = head-&gt;next; LNode* q = new LNode(); while (p-&gt;next != head) &#123; p = p-&gt;next; &#125; if (!p)return false; q-&gt;data = e;//进行data赋值 rear = q; q-&gt;next = head; p-&gt;next = q;//原最后一个元素数据的next指向这个新插入的空间地址 //length++; return true; &#125; /*获得指定结点地址操作*/ LNode* GetDataAddress(T e) &#123; LNode* p = head-&gt;next; while (p != head) &#123; if (p-&gt;data == e) return p; p = p-&gt;next; &#125; return NULL; &#125; /*遍历操作*/ void Traverse(void(*fb)(T &amp; t)) &#123; LNode* p = head-&gt;next;//从头结点开始遍历每一个元素的data while (p != head) &#123; fb(p-&gt;data); p = p-&gt;next; &#125; &#125; /*从某一个结点进行遍历*/ void Traverse(T e,void(*fb)(T&amp; t)) &#123; LNode* p = GetDataAddress(e);//从头结点开始遍历每一个元素的data LNode* q = p; if (!p) &#123; cout &lt;&lt; "链表为空" &lt;&lt; endl; return; &#125; do &#123; if(p!=head) fb(p-&gt;data); p = p-&gt;next; &#125; while (p != q); &#125;private:&#125;;template&lt;typename T&gt;void Print(T&amp; e) &#123; cout &lt;&lt; e &lt;&lt; " ";&#125;int main() &#123; CLkList&lt;char&gt; list; cout &lt;&lt; "后面插入了一个a数据" &lt;&lt; endl; list.push_back('a'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个b数据" &lt;&lt; endl; list.push_back('b'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个c数据" &lt;&lt; endl; list.push_back('c'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个d数据" &lt;&lt; endl; list.push_back('d'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "从b数据开始遍历链表； " &lt;&lt; endl; list.Traverse('b', Print); cout &lt;&lt; endl; cout &lt;&lt; "从c数据开始遍历链表； " &lt;&lt; endl; list.Traverse('c', Print); cout &lt;&lt; endl; &#125; 运行结果： 小结：​ 这里只是单单用遍历体现了循环链表的这个特点。 ​ 其实不单单在遍历操作上，这个更可以在查找操作上体现出这个优点，例如：在指定结点开始寻找其后的某个值、删除操作也可以运用上。 —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.6）循环链表（单向链表）、清空链表与销毁链表]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882-6%EF%BC%89%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[循环链表 相较于非循环链表 在非循环链表中，最后一个元素的next指针是空指针，造成浪费。 每次寻找后继指针的时候都要重新从头开始找。 循环链表 尾指针直接指向表头，使最后一个元素的next指针被利用起来。 从每一个元素开始都能遍历表中每一个元素。 便于类似于链表合并这样的算法实现。 其他不同： 循环链表与非循环链表的判断条件发生了变化 判断的具体解释（循环链表） 判断到前驱结点： 1234while (p-&gt;next != head) &#123; p = p-&gt;next; &#125; ​ 因为最后一个结点的next指针不再是空指针而是一个指向head的指针，所以在while循环中如果p的next指针下一个为head指针那么这时指针p就定位到head的前驱指针了。 判断到头结点： 1234while (p != head) &#123; p = p-&gt;next; &#125; ​ 这个也很好判断，不断移动指针p当等于头结点时就跳出循环，此时p定位到头结点。 循环链表的尾指针 循环链表通常是有一个尾指针的它指向的是最后一个元素的地址。 尾指针的好处： 找head指针非常方便。rear-&gt;next的值便是head。 便于链表的合并。 代码实现空表时的尾指针： 1234567891011121314151617181920212223class CLkList&#123; struct LNode &#123; T data;//数据 LNode* next;//指向下一个数据的指针 &#125;; LNode* head;//头指针 LNode* rear;//尾指针 int length;public: /*构造函数*/ CLkList() &#123; head = new LNode(); length = 0; head-&gt;next = head; rear = head-&gt;next;//空表时的尾指针 &#125;&#125; 当插入一个元素后尾指针的变化 123456789101112131415161718192021//从链表最后面插入元素bool push_back(T e) &#123; length++; LNode* p = head-&gt;next; LNode* q = new LNode(); while (p-&gt;next != head) &#123; p = p-&gt;next; &#125; if (!p)return false; q-&gt;data = e;//进行data赋值 rear = q;//因为是从最后面插入那么此时这个最后一个元素的的地址是尾指针指向的 q-&gt;next = head; p-&gt;next = q;//原最后一个元素数据的next指向这个新插入的空间地址 return true; &#125; 链表合并的实现: 具体思路（链表2合并到链表1）：先获得链表2的头结点的地址（即：链表2的指针head）然后让链表1的head指针指向链表2的指针head-&gt;next指向的地址（即：链表2的第一个元素的地址），然后让链表2的指针rear（尾指针）指向链表1的head-&gt;指向的地址（即指向链表1的第一个元素）最后delete 链表2的head指针。完成合并操作。 合并前： 合并后： 具体实现： 1234567891011121314bool ListCombine(CLkList* s) &#123; LNode* t_head_of_s = s-&gt;head;//获得链表2的head指针 s-&gt;rear-&gt;next = head-&gt;next;//让链表2的尾指针指向链表1的第一个元素 head-&gt;next = t_head_of_s-&gt;next;//让链表1的head-&gt;next指针指向链表1第一个元素 delete t_head_of_s;//释放原链表2的head指针 return true;&#125; 循环链表具体代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;class CLkList&#123; struct LNode &#123; T data;//数据 LNode* next;//指向下一个数据的指针 &#125;; LNode* head;//头指针 LNode* rear; int length;public: /*构造函数*/ CLkList() &#123; head = new LNode(); length = 0; if (!head)throw"No Memory";//若没有new出来就抛出异常 head-&gt;next = head; rear = head-&gt;next; &#125; /*往后插入操作*/ bool push_back(T e) &#123; length++; LNode* p = head-&gt;next; LNode* q = new LNode(); while (p-&gt;next != head) &#123; p = p-&gt;next; &#125; if (!p)return false; q-&gt;data = e;//进行data赋值 rear = q; q-&gt;next = head; p-&gt;next = q;//原最后一个元素数据的next指向这个新插入的空间地址 //length++; return true; &#125; /*获得链表长度*/ int GetLength() &#123; return length; &#125; /*插入元素操作*/ bool InsertElement(int index,T e) &#123; LNode* p = head; LNode* q = new LNode(); int j = 0; while ( j &lt; index-1) &#123; p = p-&gt;next; j++; &#125; q-&gt;data = e; q-&gt;next = p-&gt;next; p -&gt; next = q; length++; return true; &#125; /*删除操作（下标型）*/ bool DeleteElement(int index) &#123; LNode* p = head; LNode* q = head-&gt;next; int j = 0; while (j &lt; index-1) &#123; p = p -&gt; next; q = q -&gt; next; j++; &#125; p-&gt;next = q-&gt;next; delete q; length--; return true; &#125; /*删除操作（找值型）*/ bool DeleteElement(T e) &#123; LNode* p = head; LNode* q = head-&gt;next; while (q != head) &#123; if (q-&gt;data == e) &#123; p-&gt;next = q-&gt;next; delete q; length--; return true; &#125; p = p-&gt;next; q = q-&gt;next; &#125; return false; &#125; /*清空链表操作*/ bool ListClean() &#123; length = 0; LNode* p = head-&gt;next; LNode* q; while (p-&gt;next != head)//定位到头结点之前，清空初头结点的外的其他数据空间 &#123; q = p -&gt; next; delete p; p = q; &#125; head-&gt;next = head; return true; &#125; /*合并操作*/ bool ListCombine(CLkList* s) &#123; LNode* t_head_of_s = s-&gt;head; s-&gt;rear-&gt;next = head-&gt;next; head-&gt;next = t_head_of_s-&gt;next; length += s-&gt;length; delete s-&gt;head; return true; &#125; /*遍历操作*/ void Traverse(void(*fb)(T &amp; t)) &#123; LNode* p = head-&gt;next;//从头结点开始遍历每一个元素的data while (p != head) &#123; fb(p-&gt;data); p = p-&gt;next; &#125; &#125;private:&#125;;template&lt;typename T&gt;void Print(T&amp; e) &#123; cout &lt;&lt; e &lt;&lt; " ";&#125;int main() &#123; CLkList&lt;char&gt; list; cout &lt;&lt; "后面插入了一个a数据" &lt;&lt; endl; list.push_back('a'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个b数据" &lt;&lt; endl; list.push_back('b'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个c数据" &lt;&lt; endl; list.push_back('c'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个d数据" &lt;&lt; endl; list.push_back('d'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "在2号位置插入p数据" &lt;&lt; endl; list.InsertElement(2, 'p'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "删除测试 " &lt;&lt; endl; cout &lt;&lt; "2号位置的数据被删除了" &lt;&lt; endl; list.DeleteElement(2); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "数据a删除了" &lt;&lt; endl; list.DeleteElement('a'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "数据b删除了" &lt;&lt; endl; list.DeleteElement('b'); list.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "list2: " &lt;&lt; endl; CLkList&lt;char&gt; list2; cout &lt;&lt; "后面插入了一个v数据" &lt;&lt; endl; list2.push_back('v'); list2.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个n数据" &lt;&lt; endl; list2.push_back('n'); list2.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后面插入了一个m数据" &lt;&lt; endl; list2.push_back('m'); list2.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "list2合并到list" &lt;&lt; endl; list.ListCombine(&amp;list2); cout &lt;&lt; "合并后：" &lt;&lt; endl; list.Traverse(Print); cout &lt;&lt; endl; //清空list list.ListClean(); cout &lt;&lt; "清空完成" &lt;&lt; endl; &#125; 销毁链表与清空链表的区别： 销毁链表 清空链表 具体解释 包括头结点全部清空全部delete 保留头结点其他数据元素全部delete清空 产生的后果 头指针丢失，链表无法使用 清空链表后，保留了头结点，只是元素被清空了（即链表回到初始空表状态）还可以使用。 —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-(1.2)auto、头文件防卫]]></title>
    <url>%2F2019%2F06%2F18%2FC%2B%2B%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-(1.2)auto%E3%80%81%E5%A4%B4%E6%96%87%E4%BB%B6%E9%98%B2%E5%8D%AB%2F</url>
    <content type="text"><![CDATA[Auto auto：变量的自动类型推断。 可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型。（声明时要初始化） 自动推断发生在编译期间，所以使用auto不会造成程序效降低。 头文件防卫式声明 语法： 123456#ifndef _文件名_H#define _文件名_H内容#endif 为什么要用到头文件防卫式声明？ 目的：为了防止头文件中多重、重复定义内容。 情景假设： 假设一个工程里面有两个个头文件.h文件。里面都有自己的内容 123//head1.hint number1 = 8； 123//head2.hint number2 = 5; 1234567891011//main.cpp#include&lt;iostream&gt;#include"head1.h"#include"head2.h"using namespace std;int main()&#123; cout &lt;&lt; number1 &lt;&lt; endl; cout &lt;&lt; number2 &lt;&lt; endl;&#125; 编译运行情况： 假设在head2.h也include了head1.h，且在main.cpp里面也分别include了head1.h和head2.h再进行编译就会出现： 错误原因：出现了number1重复定义的错误，为啥呢？因为在执行main.cpp文件编译的时候已经对head1.h里面的内容进行了编译定义，但到了head2.h的文件的时候又include了head1.h意味着又重复定义了一次head1.h里面的内容从而造成head1.h里的number1重复定义的错误。 如何解决？——对头文件进行防卫式定义 即对head1.h文件编辑 1234567//head1.h#ifndef _HEAD1_H//如果head1.h没有被定义那么就执行下面的内容#define _HEAD1_H//定义head1.hint number1 = 8；#endif//结束如果 当main.cpp执行编译操作的时候head1.h是没有定义的。所以#ifndef下面的内容将被执行即先定义head1.h文件。但到了include”head2.h”的时候发现head2.h里面也有include“head1.h”但此时head1.h已经被定义了，故#ifndef不成立下面的内容就没有被执行了，从而避免了头文件重复定义的情况。 结论：所以以后定义头文件的时候都可以进行防卫式定义然后就可以随便include定义的头文件了避免这些错误了。 —(本文完)&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶学习总结-(1.1)命名空间]]></title>
    <url>%2F2019%2F06%2F17%2FC%2B%2B%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-(1.1)%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[命名空间的基本概念简介基本概念 命名空间就是为了防止名字冲突引入的一种机制。系统中可以定义多个命名空间，每个命名空间都有自己的名字，不可以同名。 可以把命名空间看成一个作业域，在这个命名空间定义的函数，跟你另外一个命名空间里定义的函数，即便同名，也互不影响。 命名空间定义： 1234namespace 命名空间名&#123; void fb()&#123;&#125;//函数 ....&#125; 命名空间的定义可以不连续，甚至可以写在多个文件中，如果以为没有定义这个命名空间，那么相当于定义命名空间，如果已经定义了，那么就算打开这个命名空间并可以往里面添加新成员的声明； 情形 假设同一个工程里面有两个project.cpp和project2.cpp文件并分别给两个程序员去编写，在编写过程中张三和李四都定义了同名、返回值相同、参数也相同的void Print()函数，在编译时将会出现： 找到一个或多个多重定义的符号 void_cdecl Print(void)已在project2.obj中定义的错误 如何去解决这种问题呢？分别去改函数名或许是个好方法，但是如果这样的情况多了起来难免就太麻烦了。这里就可以用命名空间来解决具体： 123456//project1.cppnamespace ZhangSan &#123; void Print() &#123; cout &lt;&lt; "这是张三的Print函数" &lt;&lt; endl; &#125;&#125; 这样就解决了这种重名的问题。如果要调用张三的这个同名函数就可以用 命名空间名::实体名（函数名）的方法调用张三的Print函数 （其中“ : : “是作用域运算符）。 12345int main() &#123; ZhangSan::Print();//张三的 Print();//李四的&#125; 运行情况： 但是每次调用的时候都要用命名空间名::实体名（函数名）的方法岂不是也太麻烦了。 所以这里就要用上using关键字了，只要在头文件引入语句下面加入： using namespace ZhangSan就可以了 1234567891011#include&lt;iostream&gt;#include"project2.h"//张三命名空间定义所在的头文件using namespace std;using namespace ZhangSan;//使用的张三的命名空间int main() &#123; Print();//张三的&#125; 运行情况: —(本文完)&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习总结</tag>
        <tag>C++学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-(2.5)链表存储结构的算法]]></title>
    <url>%2F2019%2F06%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882.5%EF%BC%89%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[链表储存结构 链表（LinkedList） 定义: 每个元素用一个指针（以存储下一个数据的地址）相互串联起来为存储方式的物理存储结构 对应线性表操作： 前插数据元素 Insert_Front() 后插数据元素 Push_back() 插入数据 Insert_Element() 删除数据 Delete_Element() 获得数据 Get() 设置数据 Set() 遍历链表 Traverse() …… 对应一些算法实现思路 插入操作： 思路：先通过移动指针获得要插入位置前一个元素的地址，然后创建一个新的元素空间让要插入的数据对其进行赋值，然后将前一个数据的next指针指向这个新空间的地址，而原来next指针指向的地址赋值给新空间的next指针 具体实现： 123456789101112131415bool InsertElement(int index, T e) &#123; LNode* p = head;//这里的p是指向头结点的指针，目的是要从第一个数据开始往下算下标 int j = 0; while (p &amp;&amp; j &lt; index-1)//定位到要插入元素位置的前一个元素（即：寻找前驱结点） &#123; p = p-&gt;next; ++j; &#125; LNode* s = new LNode();//创建一个链表数据空间 s-&gt;data = e;//把要插入的数据放入这个空间 s-&gt;next = p-&gt;next;//这个新的空间的下一个指针地址是上一个元素的下一个元素地址 p-&gt;next = s;//上一个元素的下一个指针地址变为新空间的地址 return true; &#125; 删除操作： 思路：根据要删除的位置的下标先让一个指针定位到这个位置的前一个元素。这时要先创建一个临时的指针指向将删除的元素的地址（此步目的是获得下一个元素的地址，因为删除后不能获得要删除元素next指针的地址），然后将待删除的元素的前一个元素的next指针等于这个临时指针的next指针，最后delete这个临时指针。 具体实现： 1234567891011121314bool DeleteElement(int index) &#123; LNode* p = head;//定位到头结点 int j = 0;//从第0个元素开始移动指针 while (p &amp;&amp; j &lt; index - 1) &#123;//找到要删除元素数据的前一个位置 p = p-&gt;next; ++j; &#125; LNode* q = p-&gt;next;//用一个临时指针存储要删除数据元素的位置（目的为了获取待删除数据元素的下一个数据元素的位置） p-&gt;next = q-&gt;next;//把前一个数据元素的下一个指针地址存储 delete q;//释放临时指针（即：要删除数据元素）的空间 length--; return true; &#125; 链表存储结构代码实现情况： 前插操作（完成） bool InsertFront(T e) 后插操作（完成） bool push_back(T e) 插入操作（完成） bool InsertElement(int index, T e) 删除操作（完成） bool DeleteElement(int index) 获得操作（完成） bool Get(int index,T&amp; e) 修改操作（完成） bool Set(int index, T e) 遍历操作（完成） void Traverse(void(*fb)(T&amp; t)) 代码详细123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;class LkList&#123; struct LNode &#123; T data;//数据 LNode* next;//指向下一个数据的指针 &#125;; LNode* head;//头指针 int length;public: /*构造函数*/ LkList() &#123; head = new LNode(); length = 0; if (!head)throw"No Memory";//若没有new出来就抛出异常 head-&gt;next = 0; &#125; /*获得数据操作*/ bool Get(int index,T&amp; e) &#123; LNode* p = head-&gt;next;//这里的p指向的下一个元素的头指针 int j = 1; while (p &amp;&amp; j &lt; index) &#123; p = p-&gt;next;//把p的指针往后一个元素头指针移动 ++j; &#125; if (!p || j &gt; index) return false; e = p-&gt;data;//获得数据 return true; &#125; /*插入元素操作*/ bool InsertElement(int index, T e) &#123; LNode* p = head;//这里的p是指向头结点的指针，目的是要从第一个数据开始往下算下标 int j = 0; while (p &amp;&amp; j &lt; index-1)//定位到要插入元素位置的前一个元素（即：寻找前驱结点） &#123; p = p-&gt;next; ++j; &#125; if (!p || j &gt; index) return false; LNode* s = new LNode();//创建一个链表数据空间 s-&gt;data = e;//把要插入的数据放入这个空间 s-&gt;next = p-&gt;next;//这个新的空间的下一个指针地址是上一个元素的下一个元素地址 p-&gt;next = s;//上一个元素的下一个指针地址变为新空间的地址 length++; return true; &#125; /*删除元素操作*/ bool DeleteElement(int index) &#123; LNode* p = head;//定位到头结点 int j = 0;//从第0个元素开始移动指针 while (p &amp;&amp; j &lt; index - 1) &#123;//找到要删除元素数据的前一个位置 p = p-&gt;next; ++j; &#125; if (!p || j &gt; index) return false; LNode* q = p-&gt;next;//用一个临时指针存储要删除数据元素的位置（目的为了获取待删除数据元素的下一个数据元素的位置） p-&gt;next = q-&gt;next;//把前一个数据元素的下一个指针地址存储 delete q;//释放临时指针（即：要删除数据元素）的空间 length--; return true; &#125; /*前插操作*/ bool InsertFront(T e) &#123; LNode* q = new LNode();//创建一个新数据空间 if (!q)return false; q-&gt;data = e;//对要插入的数据进行赋值到这个空间的data q-&gt;next = 0;//避免第一个数据next指针出现野指针的问题 q-&gt;next = head-&gt;next;//与头结点相连 head-&gt;next = q;//这个next指针指向第二个数据的位置 length++; return true; &#125; /*往后插入操作*/ bool push_back(T e) &#123; LNode* p = head;//从头结点开始让指针指向最后一个数据元素的地址 LNode* q = new LNode(); int j = 0; while (p-&gt;next)//如果p-&gt;next为空指针，意味着找到了最后一个数据元素的地址 &#123; p = p-&gt;next; &#125; if (!p)return false; q-&gt;data = e;//进行data赋值 q-&gt;next = 0;//因为是后插，说明后面没有数据元素地址，让这个空间的next指针赋值为0 避免野指针问题 p-&gt;next = q;//原最后一个元素数据的next指向这个新插入的空间地址 length++; return true; &#125; /*设置操作*/ bool Set(int index, T e) &#123; LNode* p = head;//从头结点开始寻找要修改的位置 int j = 0; while (p &amp;&amp; j &lt; index) &#123; p = p-&gt;next; ++j; &#125; if (!p || j &gt; index) return false; p-&gt;data = e;//数据进行修改 return true; &#125; /*遍历操作*/ void Traverse(void(*fb)(T&amp; t)) &#123; LNode* p = head-&gt;next;//从头结点开始遍历每一个元素的data while (p) &#123; fb(p-&gt;data); p = p-&gt;next; &#125; &#125;private:&#125;;template&lt;typename T&gt;void Print(T&amp;t) &#123; cout &lt;&lt; t &lt;&lt; " ";&#125;int main() &#123; LkList&lt;char&gt; List; cout &lt;&lt; "前插了一个A " &lt;&lt; endl; List.InsertFront('A'); List.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "前插了一个B " &lt;&lt; endl; List.InsertFront('B'); List.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "后插了一个C " &lt;&lt; endl; List.push_back('C'); List.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "在第4个位置插入了O " &lt;&lt; endl; List.InsertElement(4, 'O'); List.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "在第4个位置插入了G " &lt;&lt; endl; List.InsertElement(4, 'G'); List.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "删除了第2位的元素 " &lt;&lt; endl; List.DeleteElement(2); List.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "把第3位的数据修改成I" &lt;&lt; endl; List.Set(3,'I'); List.Traverse(Print); cout &lt;&lt; endl; cout &lt;&lt; "获得第4位的数据 " &lt;&lt; endl; char ch; List.Get(4, ch); cout &lt;&lt; ch &lt;&lt; endl;&#125; —（本文完)&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-(2.4)初识链表]]></title>
    <url>%2F2019%2F06%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882.4%EF%BC%89%E5%88%9D%E8%AF%86%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表基本概念 结点包括数据域和指针域。 链表是有n个结点链结成，第一个结点的存储位置叫做头指针，最后一个结点的指针为“空”。 相较于顺序表存储结构的优点： 不用定义时规定长度。 存储的元素个数不受限制。 插入和删除元素时，不用移动其他元素。 链表的头指针和头结点 基本概念 头指针：链表中第一个结点的储存位置。 头结点：在单链表的第一个结点前附设的一个结点。 头指针 头结点 若链表有头结点，则是指向头结点的指针；若没有则是链表指向第一个结点的指针 头结点是为了操作的统一和方便而设立的，放在第一个结点之前 其数据域一般无意义（可以存储链表的长度） 头指针具有表示作用，所以常常有头指针表示链表的名字 有了头结点，在第一个结点前插入和删除第一个结点时，操作与其他结点的操作就统一了 无论链表是否为空，头指针均不为空。头指针是链表的必要元素 头结点不一定是链表的必须要素 链表存储结构 链表存储结构的特点是如何将数据域与“指标”（指针域）配对，以及指示下一条数据的内存位置。 链表存储结构中，数据存储在内存中分散的位置。各个数据由一个指针相互连接 一个数据中的指针域存放的是下一个数据的地址。 由于数据储存在不同的位置，每一个数据只能通过指针域中的指针来访问 删除：删除元素时只需将前一个数据的指针域指向要删除数据的下一个数据的地址即可，从而避免了顺序表存储结构多次的数据调换的麻烦。 添加：添加只需把要添加的位置的前一个数据的指针指向新数据，再让新数据的“指标”指向后一个数据的地址即可。 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.3）顺序表存储结构代码、算法实现]]></title>
    <url>%2F2019%2F06%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882.3%EF%BC%89%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81%E3%80%81%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[顺序表储存结构 顺序表(SqList) 定义： 顺序表存储结构是一个以连续空间地址存储为方式的物理结构 实现线性表相应操作： SqList（） 初始化线性表：创建一个空的线性表List SqList.InsertElement（index ， e） 在线性表List的index下标处插入元素e SqList.DeleteElement（ index， *e) 删除线性表List中的第i个元素，并返回删除元素指针e SqList.GetLength（） 获得线性表的长度 SqList.DeleteAllElement（） 清空线性表 SqList.find（e） 查找线性表中的元素e ………. 一些基础算法的实现思路 插入算法： 思路：根据想要插入的下标为准，用循环各各数值往后移动（即：相互覆盖赋值）空出指定下标进行插入赋值。从最后一个元素开始往后赋值 具体实现： 12345678910void InsertElement(int index, Datas t) &#123; length++;//因为要插入一个新的元素，故实际长度要加1 for (int i = length; i &gt; index; i--) &#123;//先把后面的元素全部往后覆盖赋值 datas[i] = datas[i - 1]; &#125; datas[index] = t;//在目标index位置插入新元素 &#125; 删除算法： 思路：根据要删除元素的下标为目标往前覆盖赋值。 具体实现： 1234567void DeleteElement(int index) &#123; for (int i = index; i &lt; length-1; i++) &#123; datas[i] = datas[i + 1]; &#125; length--;//每删除一个length（实际长度）将减少 &#125; 扩容： 思路：先判断是否是否满了，（即：用最大容量与实际长度相互比较如果相等那么就算满了），确定满容后先重新获得一个跟大的空间容量，然后把原来的线性表数组对其进行赋值。Delete原线性表数组，地址等于新扩容后的地址，完成扩容操作。 具体实现： 1234567891011121314if(length == capacity)//判断使用扩容的时机void realloc() &#123; T* p = new T[2 * capacity];//最大容量扩大两倍 for (int i = 0; i &lt; length; i++) &#123;//把原顺序表赋值到新顺序表 p[i] = datas[i]; &#125; delete[]datas;//清空原线性表里的元素 datas = p;//把新扩容后线性表的地址赋给datas p = NULL;//避免临时指针p变为野指针 capacity *= 2;//总容量扩大 &#125; 根据线性表用顺序存储结构实现的操作完成情况： 增加元素（完成） bool Push_back(T) 查找元素（完成） bool GetElement(int index,T&amp;c) 扩容（完成） bool realloc() 删除元素（完成） bool DeleteElement(int index) 插入元素(完成) bool InsertElement(int index, T t) 清空元素（完成）&lt;待完善修改&gt; bool DeleteAllElement() 代码详细：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include&lt;iostream&gt;#define MAX_SIZE 1 //定义最大容量using namespace std;template&lt;typename T&gt;class SqList&#123;private: T* datas; //线性表 int length = 0;//实际容量 int capacity;//总容量public: /*构造函数*/ SqList() &#123; capacity = MAX_SIZE;//总容量等于最大容量（进行初始化） datas = new T[capacity]; cout &lt;&lt; "初始化成功！！！" &lt;&lt; endl; &#125; /*获得总容量*/ int GetLength() &#123; return length; &#125; /*查找并取值操作*/ bool GetElement(int index, T&amp; c) &#123; if (index &lt; 0 || index &gt; length) return false; c = datas[index]; return true; &#125; /*增加元素操作*/ bool Push_back(T NewElem) &#123; if (length == capacity)//判断顺序表是否满了 &#123;//如果满了调用扩容操作 if(!realloc())//如果扩容失败那么Push_back也失败 return false; &#125; datas[length] = NewElem; length++; return true; &#125; /*设置元素操作*/ bool SetElement(int index, T t) &#123; if (index&lt;0 || index&gt;length)//判断下标是否输入正确 return false; datas[index] = t; return true; &#125; /*插入元素操作*/ bool InsertElement(int index, T t) &#123; if (index&lt;0 || index&gt;length)//判断下标是否输入正确 return false; length++;//因为要插入一个新的元素，故实际长度要加1 if (length == capacity)//判断顺序表是否满了 &#123;//如果满了调用扩容操作 if (!realloc())//如果扩容失败那么Push_back也失败 return false; &#125; for (int i = length; i &gt; index; i--) &#123;//先把后面的元素全部后退 datas[i] = datas[i - 1]; &#125; datas[index] = t;//在目标index位置插入新元素 return true; &#125; /*删除元素操作*/ bool DeleteElement(int index) &#123; if (index&lt;0 || index&gt;length)//判断下标是否输入正确 return false; for (int i = index; i &lt; length-1; i++) &#123; datas[i] = datas[i + 1]; &#125; length--;//每删除一个length（实际长度）将减少 return true;//删除动作完成后返回true &#125; /*清空元素操作*/ bool DeleteAllElement() &#123; int len = length; for (int i = 0; i &lt; len; i++) &#123; DeleteElement(0); &#125; return true; &#125; /*查找元素操作*/ int find(T e, int pos = 0) &#123; for (int i = pos; i &lt; length; i++) &#123; if(datas[i] == e) return i; &#125; return -1; &#125;private: /*扩容操作*/ bool realloc() &#123; T* p = new T[2 * capacity];//最大容量扩大两倍 cout &lt;&lt; "扩容成功！！！" &lt;&lt; endl; if (!p)return false; for (int i = 0; i &lt; length; i++) &#123;//把原顺序表赋值到新顺序表 p[i] = datas[i]; &#125; delete[]datas;//清空原线性表里的元素 datas = p;//把新扩容后线性表的地址赋给datas p = NULL;//避免临时指针p变为野指针 capacity *= 2;//总容量扩大 return true;//更换扩容操作完成后宣布扩容操作成功 &#125;&#125;;//打印顺序表操作template&lt;typename T&gt;//模版void Print(SqList&lt;T&gt;&amp; L) &#123; T e; for (int i = 0; i &lt; L.GetLength(); i++) &#123; L.GetElement(i, e); cout &lt;&lt; e &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; int main() &#123; SqList&lt;char&gt; List; char ch; if (!List.GetElement(1, ch)) cout &lt;&lt; "未找到" &lt;&lt; endl; cout &lt;&lt; "加入A" &lt;&lt; endl; List.Push_back('A'); Print(List); cout &lt;&lt; "加入B" &lt;&lt; endl; List.Push_back('B'); Print(List); cout &lt;&lt; "修改下标为1的B为G" &lt;&lt; endl; List.SetElement(1, 'G'); Print(List); cout &lt;&lt; "加入C" &lt;&lt; endl; List.Push_back('C'); Print(List); cout &lt;&lt; "加入D" &lt;&lt; endl; List.Push_back('D'); Print(List); cout &lt;&lt; "在下标为2的位置插入O" &lt;&lt; endl; List.InsertElement(2, 'O'); Print(List); cout &lt;&lt; "删除下标为1的G" &lt;&lt; endl; List.DeleteElement(1); Print(List); cout &lt;&lt; "寻找M的下标为： " &lt;&lt; List.find('M') &lt;&lt; endl; cout &lt;&lt; "清空了所有元素" &lt;&lt; endl; List.DeleteAllElement(); cout &lt;&lt; "加入F" &lt;&lt; endl; List.Push_back('F'); Print(List); cout &lt;&lt; "寻找A的下标为： " &lt;&lt; List.find('A') &lt;&lt; endl; cout &lt;&lt; "在下标9位置插入G" &lt;&lt; endl; List.InsertElement(9, 'G'); Print(List);&#125; —(本文完)&lt;原创&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大学学习个人计划及路线规划]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%E5%8F%8A%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! U2FsdGVkX1+7/iEXXHlsUesu8xTbwbcI9iPxY4YDinnH8x0rrbvKBPr/GnzW0i2sv9Os42LZ2u9dqvyDEgh82x5pnKv5MIJrBL34fBq4MvhVzvCCZn4BYwy4C24sUpiY1ncpdVpT6i1MzN+GZcXZxLKzNJC1XYzQJXN9Ps9jOV2mD3fRpzRNBuSww78qEzDdoeGIxLYZp6POBcaMK2pRokt/vBS0qBWLJQvDhQgk1K0qEp77a93/ldrbjPYLo0qb9smUPBFtaoy6LMTjfnLHHXSBQB2qbL4aYjmsV+hfD5jk4hv1JhiV4Ck4G1UNgqHhF0yP4ai2TyEbzQONNGM+aBQXEL08nRsHkPe1LnhsjU8jmFG8pfFnZ39m4AmnOHsP+BnIaQIIpRwFA3i9cna8IJ6LVDRZcpk0u2zFsSVbHFjtXGCNQPQ3JzBl1nJkjwdvSifRjJdLz8Ygc6oDgmO2cPFzq7Nt5u6E9lJ6KaQXDaotY4J/uDFPGyF/0vq3boXgtMjAXee4j62LSX9cCCdpf2Aue0Y+4kEwIgkj4D4CBo85uNvnWc98K7fmcaWnAF3PyE7vDtbju4i9sOYfOpnBm81DJfZQJYVC6bFY3Q8HoR6vu9E54SSpEr9sxOg7ktbbE1ClhBFeIkV07LV51bicn91p1sQio1uq45Tz0z+Kdc2rY7Pz0T8Rt7hzFuYx94GhCn+6Z0OeomnmnSjqflYprQGJoEf1wYBjbaF/GtPe5e0kppGp6vcrzhH/dA6KGdUeHQ/GndXwtkoi7D7hrIGQadaVXBK8T1B/nKjRlkxxjMRXc9YcRKEnf4jcaS6qXYH3mcWJzzVYVfN3wh1LagU+FOz1AwI6+d4Qd8vjkkDMnMl9n+7Wz3iIQB8Ncfi0GEqixeLoRe8rL/D3Q0jPLfVbEt3377phwt+6wtb9p0OwZaXF6zWQrudqfRHOizixlRG2nDTEIz7Gu7HI27GiNZtqCzEPT4s7JgMdIC0Ma3O1ZbU5X3XHcXESDL/8spjdq/6hJA7hKP5Zvsc/XmlXLVC4KXRJf2o63kyMTn7eO6VD+AyFFPx1q6Q8kChuBwFCnSZ1e+gTW0euOoCUpLtSdUPGXz0LfYTBZQFCiKMQDmF7SNFtzmAJKUaDAJyIkR3pZVi/pSK+zdIydLBPl/Np/0aMs9frCkbkHAoVOywccCD7GGxD+vrI7e1xda8xv4UGRm2paJ55wWE8e2YQBvNU7GYrNL3VPWqFuqds0XAS5/LGfhhVG31UWpERPHaXrOkktXehFk/C2GvZlt0QdKwdzHFGcA==]]></content>
      <categories>
        <category>个人随感</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
        <tag>目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.2）顺序表存储结构]]></title>
    <url>%2F2019%2F06%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882.2%EF%BC%89%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[顺序表结构 顺序存储结构的线性表—顺序表 定义：指的是用一段地址连续的存储单元依次存储线性表的数据元素（数组） 顺序表的构成 需要定义线性表的最大存储空间 define int Max_SIZE = 255; 线性表里需要有统一类型的元素集合 12345678910111213141516#define int MAX_SIZE = 255;//最大存储长度 /*定义线性表*/typedef int ElemType;//给int起一个别名 ElementTypetypedef struct&#123; int num;char* name;&#125;ElementType;/*定义顺序表结构*/typedef struct &#123; ElementType Datas[MAX_SIZE]; int length;//当前长度&#125;SeqList; —(本文完)&lt;待完善&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[石膏球（练习）]]></title>
    <url>%2F2019%2F06%2F14%2F%E7%9F%B3%E8%86%8F%E7%90%83%EF%BC%88%E7%BB%83%E4%B9%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>绘画</category>
        <category>练习</category>
      </categories>
      <tags>
        <tag>绘画练习</tag>
        <tag>素描</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习心得体会]]></title>
    <url>%2F2019%2F06%2F14%2FJava%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[​ 先简单说一下我对于编程这一门课程个人感受吧，编程说难也难，但说它简单也不过分。难，难在程序编写过程的中的思考方式。简单，就简单在一旦你掌握了基本语句和方法的基础下，有着一个活跃的思维思考能力，程序编程基本都是水到渠成的事。接下来我就简单说下我个人对于Java学习过程中一些心得和学习方法供大家参考一下吧。 心得：​ 首先我在大一是有接触过C++的，刚拿到课本也是一头雾水，看不明白。但在深入学习后，我认为掌握一门程序语言重要的不是知道它具体的语法和规则，而是运用这些语法和规则时的思维。为什么编程的思维很重要呢？这是一个很现实的问题，如今知识更新快，社会发展非常快，意味着编程语言的变化也是很无常的，或许你刚掌握了java语言，市场上就有了更好的编程语言。这就意味着你要继续学习新的语言和知识，如果此时你有一个活跃的编程思维，去接触新的语言学会它会非常容易。 说了这么多思维很重要，那编程思维到底是怎样的？举个小例子：假设你要编程一个超市商品结账的程序，先不要想怎么去编写它。先去思考一下，假如你在超市工作并给一个顾客买的两个东西结账。结账时你要做的事情：你要先识别他买的两个东西单价分别是多少钱，买了多少个，总金额多少，付钱结账最后打印一个小票给这个顾客。简化下来就是：1.识别物品，2.计算金额3.打印信息。好的！接下来用编程来搞定它，1.识别物品从你一大堆的商品信息中找到这个商品的信息。怎么编这个功能？用循环被一个个找。找到同名的商品并得到它的金额信息就可以了。2.计算金额 用循环累加，3.打印出信息 完成本次结账，程序结束。从上面可以看出编这个程序思考方向：明确你程序要干的事情是什么（目的是结账），干这个事情有什么动作（1.识别食品找到对应的价格2.计算总金额3.打印信息），完成这些动作要用什么方法（1.可以用循环来找或其他方法2.每一项金额累加3.打印上面步骤得到的数据信息）。你能在看见一个动作就能想到一个方法去解决它。这就要靠活跃的思维，怎么样用你所学到的编程规则与语句对应想出编写针对它解决它的方法，这就是一个编程的思维。 学习方法：​ 根据上文所述的思维的方式我说下我自己的学习方法供大家参考。 根据自己的想法用自己的话去总结每一章学习的知识：这里要注意！自己每次学习完一章内容尽量地去总结且一定要根据自己的话和自己的思考去总结不能网上复制粘贴一下概念知识。这样做有两个好处：①加固加深你所学的知识，毕竟是根据自己思考后总结出来的、②培养独立的学习思考能力（说白了就是把你学到的知识用自己的理解写一个类似于教材的总结）。 建立编程错误库：其实很多人在编程的时候都会遇到红标报错，这是很正常的事情我们本来就是在试错中才能积累经验。你每一次出错，如果你有时间可以编写一个文档计入每一次遇到的新的报错 并且记录下错因是什么 怎么去解决，这样遇到同样的错误就会有条件反射：“哦！我以前犯过NullPointException的错误，这个错误是空指针错误，原因是有一个对象没有给它空间，应该调用它的构造方法去解决它。”慢慢的就会有独立去解决这些错误的能力了。当然如果你没有多余的时间，也可以让自己的脑子去记下来QWQ。 找个好（ji）朋友进行讨论和思维碰撞：单干是很寂寞的。可以找一个好朋友、舍友进行思维碰撞和讨论。这也很重要！为什么，因为每一个对同一个问题的思考方式、方向都不可能完全相同的。通过思维的交汇，朋友间能相互提高且提高的跟快。再者可以有效的避免一些舍友之间的矛盾。 兴趣主导目标引领：有一个学习目标是很重要的，当然这得取决你不会去排斥它，就如编程。你主动爱它虽然它不会爱你_(:з」∠)_。但你排斥它，它也一定会排斥你这也是必然的。所以学好一门课首先是要培养出对它的兴趣，然后java语言与其他编程语言一样，学习它时候是要用大量的课余时间去练习它。练习也是要有目的的，你可以就按每次作业的要求去学习它，在完成作业后，你也可以自己想一点小玩意供自己去练习。例如：你看见你去钱用的很乱，你就会想编一个记账的小程序，然后就有一个目标出现了。你就会根据你的小目标去主动学习主动搜索你所需要的知识。学习一门课程，只要你站在主动的一方，一切问题就非常好解决了。 从初学就养成良好的编码习惯：这里有些人可能有点疑问，码是我编的，我想咋编就咋编我看得懂就ok这样的思想是很错误的。首先这样做DEbug会非常辛苦，现在是小程序可能体会不出来，当你编写几百行几万行以上的代码就会痛苦的不得了。（个人亲试过：你体验过自己编了700多行代码的程序，de一个bug蹦出一堆bug的快感吗？）。这里我非常推荐一点要写注释！特别是自己想的方法。这样做有两个好处：①这样你编写这个方法的时候思路会比较明确，知道每一步要怎么去做。 ②.对于以后工作写文档会有用处，未来的代码是要给别人看的。 然后我提一点其他的好习惯吧。㈠定义变量的时候命名让它有意义，且在定义的时候一个变量占一行，有关联的变量尽量相近定义。㈡善用回车换行，这里举一个简单的例子吧。每个方法尽量用两个回车来分开。这样做，一是方便注释，二是方便分辨每一个方法体，且美观。这里要注意回车换行适度就行，不宜太多。其他方法可以搜索网上资料。这里就不一一叙述了。养成良好的编程习惯一是方便你自己，二来也对未来工作有非常大的帮助。 尽量先靠自己去想怎么做：不要一遇到不会就百度、参考其他同学的代码。切记！有人会说，参考后我会自己去理解，之后也不是会变成我自己的知识吗？这样说吧：这样做好比你在海上航行，你知道答案了就像你知道目的地的准确位置了，接下来你只需把船开过去即可，但正常情况下，你应该要靠自己的能力去找目的地而不是知道它在哪的前提下去航海。未来工作也是这样。一个是逆向思考，另一个是正向思考。两者是不一样的。所以我们一定要先独立思考。直到真的完全不会了再去参考学习。每次都参考别人的东西去学习，会导致一个依赖感长期的逆向思考，到了真的要自己动手的时候发现一点都不会。这也解释了一些同学看得懂代码，自己动手却什么都不会的原因。 ​ 最后我先明确我的这些理解和见解只供大家去参考。我的一些理解和心得可能没有你们的好，学习方法或许你的也会更棒。所以不要太局限于我的见解QAQ。 —（本文完）&lt;原创&gt;]]></content>
      <categories>
        <category>个人随感</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>心得体会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2.1）线性表的抽象数据类型]]></title>
    <url>%2F2019%2F06%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882.1%EF%BC%89%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[线性表 定义： 零个或多个数据元素的有限序列。 特点: 它是一个序列 数据元素之间是有有序的。 数据元素之间是一对一的关系。 有限性 两个数据元素的有限序列称为空表。 常见线性表的操作： 删除 插入 创建 初始化 清空 查找 线性表的抽象数据类型 ADT 线性表(List) Data 线性表数据元素是一个集合{a_1 , a_2 , a_3 , …. , a_n},数据元素的类型DataType（int , char ,…)。 除了第一个（a_1）元素外，每个元素有且只有一个直接的前驱元素。 例如 : a_2的前驱元素是a_1。 除了最后一个（a_n）元素外，每一个元素有且只有一个直接的后继元素。 例如: a_3是a_2的后继元素。 Operation InitList（*List） 初始化线性表：创建一个空的线性表List InsertElement（*List ， index ， e） 在线性表List的index下标处插入元素e DeleteElement（List ， index， e) 删除线性表List中的第i个元素，并返回删除元素指针e GetLength（*List） 获得线性表的长度 IsEmpty（*List） 判断线性表是否为空表 ClearList（*List） 清空线性表 ExsitElement（*List ， e） 查找线性表中的元素e endADT 个人理解：​ 在实际上，线性表可以理解为一群人在排队，排队的都是人（数据元素类型相同），然后他们是排成一条线的。首先排队的人肯定是有限的（即：有限性）其次他们每一个人是相互连成一条线的，即一个人跟着一个人有顺序（即：一对一、有序的）。 ​ 再者，这队排队的人，除了第一个人前面没人，最后一个人后面没人外。其中每一个人都是前后都有人的。例如第二个人的前面是第一个人（即：第一个人为第二个人的前驱元素），而第三个人是第二个人的后面（即：第三个人为第二个人的后继元素）。 ​ 这队排队的人是在等待上车的。他们之间可能会有人在中途想上厕所从而离开了队伍（即：删除），又或者有人在后面加入进去了（即：增加），这时检票员也会一一核对信息对照人员表查找每一个人是否到齐了（即：查找），这时上厕所的人回来了因为这队人是有顺序的，所以这位回来的也可以插入原来的位置（即：插入）。 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（2）第二章预习]]></title>
    <url>%2F2019%2F06%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%882%EF%BC%89%E7%AC%AC%E4%BA%8C%E7%AB%A0%E9%A2%84%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[问题： 线性表的顺序存储的优点和缺点有哪些？ 线性表的删除和插入算法的思路？ 数组长度和线性表长度的区别？ 顺序存储结构的三大属性？ —（本文未完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-(1.2)抽象数据类型]]></title>
    <url>%2F2019%2F06%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%881.2%EF%BC%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[抽象数据类型数据类型 定义： 计算机中，内存空间是最有限的，不同的类型的数据分配的内存空间大小不同。 例如：在C++ 中 整型占4个字节，双精度浮点数占8个字节等等 数据类型就是指一组性质相同的值和集合及定义在此集合上的一些操作的总称 例如在C/C++语言中的数据类型中是按取值不同分类的数据类型 原子型（不可再分）：不可再分的数据类型。例如：int(整型)、double（双精度浮点型）等等 结构型（可再分）：若干个数据类型（包括原子型和结构型）组成的一个组合。例如：数组，类，结构体（C/C++）等。 抽象数据类型（Abstruct Data Type[ADT]) 定义：是对已有的数据类型进行抽象 抽象数据类型是指一个数据**模型**及定义在该模型上的一组操作 - 模板： ADT 抽象数据类型名 Data 数据元素之间的逻辑关系的定义 Operation 操作1 初始条件 操作结果描述 操作2 … 操作n … endADT 个人理解：通过套用上面的模板 解释int（整型数据类型） int（整型） 是以线性结构存储一个int（整型）数据类型占4个字节 Operation 操作1：加法 需要两个数 结果为两个数的和 操作2：减法 需要两个数 结果为两个数的差 操作3：乘法 … 操作4：除法 … 个人总结： 用自己的话简述下列术语： 数据：类似一个或几个人的全部基本信息（姓名、性别、爱好等）。 数据元素：人基本类型里面的单一个姓名、性别等。 数据对象：单一个人的基本信息。 数据结构：数据通过一定的结构、关系（计算方法【算法】）存储起来就是数据结构 例如：上面所说的数据 —多个人的基本信息 一般是用列表格的形式存储的，即所用的是线性逻辑结构存储的。 存储结构（物理结构）：是对逻辑结构在计算机上的表示。即对上面的数据结构在计算机进行实习，如果是顺序存储结构，那么这些个人基本信息可能是用数组储存起来的。 数据类型：例如 整型、浮点型就是一个数据类型，数据类型是一组相同值和其每个值之间特有的关系上的操作的总称。例如整型，它每一个数据元素都是一个整数，他们可以进行加减乘除等操作。 抽象数据类型：类似于数据类型，但是把一些东西抽象化成数据类型。例如游戏角色，它的数据元素（对比就是整型里面的整数）有很多，例如武器、玩家属性等、这个数据类型可以执行的动作有移动攻击等。 数据结构和抽象数据类型的概念与程序设计语言中的数据类型概念的区别 抽象数据类型是对软件设计过程中问题模型抽象出来的逻辑结构和在逻辑结构上的运算。 数据结构是计算机处理元素的组织形式的相互关系。 程序设计语言中的数据类型是已经实现了的数据结构。 即：一个还没有被实现（抽象数据类型）一个是已经实现的了（程序设计语言中的数据类型） 而数据结构是指： 数据的相互之间存在一种或多种特点关系的数据元素的集合。 --（本文完）&lt;待完善&gt;]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java模拟考心得体会]]></title>
    <url>%2F2019%2F06%2F12%2FJava%E6%A8%A1%E6%8B%9F%E8%80%83%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[今天进行了Java期末考试的模拟考，颇有心得与感触，以本文进行叙述：遇到的问题比较多：例如 &gt;&gt; 与 &gt;&gt;&gt;运算符 这里的意思是这样的 &gt;&gt;有符号的右移这是对二进制的数来说的 int i=8，那么 i &gt;&gt; 2就是二进制往右移两位，即：（0）1000【8】 往右移两位就是 （0）0010【2】，而&gt;&gt;&gt;就是不考虑符号位。 jpane的默认布局是流式布局 （我居然写BorderLayout） 其次是swing包里面的 按钮监听器不太熟 警示： 千万不要在程序设计或填空 题目里面用Shift + F 格式化 切记切记！！ 其他知识点： 按钮监听器重写方法：public void actionPerformed(ActionEvent event) 对于子类可以从父类继承的成员变量，只要子类中声明的成员变量和父类中的成员变量同名时，子类就隐藏了继承的成员变量，子类自己声明定义的方法操作与父类同名的成员变量是指子类重新声明定义的这个成员变量。 —（本文完）]]></content>
      <categories>
        <category>个人随感</category>
      </categories>
      <tags>
        <tag>心得体会</tag>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结-（1.1）数据结构的基本概念]]></title>
    <url>%2F2019%2F06%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%EF%BC%881.1%EF%BC%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[数据结构的基本概念五个基本概念：数据 定义：描述客观事物的符号，是计算机中可以操作的对象。 个人理解：类似于整型，或者一个文件都是可以看出数据。实际情况：例如我输入的账号密码就算是为数据 数据元素 定义：组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。 数据元素是数据结构的聚焦点 个人理解：把数据比喻成一个文件夹，那么数据元素就应该是里面的一个不可分的文件（高达模型上面的一个零件？）。 数据项 定义： 一个数据元素可以由若干个数据项组成。 个人理解 ： 数据元素比作对象，那么数据项就类似于对象的属性（成员变量）。例如：上面输入信息时，用户名和密码分别就算是数据项 数据对象 定义： 性质相同的数据元素的集合，是数据的子集。 个人理解：这个应该是介于数据和数据项中间的东西 数据结构（data structure） 定义：数据结构是相互之间存在一种或多种特定关系的数据元素的集合。 数据元素 + 特定关系 = 数据结构 总结：用实际情形来描述，你在一个网站上进行注册，要求填写个人形象，其中里面的姓名、密码就是 数据项 ，每一个数据项组成的就是一个 数据元素 ，数据元素一多起来就统称为：数据 逻辑结构 集合结构 图形结构（图） 树形结构（皇帝与丞民） 线性结构 物理结构 定义：又叫存储结构，是指数据的逻辑结构在计算机中的存储形式。 顺序存储结构 ：类似于数组 ，把数据元素存储在地址连续的储存单元里。 链式存储结构 ：把数据元素存放在任意的存储单元里 类似于数组，但可以不连续，每一个数值直接有一个类似于绳子或链条的东西相互绑定。 类似指针 —（本文完）]]></content>
      <categories>
        <category>代码学习</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>数据结构</tag>
        <tag>数据结构-学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[石膏立方体（练习）]]></title>
    <url>%2F2019%2F06%2F11%2F%E7%9F%B3%E8%86%8F%E7%AB%8B%E6%96%B9%E4%BD%93%EF%BC%88%E7%BB%83%E4%B9%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>绘画</category>
        <category>练习</category>
      </categories>
      <tags>
        <tag>绘画练习</tag>
        <tag>素描</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[置顶]欢迎来到ShuHaoHwang的博客！！]]></title>
    <url>%2F2019%2F06%2F11%2F%5B%E7%BD%AE%E9%A1%B6%5D%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%9C%AC%E5%8D%9A%E4%B8%BB%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%81%EF%BC%81%2F</url>
    <content type="text"><![CDATA[本博客将先会以个人的学习总结为主，之后将更新一些技术性的文章，欢迎与博主进行探讨、一起思维碰撞。在吉珠的小伙伴还可以联系博主哦！ 欢迎留言，博主在有空之余将一一进行查看并回复。]]></content>
  </entry>
</search>
